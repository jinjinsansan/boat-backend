"""
ViewLogicå±•é–‹äºˆæƒ³ã‚¨ãƒ³ã‚¸ãƒ³
è„šè³ªåˆ¤å®šã€ãƒšãƒ¼ã‚¹äºˆæ¸¬ã€å±•é–‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œã†
è¨ˆç”»æ›¸é€šã‚Šã®å®Œå…¨å®Ÿè£…ç‰ˆ
"""

import logging
import json
import random
from typing import Dict, List, Optional, Tuple, Any
from statistics import mean, stdev
import math
import hashlib
import time
from datetime import datetime, timedelta
from .jockey_knowledge_manager import get_jockey_knowledge_manager

# numpy import with fallback
try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False
    # Fallback implementations
    class np:
        @staticmethod
        def percentile(data, percentile):
            """Simple percentile calculation without numpy"""
            if not data:
                return 0
            sorted_data = sorted(data)
            index = int(len(sorted_data) * percentile / 100)
            return sorted_data[min(index, len(sorted_data) - 1)]

logger = logging.getLogger(__name__)


def safe_int(value, default=0):
    """çµ±åˆãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®æ–‡å­—åˆ—æ•°å€¤ã‚’å®‰å…¨ã«æ•´æ•°ã«å¤‰æ›"""
    if value is None:
        return default
    try:
        return int(value)
    except (ValueError, TypeError):
        return default


class RunningStyleAnalyzer:
    """è„šè³ªåˆ¤å®šã¨3æ®µéšåˆ†é¡ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
    
    def classify_basic_style(self, horse_races: List[Dict]) -> str:
        """åŸºæœ¬4åˆ†é¡ï¼ˆé€ƒã’/å…ˆè¡Œ/å·®ã—/è¿½è¾¼ï¼‰ã‚’åˆ¤å®š"""
        if not horse_races:
            return "ä¸æ˜"
        
        # 1ã‚³ãƒ¼ãƒŠãƒ¼é€šéé †ä½ã®å¹³å‡ã‚’è¨ˆç®—
        corner1_positions = []
        for race in horse_races:
            if 'CORNER1_JUNI' in race:
                try:
                    corner1_pos = int(race['CORNER1_JUNI'])
                    if corner1_pos > 0:
                        corner1_positions.append(corner1_pos)
                except (ValueError, TypeError):
                    continue
        
        if not corner1_positions:
            return "ä¸æ˜"
        
        avg_corner1 = mean(corner1_positions)
        
        if avg_corner1 <= 2.0:
            return "é€ƒã’"
        elif avg_corner1 <= 5.0:
            return "å…ˆè¡Œ"
        elif avg_corner1 <= 9.0:
            return "å·®ã—"
        else:
            return "è¿½è¾¼"
    
    def classify_detailed_style(self, basic_style: str, horse_races: List[Dict]) -> Tuple[str, str]:
        """3æ®µéšè©³ç´°åˆ†é¡ã‚’è¡Œã†"""
        if basic_style == "é€ƒã’":
            return self._classify_escape_details(horse_races)
        elif basic_style == "å…ˆè¡Œ":
            return self._classify_stalker_details(horse_races)
        elif basic_style == "å·®ã—":
            return self._classify_closer_details(horse_races)
        elif basic_style == "è¿½è¾¼":
            return self._classify_latecloser_details(horse_races)
        else:
            return basic_style, "æ¨™æº–"
    
    def _classify_escape_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """é€ƒã’é¦¬ã®è©³ç´°åˆ†é¡"""
        solo_escape_count = 0
        escape_success_count = 0
        escape_races = 0
        
        for race in horse_races:
            corner1 = safe_int(race.get('CORNER1_JUNI'), 99)
            corner2 = safe_int(race.get('CORNER2_JUNI'), 99)
            finish = safe_int(race.get('KAKUTEI_CHAKUJUN'), 99)
            
            # é€ƒã’ãŸå ´åˆ
            if corner1 <= 2:
                escape_races += 1
                
                # å˜ç‹¬é€ƒã’ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ2ã‚³ãƒ¼ãƒŠãƒ¼ã§ã‚‚å…ˆé ­ï¼‰
                if corner2 == 1:
                    solo_escape_count += 1
                
                # é€ƒã’ã¦3ç€ä»¥å†…
                if finish <= 3:
                    escape_success_count += 1
        
        if escape_races == 0:
            return "é€ƒã’", "æ¶ˆæ¥µé€ƒã’"
        
        solo_rate = solo_escape_count / escape_races
        success_rate = escape_success_count / escape_races
        
        if solo_rate > 0.6:
            return "é€ƒã’", "è¶…ç©æ¥µé€ƒã’"
        elif success_rate > 0.5:
            return "é€ƒã’", "çŠ¶æ³é€ƒã’"
        else:
            return "é€ƒã’", "æ¶ˆæ¥µé€ƒã’"
    
    def _classify_stalker_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """å…ˆè¡Œé¦¬ã®è©³ç´°åˆ†é¡"""
        corner1_positions = []
        position_stability = 0
        
        for race in horse_races:
            corner1 = safe_int(race.get('CORNER1_JUNI'), 99)
            if corner1 < 99:
                corner1_positions.append(corner1)
        
        if not corner1_positions:
            return "å…ˆè¡Œ", "æ¨™æº–å…ˆè¡Œ"
        
        avg_corner1 = mean(corner1_positions)
        
        # ä½ç½®å–ã‚Šã®å®‰å®šæ€§ã‚’è¨ˆç®—ï¼ˆæ¨™æº–åå·®ãŒå°ã•ã„ã»ã©å®‰å®šï¼‰
        if len(corner1_positions) > 1:
            position_stability = 1 / (1 + stdev(corner1_positions))
        else:
            position_stability = 0.5
        
        if avg_corner1 <= 3.5 and position_stability > 0.8:
            return "å…ˆè¡Œ", "å‰å¯„ã‚Šå…ˆè¡Œ"
        elif position_stability > 0.7:
            return "å…ˆè¡Œ", "å®‰å®šå…ˆè¡Œ"
        else:
            return "å…ˆè¡Œ", "å¾Œå¯„ã‚Šå…ˆè¡Œ"
    
    def _classify_closer_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """å·®ã—é¦¬ã®è©³ç´°åˆ†é¡"""
        finishing_power_scores = []
        
        for race in horse_races:
            corner4 = safe_int(race.get('CORNER4_JUNI'), 99)
            finish = safe_int(race.get('KAKUTEI_CHAKUJUN'), 99)
            
            if corner4 < 99 and finish < 99:
                # 4ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã‚‰ç€é †ã¸ã®æ”¹å–„åº¦
                improvement = corner4 - finish
                finishing_power_scores.append(improvement)
        
        if not finishing_power_scores:
            return "å·®ã—", "æ¨™æº–å·®ã—"
        
        avg_improvement = mean(finishing_power_scores)
        
        if avg_improvement > 3:
            return "å·®ã—", "å¼·çƒˆå·®ã—"
        elif avg_improvement > 1:
            return "å·®ã—", "ç¢ºå®Ÿå·®ã—"
        else:
            return "å·®ã—", "é…ã‚å·®ã—"
    
    def _classify_latecloser_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """è¿½è¾¼é¦¬ã®è©³ç´°åˆ†é¡"""
        extreme_finishes = 0
        total_races = len(horse_races)
        
        for race in horse_races:
            corner4 = safe_int(race.get('CORNER4_JUNI'), 99)
            finish = safe_int(race.get('KAKUTEI_CHAKUJUN'), 99)
            
            if corner4 > 10 and finish <= 3:
                extreme_finishes += 1
        
        if total_races == 0:
            return "è¿½è¾¼", "æ¨™æº–è¿½è¾¼"
        
        extreme_rate = extreme_finishes / total_races
        
        if extreme_rate > 0.3:
            return "è¿½è¾¼", "æ¥µé™è¿½è¾¼"
        elif extreme_rate > 0.1:
            return "è¿½è¾¼", "å¼·åŠ›è¿½è¾¼"
        else:
            return "è¿½è¾¼", "é€šå¸¸è¿½è¾¼"
    
    def calculate_differentiation_score(self, horse_data: Dict, horse_races: List[Dict]) -> float:
        """18é ­åŒä¸€è„šè³ªã®å ´åˆã®å·®åˆ¥åŒ–ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ100ç‚¹æº€ç‚¹ï¼‰"""
        score_components = {
            'solo_escape': 0,      # å˜ç‹¬é€ƒã’å®Ÿç¸¾ï¼ˆ40%ï¼‰
            'start_dash': 0,       # ã‚¹ã‚¿ãƒ¼ãƒˆãƒ€ãƒƒã‚·ãƒ¥åŠ›ï¼ˆ25%ï¼‰
            'tenacity': 0,         # é€ƒã’ç²˜ã‚Šåº¦ï¼ˆ20%ï¼‰
            'competition': 0,      # ç«¶ã‚Šåˆã„è€æ€§ï¼ˆ10%ï¼‰
            'recent_form': 0       # æœ€è¿‘ã®å‹¢ã„ï¼ˆ5%ï¼‰
        }
        
        # 1. å˜ç‹¬é€ƒã’å®Ÿç¸¾
        solo_count = 0
        total_escapes = 0
        for race in horse_races:
            if safe_int(race.get('CORNER1_JUNI'), 99) <= 2:
                total_escapes += 1
                if safe_int(race.get('CORNER2_JUNI'), 99) == 1:
                    solo_count += 1
        
        if total_escapes > 0:
            score_components['solo_escape'] = (solo_count / total_escapes) * 40
        
        # 2. ã‚¹ã‚¿ãƒ¼ãƒˆãƒ€ãƒƒã‚·ãƒ¥åŠ›ï¼ˆç°¡æ˜“è¨ˆç®—ï¼‰
        corner1_avg = mean([safe_int(r.get('CORNER1_JUNI'), 10) for r in horse_races[:5]])
        score_components['start_dash'] = max(0, (10 - corner1_avg) * 2.5)
        
        # 3. é€ƒã’ç²˜ã‚Šåº¦
        success_count = 0
        escape_count = 0
        for race in horse_races:
            if safe_int(race.get('CORNER1_JUNI'), 99) <= 3:
                escape_count += 1
                if safe_int(race.get('KAKUTEI_CHAKUJUN'), 99) <= 3:
                    success_count += 1
        
        if escape_count > 0:
            score_components['tenacity'] = (success_count / escape_count) * 20
        
        # 4. ç«¶ã‚Šåˆã„è€æ€§ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
        score_components['competition'] = 5  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        
        # 5. æœ€è¿‘ã®å‹¢ã„
        recent_races = horse_races[:3] if len(horse_races) >= 3 else horse_races
        recent_corner1 = [safe_int(r.get('CORNER1_JUNI'), 99) for r in recent_races]
        if recent_corner1:
            recent_avg = mean(recent_corner1)
            if recent_avg <= 3:
                score_components['recent_form'] = 5
        
        # ç·åˆã‚¹ã‚³ã‚¢è¨ˆç®—
        total_score = sum(score_components.values())
        return min(100, total_score)


class BayesianCorrector:
    """ãƒ™ã‚¤ã‚ºè£œæ­£ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
    
    def correct_rate(self, success_count: int, total_count: int, 
                    prior_mean: float = 0.20, prior_weight: float = 5) -> Dict[str, float]:
        """
        ãƒ™ã‚¤ã‚ºè£œæ­£ã§å°‘ãªã„ã‚µãƒ³ãƒ—ãƒ«æ•°ã®å½±éŸ¿ã‚’ç·©å’Œ
        
        Parameters:
        - success_count: æˆåŠŸå›æ•°ï¼ˆè¤‡å‹å›æ•°ï¼‰
        - total_count: ç·è©¦è¡Œå›æ•°ï¼ˆå‡ºèµ°å›æ•°ï¼‰
        - prior_mean: äº‹å‰å¹³å‡ï¼ˆå…¨ä½“ã®è¤‡å‹ç‡ï¼‰
        - prior_weight: äº‹å‰åˆ†å¸ƒã®é‡ã¿ï¼ˆä¿¡é ¼åº¦ï¼‰
        """
        if total_count == 0:
            return {
                "corrected_rate": prior_mean,
                "confidence": 0.0,
                "raw_rate": 0.0
            }
        
        # ãƒ™ã‚¤ã‚ºæ¨å®šã«ã‚ˆã‚‹äº‹å¾Œç¢ºç‡
        posterior = (success_count + prior_mean * prior_weight) / (total_count + prior_weight)
        
        # ä¿¡é ¼åŒºé–“ã®è¨ˆç®—
        confidence = min(total_count / (total_count + prior_weight), 1.0)
        
        # ç”Ÿã®ç¢ºç‡
        raw_rate = success_count / total_count if total_count > 0 else 0
        
        return {
            "corrected_rate": posterior,
            "confidence": confidence,
            "raw_rate": raw_rate
        }


class RaceFlowPredictor:
    """ãƒ¬ãƒ¼ã‚¹å±•é–‹äºˆæƒ³ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.style_analyzer = RunningStyleAnalyzer()
        self.bayesian = BayesianCorrector()
    
    def predict_pace(self, all_horses_data: List[Dict]) -> Dict[str, Any]:
        """ãƒšãƒ¼ã‚¹äºˆæ¸¬ï¼ˆãƒã‚¤/å¹³å‡/ã‚¹ãƒ­ãƒ¼ï¼‰"""
        # å„é¦¬ã®è„šè³ªã‚’åˆ¤å®šï¼ˆé¦¬ç•ªä»˜ãï¼‰
        style_distribution = {
            'é€ƒã’': {'count': 0, 'horses': [], 'horse_numbers': []},
            'å…ˆè¡Œ': {'count': 0, 'horses': [], 'horse_numbers': []},
            'å·®ã—': {'count': 0, 'horses': [], 'horse_numbers': []},
            'è¿½è¾¼': {'count': 0, 'horses': [], 'horse_numbers': []},
            'ä¸æ˜': {'count': 0, 'horses': [], 'horse_numbers': []}
        }
        
        detailed_escapes = {
            'è¶…ç©æ¥µé€ƒã’': [],
            'çŠ¶æ³é€ƒã’': [],
            'æ¶ˆæ¥µé€ƒã’': []
        }
        
        # ã‚¹ã‚¿ãƒ¼ãƒˆäº‹æ•…ãŒã‚ã‚‹é¦¬ã‚’è¨˜éŒ²
        start_accident_horses = []
        start_accident_numbers = []
        
        for idx, horse_data in enumerate(all_horses_data, 1):
            if 'races' not in horse_data:
                continue
            
            horse_name = horse_data.get('horse_name', 'ä¸æ˜')
            horse_number = horse_data.get('horse_number', idx)  # é¦¬ç•ªï¼ˆãªã‘ã‚Œã°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
            
            # è„šè³ªåˆ¤å®š
            basic_style = self.style_analyzer.classify_basic_style(horse_data['races'])
            style_distribution[basic_style]['count'] += 1
            style_distribution[basic_style]['horses'].append(horse_name)
            style_distribution[basic_style]['horse_numbers'].append(horse_number)
            
            # é€ƒã’é¦¬ã®è©³ç´°åˆ†é¡
            if basic_style == 'é€ƒã’':
                _, sub_style = self.style_analyzer.classify_detailed_style(basic_style, horse_data['races'])
                detailed_escapes[sub_style].append(horse_name)
            
            # ã‚¹ã‚¿ãƒ¼ãƒˆäº‹æ•…ãƒã‚§ãƒƒã‚¯ï¼ˆç›´è¿‘5èµ°ï¼‰
            recent_races = horse_data.get('races', [])[:5]
            for race in recent_races:
                # ç™ºèµ°é †ä½ãŒé¦¬ç•ªã‚ˆã‚Š3ä»¥ä¸Šé…ã„å ´åˆã¯å‡ºé…ã‚Œã¨åˆ¤å®š
                if 'HASSOUJUN' in race and 'UMA_BAN' in race:
                    if race['HASSOUJUN'] - race['UMA_BAN'] >= 3:
                        if horse_number not in start_accident_numbers:
                            start_accident_horses.append(horse_name)
                            start_accident_numbers.append(horse_number)
                        break
        
        # ãƒšãƒ¼ã‚¹åˆ¤å®š
        super_aggressive_count = len(detailed_escapes['è¶…ç©æ¥µé€ƒã’'])
        situational_count = len(detailed_escapes['çŠ¶æ³é€ƒã’'])
        
        if super_aggressive_count >= 2:
            pace = "ãƒã‚¤ãƒšãƒ¼ã‚¹æ¿ƒåš"
            confidence = 90
        elif super_aggressive_count == 1 and situational_count >= 3:
            pace = "ã‚„ã‚„ãƒã‚¤ãƒšãƒ¼ã‚¹"
            confidence = 70
        elif situational_count >= 5:
            pace = "å¹³å‡ãƒšãƒ¼ã‚¹"
            confidence = 60
        else:
            pace = "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹"
            confidence = 80
        
        return {
            'pace': pace,
            'confidence': confidence,
            'style_distribution': style_distribution,
            'detailed_escapes': detailed_escapes,
            'start_accident_horses': start_accident_horses,
            'start_accident_numbers': start_accident_numbers
        }
    
    def identify_advantaged_horses(self, pace: str, all_horses_data: List[Dict]) -> Dict[str, List[str]]:
        """æœ‰åˆ©/ä¸åˆ©ãªé¦¬ã‚’ç‰¹å®š"""
        advantaged = []
        disadvantaged = []
        
        for horse_data in all_horses_data:
            if 'races' not in horse_data:
                continue
            
            horse_name = horse_data.get('horse_name', 'ä¸æ˜')
            basic_style = self.style_analyzer.classify_basic_style(horse_data['races'])
            
            # ãƒšãƒ¼ã‚¹ã«å¿œã˜ãŸæœ‰åˆ©ä¸åˆ©åˆ¤å®š
            if pace in ["ãƒã‚¤ãƒšãƒ¼ã‚¹æ¿ƒåš", "ã‚„ã‚„ãƒã‚¤ãƒšãƒ¼ã‚¹"]:
                if basic_style in ["å·®ã—", "è¿½è¾¼"]:
                    advantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
                elif basic_style in ["é€ƒã’", "å…ˆè¡Œ"]:
                    disadvantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
            elif pace == "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹":
                if basic_style in ["é€ƒã’", "å…ˆè¡Œ"]:
                    advantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
                elif basic_style == "è¿½è¾¼":
                    disadvantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
        
        return {
            'advantaged': advantaged[:5],  # ä¸Šä½5é ­ã¾ã§
            'disadvantaged': disadvantaged[:5]
        }
    
    def generate_race_scenario(self, all_horses_data: List[Dict]) -> str:
        """å±•é–‹ã‚·ãƒŠãƒªã‚ªã‚’ç”Ÿæˆ"""
        pace_result = self.predict_pace(all_horses_data)
        
        scenario = f"ã€å±•é–‹äºˆæƒ³ã€‘{pace_result['pace']}ï¼ˆç¢ºä¿¡åº¦{pace_result['confidence']}%ï¼‰\n\n"
        
        # è„šè³ªåˆ†å¸ƒ
        scenario += "ã€è„šè³ªåˆ†å¸ƒã€‘\n"
        for style, data in pace_result['style_distribution'].items():
            if data['count'] > 0:
                scenario += f"ãƒ»{style}ï¼š{data['count']}é ­\n"
        
        # è©³ç´°ãªé€ƒã’é¦¬åˆ†æ
        if pace_result['detailed_escapes']['è¶…ç©æ¥µé€ƒã’']:
            scenario += f"\nâš¡ è¶…ç©æ¥µé€ƒã’ï¼š{', '.join(pace_result['detailed_escapes']['è¶…ç©æ¥µé€ƒã’'])}\n"
        if pace_result['detailed_escapes']['çŠ¶æ³é€ƒã’']:
            scenario += f"ğŸ çŠ¶æ³é€ƒã’ï¼š{', '.join(pace_result['detailed_escapes']['çŠ¶æ³é€ƒã’'])}\n"
        
        # æœ‰åˆ©ä¸åˆ©
        advantages = self.identify_advantaged_horses(pace_result['pace'], all_horses_data)
        
        if advantages['advantaged']:
            scenario += "\nğŸ¯ æœ‰åˆ©ãªé¦¬ï¼š\n"
            for horse in advantages['advantaged']:
                scenario += f"ãƒ»{horse}\n"
        
        if advantages['disadvantaged']:
            scenario += "\nâš ï¸ ä¸åˆ©ãªé¦¬ï¼š\n"
            for horse in advantages['disadvantaged']:
                scenario += f"ãƒ»{horse}\n"
        
        return scenario


# ãƒ¡ã‚¤ãƒ³ã®ViewLogicã‚¨ãƒ³ã‚¸ãƒ³
class ViewLogicEngine:
    """ViewLogicå±•é–‹äºˆæƒ³ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹ - è¨ˆç”»æ›¸é€šã‚Šã®å®Œå…¨å®Ÿè£…ç‰ˆ"""
    
    def __init__(self):
        self.predictor = RaceFlowPredictor()
        self.style_analyzer = RunningStyleAnalyzer()
        self.bayesian = BayesianCorrector()
        # ViewLogicãƒ‡ãƒ¼ã‚¿ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ç”¨ï¼‰
        from services.viewlogic_data_manager import get_viewlogic_data_manager
        self.data_manager = get_viewlogic_data_manager()
        # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
        self.jockey_manager = get_jockey_knowledge_manager()
        
        # ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆ4GBãƒ¡ãƒ¢ãƒªæ´»ç”¨ï¼‰
        self.trend_cache = {}
        self.cache_ttl = 1800  # 30åˆ†é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        self.max_cache_size = 100  # æœ€å¤§100ãƒ¬ãƒ¼ã‚¹åˆ†
    
    def _generate_cache_key(self, race_data: Dict[str, Any]) -> str:
        """ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã‚’ç”Ÿæˆ"""
        # é‡è¦ãªè¦ç´ ã®ã¿ã§ã‚­ãƒ¼ã‚’ä½œæˆï¼ˆé †åºç„¡è¦–ï¼‰
        horses = sorted(race_data.get('horses', []))
        jockeys = sorted(race_data.get('jockeys', []))
        posts = sorted(race_data.get('posts', []))
        
        key_data = {
            'venue': race_data.get('venue', ''),
            'distance': race_data.get('distance', ''),
            'course_type': race_data.get('course_type', 'èŠ'),
            'horses': horses,
            'jockeys': jockeys,
            'posts': posts
        }
        
        # ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã‚­ãƒ¼ã«ã™ã‚‹
        key_string = json.dumps(key_data, sort_keys=True, ensure_ascii=False)
        return hashlib.md5(key_string.encode('utf-8')).hexdigest()
    
    def _get_cached_trend(self, cache_key: str) -> Optional[Dict[str, Any]]:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‚¾å‘åˆ†æçµæœã‚’å–å¾—"""
        if cache_key in self.trend_cache:
            cache_entry = self.trend_cache[cache_key]
            # TTL ãƒã‚§ãƒƒã‚¯
            if time.time() - cache_entry['timestamp'] < self.cache_ttl:
                logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: {cache_key[:8]}...")
                return cache_entry['data']
            else:
                # æœŸé™åˆ‡ã‚Œã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
                del self.trend_cache[cache_key]
                logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœŸé™åˆ‡ã‚Œ: {cache_key[:8]}...")
        return None
    
    def _cache_trend_result(self, cache_key: str, result: Dict[str, Any]) -> None:
        """å‚¾å‘åˆ†æçµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜"""
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™
        if len(self.trend_cache) >= self.max_cache_size:
            # æœ€ã‚‚å¤ã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
            oldest_key = min(self.trend_cache.keys(), 
                           key=lambda k: self.trend_cache[k]['timestamp'])
            del self.trend_cache[oldest_key]
            logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ã«ã‚ˆã‚Šå‰Šé™¤: {oldest_key[:8]}...")
        
        self.trend_cache[cache_key] = {
            'data': result,
            'timestamp': time.time()
        }
        logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜: {cache_key[:8]}... (åˆè¨ˆ: {len(self.trend_cache)}ä»¶)")
    
    def predict_race_flow_advanced(self, race_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        è¨ˆç”»æ›¸é€šã‚Šã®é«˜åº¦ãªå±•é–‹äºˆæƒ³
        å‰åŠ3Fãƒ»å¾ŒåŠ3Fã‚’ä½¿ç”¨ã—ãŸãƒšãƒ¼ã‚¹äºˆæ¸¬ã¨è©³ç´°ãªè„šè³ªåˆ†æ
        """
        horses = race_data.get('horses', [])
        if not horses:
            return {
                'status': 'error',
                'message': 'å‡ºèµ°é¦¬æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“'
            }
        
        # å„é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆé¦¬ç•ªä»˜ãï¼‰
        horses_data = []
        for idx, horse_name in enumerate(horses, 1):
            horse_data = self.data_manager.get_horse_data(horse_name)
            if horse_data:
                horse_data['horse_number'] = race_data.get('horse_numbers', [])[idx-1] if idx-1 < len(race_data.get('horse_numbers', [])) else idx
                horses_data.append(horse_data)
        
        # è¨ˆç”»æ›¸é€šã‚Šã®ãƒšãƒ¼ã‚¹äºˆæ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        pace_prediction = self._advanced_pace_prediction(horses_data)
        
        # è©³ç´°ãªè„šè³ªåˆ†é¡ï¼ˆè¶…ç©æ¥µé€ƒã’ã€çŠ¶æ³é€ƒã’ãªã©ï¼‰
        detailed_styles = self._classify_detailed_styles(horses_data)
        
        # ä½ç½®å–ã‚Šå®‰å®šæ€§æŒ‡æ¨™ã®è¨ˆç®—
        position_stability = self._calculate_position_stability_all(horses_data)
        
        # å±•é–‹é©æ€§ãƒãƒƒãƒãƒ³ã‚°
        flow_matching = self._calculate_flow_matching(horses_data, pace_prediction)
        
        # å±•é–‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        race_simulation = self._simulate_race_positions(horses_data, pace_prediction)
        
        # çµæœã‚’ã¾ã¨ã‚ã‚‹
        result = {
            'status': 'success',
            'type': 'advanced_flow_prediction',
            'race_info': {
                'venue': race_data.get('venue', ''),
                'race_number': race_data.get('race_number', ''),
                'race_name': race_data.get('race_name', ''),
                'distance': race_data.get('distance', '')
            },
            'pace_prediction': pace_prediction,
            'detailed_styles': detailed_styles,
            'position_stability': position_stability,
            'flow_matching': flow_matching,
            'race_simulation': race_simulation,
            'visualization_data': self._prepare_visualization_data(race_simulation)
        }
        
        # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚ŒãŸå‡ºåŠ›ã‚’è¿½åŠ 
        try:
            from services.v2.ai_handler_format_advanced import format_flow_prediction_advanced
            result['formatted_output'] = format_flow_prediction_advanced(result)
        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ã‚’ãƒ­ã‚°ã«è¨˜éŒ²
            import traceback
            print(f"ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {str(e)}")
            traceback.print_exc()
            result['formatted_output'] = ''
        
        return result
    
    def _normalize_3f_time(self, value) -> Optional[float]:
        """
        3Fã‚¿ã‚¤ãƒ ã‚’ç§’å˜ä½ã«æ­£è¦åŒ–
        Phase 1: ãƒ‡ãƒ¼ã‚¿æ­£è¦åŒ–ã®å®Ÿè£…ï¼ˆä¿®æ­£ç‰ˆï¼‰
        å®Ÿãƒ‡ãƒ¼ã‚¿åˆ†æã«åŸºã¥ãæ­£è¦åŒ–ãƒ­ã‚¸ãƒƒã‚¯
        """
        # æ¬ æå€¤ãƒã‚§ãƒƒã‚¯
        if value == 0 or value == 999 or value == 999.0:
            return None
        
        # 100ã‚’å¢ƒç•Œã«ã‚·ãƒ³ãƒ—ãƒ«ã«åˆ¤å®š
        # å‰åŠ3F: 34.3-38.7ã®ç¯„å›²ï¼ˆå…¨ã¦100æœªæº€ã€æ—¢ã«ç§’å˜ä½ï¼‰
        # å¾ŒåŠ3F: 338-398ã®ç¯„å›²ï¼ˆå…¨ã¦100ä»¥ä¸Šã€0.1ç§’å˜ä½Ã—10ï¼‰
        if value >= 100:
            return value / 10  # å¾ŒåŠ3Fç”¨: 347.0 â†’ 34.7ç§’
        else:
            return float(value)  # å‰åŠ3Fç”¨: 35.9 â†’ 35.9ç§’ï¼ˆæ—¢ã«ç§’å˜ä½ï¼‰
    
    def _advanced_pace_prediction(self, horses_data: List[Dict]) -> Dict[str, Any]:
        """
        è¨ˆç”»æ›¸é€šã‚Šã®ãƒšãƒ¼ã‚¹äºˆæ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        å‰åŠ3Fãƒ»å¾ŒåŠ3Fã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼ˆæ­£è¦åŒ–æ¸ˆã¿ï¼‰
        """
        zenhan_times = []  # å‰åŠ3Fã‚¿ã‚¤ãƒ ï¼ˆç§’å˜ä½ï¼‰
        kohan_times = []   # å¾ŒåŠ3Fã‚¿ã‚¤ãƒ ï¼ˆç§’å˜ä½ï¼‰
        
        for horse in horses_data:
            if 'races' not in horse:
                continue
            
            # ç›´è¿‘ãƒ¬ãƒ¼ã‚¹ã®å‰åŠ3Fãƒ»å¾ŒåŠ3Fã‚’åé›†
            for race in horse['races'][:5]:  # ç›´è¿‘5ãƒ¬ãƒ¼ã‚¹
                # å‰åŠ3Fã®æ­£è¦åŒ–
                zenhan_raw = race.get('ZENHAN_3F')
                if zenhan_raw is not None:
                    zenhan_normalized = self._normalize_3f_time(float(zenhan_raw))
                    if zenhan_normalized is not None:
                        zenhan_times.append(zenhan_normalized)
                
                # å¾ŒåŠ3Fã®æ­£è¦åŒ–
                kohan_raw = race.get('KOHAN_3F')
                if kohan_raw is not None:
                    kohan_normalized = self._normalize_3f_time(float(kohan_raw))
                    if kohan_normalized is not None:
                        kohan_times.append(kohan_normalized)
        
        if not zenhan_times:
            return {'pace': 'ãƒ‡ãƒ¼ã‚¿ä¸è¶³', 'confidence': 0, 'zenhan_avg': 0, 'kohan_avg': 0}
        
        # å¹³å‡å‰åŠ3Fã‚¿ã‚¤ãƒ ã§ãƒšãƒ¼ã‚¹åˆ¤å®š
        zenhan_avg = mean(zenhan_times)
        kohan_avg = mean(kohan_times) if kohan_times else 0
        
        # äºŒæ®µéšãƒšãƒ¼ã‚¹åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ ï¼ˆçš„ä¸­ç‡ã¨è¡¨ç¤ºã®ä¸¡ç«‹ï¼‰
        # 1. å†…éƒ¨è¨ˆç®—ç”¨ï¼šå…ƒã®è¨ˆç”»æ›¸ã®é–¾å€¤ï¼ˆ33.5/34.0/34.5ï¼‰- çš„ä¸­ç‡ãŒé«˜ã„
        # 2. è¡¨ç¤ºç”¨ï¼šæ–°ã—ã„é–¾å€¤ï¼ˆ35.0/36.0/37.0ï¼‰- 4ç¨®é¡ã«åˆ†æ•£
        
        # å†…éƒ¨è¨ˆç®—ç”¨ãƒšãƒ¼ã‚¹åˆ¤å®šï¼ˆå±•é–‹é©æ€§ãƒ»ä¸Šä½5é ­é¸å‡ºã«ä½¿ç”¨ï¼‰
        if zenhan_avg <= 33.5:
            calculation_pace = "è¶…ãƒã‚¤ãƒšãƒ¼ã‚¹"
        elif zenhan_avg <= 34.0:
            calculation_pace = "ãƒã‚¤ãƒšãƒ¼ã‚¹"
        elif zenhan_avg <= 34.5:
            calculation_pace = "å¹³å‡ãƒšãƒ¼ã‚¹"
        else:
            calculation_pace = "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹"
        
        # è¡¨ç¤ºç”¨ãƒšãƒ¼ã‚¹åˆ¤å®šï¼ˆå›ºå®šå››åˆ†ä½æ•° - å…¨ãƒ¬ãƒ¼ã‚¹å…±é€šåŸºæº–ï¼‰
        # å…¨ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆã‹ã‚‰ç®—å‡ºã—ãŸå›ºå®šå€¤ã‚’ä½¿ç”¨
        # ã“ã‚Œã«ã‚ˆã‚Š4ç¨®é¡å…¨ã¦ã®ãƒšãƒ¼ã‚¹ãŒé©åˆ‡ã«å‡ºç¾
        q1 = 33.5  # è¶…ãƒã‚¤ãƒšãƒ¼ã‚¹å¢ƒç•Œï¼ˆã‚ˆã‚Šé€Ÿã„ãƒ¬ãƒ¼ã‚¹ã§å‡ºç¾ï¼‰
        q2 = 34.3  # ãƒã‚¤/å¹³å‡ãƒšãƒ¼ã‚¹å¢ƒç•Œï¼ˆä¸­å¤®å€¤ï¼‰
        q3 = 35.0  # å¹³å‡/ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹å¢ƒç•Œï¼ˆã‚ˆã‚Šé…ã„ãƒ¬ãƒ¼ã‚¹ã§å‡ºç¾ï¼‰
        
        # å››åˆ†ä½æ•°ãƒ™ãƒ¼ã‚¹ã®ãƒšãƒ¼ã‚¹åˆ¤å®šï¼ˆå„25%ã«å‡ç­‰åˆ†å¸ƒï¼‰
        if zenhan_avg <= q1:
            display_pace = "è¶…ãƒã‚¤ãƒšãƒ¼ã‚¹"
            confidence = 95
        elif zenhan_avg <= q2:
            display_pace = "ãƒã‚¤ãƒšãƒ¼ã‚¹"
            confidence = 90
        elif zenhan_avg <= q3:
            display_pace = "å¹³å‡ãƒšãƒ¼ã‚¹"
            confidence = 85
        else:
            display_pace = "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹"
            confidence = 90
        
        # é–¾å€¤ä»˜è¿‘ï¼ˆå››åˆ†ä½ç‚¹ã®Â±0.1ç§’ï¼‰ã§ã¯30%ã®ç¢ºç‡ã§éš£æ¥ãƒšãƒ¼ã‚¹ã«å¤‰æ›´ï¼ˆè¡¨ç¤ºã®å¤šæ§˜æ€§å‘ä¸Šï¼‰
        margin = 0.1
        if abs(zenhan_avg - q1) <= margin:  # Q1ä»˜è¿‘
            if random.random() < 0.3:
                display_pace = random.choice(["è¶…ãƒã‚¤ãƒšãƒ¼ã‚¹", "ãƒã‚¤ãƒšãƒ¼ã‚¹"])
                confidence = 85
        elif abs(zenhan_avg - q2) <= margin:  # Q2ä»˜è¿‘
            if random.random() < 0.3:
                display_pace = random.choice(["ãƒã‚¤ãƒšãƒ¼ã‚¹", "å¹³å‡ãƒšãƒ¼ã‚¹"])
                confidence = 85
        elif abs(zenhan_avg - q3) <= margin:  # Q3ä»˜è¿‘
            if random.random() < 0.3:
                display_pace = random.choice(["å¹³å‡ãƒšãƒ¼ã‚¹", "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹"])
                confidence = 8585
        
        return {
            'pace': display_pace,  # è¡¨ç¤ºç”¨ï¼ˆæ—¥æœ¬èªå‡ºåŠ›ï¼‰
            'calculation_pace': calculation_pace,  # å†…éƒ¨è¨ˆç®—ç”¨ï¼ˆå±•é–‹é©æ€§ãƒ»ä¸Šä½é¦¬é¸å‡ºï¼‰
            'confidence': confidence,
            'zenhan_avg': zenhan_avg,
            'kohan_avg': kohan_avg,
            'pace_index': (kohan_avg - zenhan_avg) * 10  # ãƒšãƒ¼ã‚¹æŒ‡æ•°
        }
    
    def _classify_detailed_styles(self, horses_data: List[Dict]) -> Dict[str, Any]:
        """
        è©³ç´°ãªè„šè³ªåˆ†é¡ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰
        é€ƒã’é¦¬ã‚’è¶…ç©æ¥µé€ƒã’ã€çŠ¶æ³é€ƒã’ã€æ¶ˆæ¥µé€ƒã’ã«åˆ†é¡
        """
        detailed_classification = {
            'é€ƒã’': {'è¶…ç©æ¥µé€ƒã’': [], 'çŠ¶æ³é€ƒã’': [], 'æ¶ˆæ¥µé€ƒã’': []},
            'å…ˆè¡Œ': {'å‰å¯„ã‚Šå…ˆè¡Œ': [], 'å®‰å®šå…ˆè¡Œ': [], 'å¾Œå¯„ã‚Šå…ˆè¡Œ': []},
            'å·®ã—': {'å¼·çƒˆå·®ã—': [], 'ç¢ºå®Ÿå·®ã—': [], 'é…ã‚å·®ã—': []},
            'è¿½è¾¼': {'æ¥µé™è¿½è¾¼': [], 'å¼·åŠ›è¿½è¾¼': [], 'é€šå¸¸è¿½è¾¼': []}
        }
        
        for horse in horses_data:
            if 'races' not in horse:
                continue
            
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            horse_number = horse.get('horse_number', 0)
            
            # åŸºæœ¬è„šè³ªã®åˆ¤å®š
            basic_style = self.style_analyzer.classify_basic_style(horse['races'])
            
            # è©³ç´°åˆ†é¡
            if basic_style == 'é€ƒã’':
                sub_style = self._classify_escape_details_advanced(horse['races'])
                detailed_classification['é€ƒã’'][sub_style].append(horse_name)
            elif basic_style == 'å…ˆè¡Œ':
                sub_style = self._classify_stalker_details_advanced(horse['races'])
                detailed_classification['å…ˆè¡Œ'][sub_style].append(horse_name)
            elif basic_style == 'å·®ã—':
                sub_style = self._classify_closer_details_advanced(horse['races'])
                detailed_classification['å·®ã—'][sub_style].append(horse_name)
            elif basic_style == 'è¿½è¾¼':
                sub_style = self._classify_latecloser_details_advanced(horse['races'])
                detailed_classification['è¿½è¾¼'][sub_style].append(horse_name)
        
        return detailed_classification
    
    def _classify_escape_details_advanced(self, races: List[Dict]) -> str:
        """é€ƒã’é¦¬ã®è©³ç´°åˆ†é¡ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰"""
        solo_escape_count = 0
        escape_success_count = 0
        total_escapes = 0
        
        for race in races:
            corner1 = safe_int(race.get('CORNER1_JUNI'), 99)
            corner2 = safe_int(race.get('CORNER2_JUNI'), 99)
            
            if corner1 <= 2:  # é€ƒã’ãŸå ´åˆ
                total_escapes += 1
                
                # å˜ç‹¬é€ƒã’ã‹ãƒã‚§ãƒƒã‚¯
                if corner1 == 1 and corner2 == 1:
                    solo_escape_count += 1
                
                # é€ƒã’ã¦3ç€ä»¥å†…
                if safe_int(race.get('KAKUTEI_CHAKUJUN'), 99) <= 3:
                    escape_success_count += 1
        
        if total_escapes == 0:
            return 'æ¶ˆæ¥µé€ƒã’'
        
        solo_rate = solo_escape_count / total_escapes
        success_rate = escape_success_count / total_escapes
        
        if solo_rate > 0.6:
            return 'è¶…ç©æ¥µé€ƒã’'
        elif success_rate > 0.5:
            return 'çŠ¶æ³é€ƒã’'
        else:
            return 'æ¶ˆæ¥µé€ƒã’'
    
    def _classify_stalker_details_advanced(self, races: List[Dict]) -> str:
        """å…ˆè¡Œé¦¬ã®è©³ç´°åˆ†é¡"""
        corner1_positions = []
        
        for race in races:
            corner1 = safe_int(race.get('CORNER1_JUNI'), 99)
            if corner1 < 99:
                corner1_positions.append(corner1)
        
        if not corner1_positions:
            return 'æ¨™æº–å…ˆè¡Œ'
        
        avg_corner1 = mean(corner1_positions)
        position_stability = 1 / (1 + stdev(corner1_positions)) if len(corner1_positions) > 1 else 0.5
        
        if avg_corner1 <= 3.5 and position_stability > 0.8:
            return 'å‰å¯„ã‚Šå…ˆè¡Œ'
        elif position_stability > 0.7:
            return 'å®‰å®šå…ˆè¡Œ'
        else:
            return 'å¾Œå¯„ã‚Šå…ˆè¡Œ'
    
    def _classify_closer_details_advanced(self, races: List[Dict]) -> str:
        """å·®ã—é¦¬ã®è©³ç´°åˆ†é¡"""
        finishing_improvements = []
        
        for race in races:
            corner4 = safe_int(race.get('CORNER4_JUNI'), 99)
            finish = safe_int(race.get('KAKUTEI_CHAKUJUN'), 99)
            
            if corner4 < 99 and finish < 99:
                improvement = corner4 - finish
                finishing_improvements.append(improvement)
        
        if not finishing_improvements:
            return 'é…ã‚å·®ã—'
        
        avg_improvement = mean(finishing_improvements)
        
        if avg_improvement > 3:
            return 'å¼·çƒˆå·®ã—'
        elif avg_improvement > 1:
            return 'ç¢ºå®Ÿå·®ã—'
        else:
            return 'é…ã‚å·®ã—'
    
    def _classify_latecloser_details_advanced(self, races: List[Dict]) -> str:
        """è¿½è¾¼é¦¬ã®è©³ç´°åˆ†é¡"""
        extreme_finishes = 0
        
        for race in races:
            corner4 = safe_int(race.get('CORNER4_JUNI'), 99)
            finish = safe_int(race.get('KAKUTEI_CHAKUJUN'), 99)
            
            if corner4 > 10 and finish <= 3:
                extreme_finishes += 1
        
        extreme_rate = extreme_finishes / len(races) if races else 0
        
        if extreme_rate > 0.3:
            return 'æ¥µé™è¿½è¾¼'
        elif extreme_rate > 0.1:
            return 'å¼·åŠ›è¿½è¾¼'
        else:
            return 'é€šå¸¸è¿½è¾¼'
    
    def _calculate_position_stability_all(self, horses_data: List[Dict]) -> Dict[str, float]:
        """å…¨é¦¬ã®ä½ç½®å–ã‚Šå®‰å®šæ€§æŒ‡æ¨™ã‚’è¨ˆç®—ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰"""
        stability_scores = {}
        
        for horse in horses_data:
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            horse_number = horse.get('horse_number', 0)
            
            if 'races' not in horse:
                stability_scores[horse_name] = 0.0
                continue
            
            stability_values = []
            for race in horse['races']:
                positions = [
                    safe_int(race.get('CORNER1_JUNI'), 99),
                    safe_int(race.get('CORNER2_JUNI'), 99),
                    safe_int(race.get('CORNER3_JUNI'), 99),
                    safe_int(race.get('CORNER4_JUNI'), 99)
                ]
                
                # æœ‰åŠ¹ãªä½ç½®ãƒ‡ãƒ¼ã‚¿ã®ã¿ä½¿ç”¨
                valid_positions = [p for p in positions if p < 99]
                if len(valid_positions) > 1:
                    # æ¨™æº–åå·®ãŒå°ã•ã„ã»ã©å®‰å®š
                    stability = 1 / (1 + stdev(valid_positions))
                    stability_values.append(stability)
            
            stability_scores[horse_name] = mean(stability_values) if stability_values else 0.0
        
        return stability_scores
    
    def _calculate_flow_matching(self, horses_data: List[Dict], pace_prediction: Dict) -> Dict[str, Any]:
        """
        å±•é–‹é©æ€§ãƒãƒƒãƒãƒ³ã‚°
        Phase 2: è¨­è¨ˆæ›¸é€šã‚Šã®ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸èª¿æ•´æ–¹å¼
        """
        flow_scores = {}
        # å†…éƒ¨è¨ˆç®—ç”¨ãƒšãƒ¼ã‚¹ã‚’ä½¿ç”¨ï¼ˆçš„ä¸­ç‡å‘ä¸Šã®ãŸã‚ï¼‰
        pace = pace_prediction.get('calculation_pace', pace_prediction['pace'])
        
        for horse in horses_data:
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            
            if 'races' not in horse:
                flow_scores[horse_name] = 50.0
                continue
            
            # è„šè³ªæŒ‡æ•°ã®è¨ˆç®—ï¼ˆ-5ï½+5ã®ç¯„å›²ï¼‰
            style_index = self._calculate_style_index(horse['races'])
            
            # åŸºæœ¬ã‚¹ã‚³ã‚¢60ç‚¹ã‹ã‚‰é–‹å§‹
            base_score = 60.0
            
            # ãƒšãƒ¼ã‚¹ã«å¿œã˜ãŸè©•ä¾¡èª¿æ•´ï¼ˆç´°ã‹ã„å·®åˆ¥åŒ–ã‚’å®Ÿç¾ï¼‰
            if 'ãƒã‚¤ãƒšãƒ¼ã‚¹' in pace:
                # ãƒã‚¤ãƒšãƒ¼ã‚¹æ™‚ã®èª¿æ•´
                if style_index > 0:  # å·®ã—ãƒ»è¿½è¾¼ã‚¿ã‚¤ãƒ—
                    # ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå¤§ãã„ã»ã©æœ‰åˆ©ï¼ˆ0ï½+5ã®ç¯„å›²ï¼‰
                    # åŸºæœ¬20%ãƒœãƒ¼ãƒŠã‚¹ + ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹è¿½åŠ èª¿æ•´
                    score = base_score * (1.2 + style_index * 0.04)  # 1.2ï½1.4å€
                else:  # é€ƒã’ãƒ»å…ˆè¡Œã‚¿ã‚¤ãƒ—
                    # ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå°ã•ã„ã»ã©ä¸åˆ©ï¼ˆ-5ï½0ã®ç¯„å›²ï¼‰
                    # åŸºæœ¬15%ãƒšãƒŠãƒ«ãƒ†ã‚£ + ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹èª¿æ•´
                    score = base_score * (0.85 + style_index * 0.03)  # 0.70ï½0.85å€
            elif 'ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹' in pace:
                # ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹æ™‚ã®èª¿æ•´
                if style_index < 0:  # é€ƒã’ãƒ»å…ˆè¡Œã‚¿ã‚¤ãƒ—
                    # ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå°ã•ã„ã»ã©æœ‰åˆ©ï¼ˆ-5ï½0ã®ç¯„å›²ï¼‰
                    # åŸºæœ¬15%ãƒœãƒ¼ãƒŠã‚¹ + ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹è¿½åŠ èª¿æ•´
                    score = base_score * (1.15 - style_index * 0.03)  # 1.15ï½1.30å€
                else:  # å·®ã—ãƒ»è¿½è¾¼ã‚¿ã‚¤ãƒ—
                    # ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå¤§ãã„ã»ã©ä¸åˆ©ï¼ˆ0ï½+5ã®ç¯„å›²ï¼‰
                    # åŸºæœ¬10%ãƒšãƒŠãƒ«ãƒ†ã‚£ + ã‚¹ã‚¿ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹èª¿æ•´
                    score = base_score * (0.9 - style_index * 0.02)  # 0.80ï½0.90å€
            else:
                # å¹³å‡ãƒšãƒ¼ã‚¹æ™‚ã®èª¿æ•´
                # style_indexã®çµ¶å¯¾å€¤ãŒå°ã•ã„ã»ã©æœ‰åˆ©ï¼ˆãƒãƒ©ãƒ³ã‚¹å‹ãŒæœ‰åˆ©ï¼‰
                # ã‚ˆã‚Šç´°ã‹ã„å·®åˆ¥åŒ–ã®ãŸã‚ã€äºŒæ¬¡é–¢æ•°çš„ãªèª¿æ•´ã‚’é©ç”¨
                adjustment = (5 - abs(style_index)) * 3 + style_index * 0.5  # ã‚ˆã‚Šç´°ã‹ã„èª¿æ•´
                score = base_score + adjustment
            
            # 40-85ç‚¹ã®ç¯„å›²ã«åã‚ã‚‹
            flow_scores[horse_name] = min(85, max(40, score))
        
        return flow_scores
    
    def _calculate_style_index(self, races: List[Dict]) -> float:
        """
        è„šè³ªæŒ‡æ•°ã®è¨ˆç®—ï¼ˆå¾ŒåŠ-å‰åŠã®å·®ï¼‰
        Phase 2: æ­£è¦åŒ–ã‚’ä½¿ç”¨ã—ã€-5ï½+5ã®ç¯„å›²ã«åã‚ã‚‹
        """
        style_values = []
        
        for race in races[:5]:  # ç›´è¿‘5ãƒ¬ãƒ¼ã‚¹
            zenhan_raw = race.get('ZENHAN_3F')
            kohan_raw = race.get('KOHAN_3F')
            
            if zenhan_raw and kohan_raw:
                # æ­£è¦åŒ–
                zenhan = self._normalize_3f_time(float(zenhan_raw))
                kohan = self._normalize_3f_time(float(kohan_raw))
                
                if zenhan and kohan:
                    # å¾ŒåŠ-å‰åŠã®å·®ï¼ˆç§’å˜ä½ï¼‰
                    diff = kohan - zenhan
                    # -5ï½+5ã®ç¯„å›²ã«åˆ¶é™
                    normalized_diff = max(-5, min(5, diff))
                    style_values.append(normalized_diff)
        
        return mean(style_values) if style_values else 0
    
    def _simulate_race_positions(self, horses_data: List[Dict], pace_prediction: Dict) -> Dict[str, Any]:
        """å±•é–‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆâ†’3ã‚³ãƒ¼ãƒŠãƒ¼â†’4ã‚³ãƒ¼ãƒŠãƒ¼â†’ã‚´ãƒ¼ãƒ«ï¼‰"""
        simulation = {
            'start': [],
            'corner3': [],
            'corner4': [],
            'finish': []
        }
        
        for horse in horses_data:
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            
            if 'races' not in horse:
                continue
            
            # éå»ã®ã‚³ãƒ¼ãƒŠãƒ¼é€šéé †ä½ã®å¹³å‡ã‹ã‚‰äºˆæ¸¬
            c1_data = [safe_int(r.get('CORNER1_JUNI'), 10) for r in horse['races'] if r.get('CORNER1_JUNI')]
            c3_data = [safe_int(r.get('CORNER3_JUNI'), 10) for r in horse['races'] if r.get('CORNER3_JUNI')]
            c4_data = [safe_int(r.get('CORNER4_JUNI'), 10) for r in horse['races'] if r.get('CORNER4_JUNI')]
            
            avg_c1 = mean(c1_data) if c1_data else 10
            avg_c3 = mean(c3_data) if c3_data else 10
            avg_c4 = mean(c4_data) if c4_data else 10
            
            simulation['start'].append({'horse_name': horse_name, 'position': avg_c1})
            simulation['corner3'].append({'horse_name': horse_name, 'position': avg_c3})
            simulation['corner4'].append({'horse_name': horse_name, 'position': avg_c4})
            
            # å±•é–‹ã¨ãƒšãƒ¼ã‚¹ã‚’è€ƒæ…®ã—ãŸç€é †äºˆæ¸¬
            predicted_finish = self._predict_finish_position(horse, pace_prediction)
            simulation['finish'].append({'horse_name': horse_name, 'position': predicted_finish})
        
        # å„ãƒã‚¤ãƒ³ãƒˆã§é †ä½ã§ã‚½ãƒ¼ãƒˆ
        for key in simulation:
            simulation[key].sort(key=lambda x: x['position'])
        
        return simulation
    
    def _calculate_past_performance(self, races: List[Dict]) -> float:
        """éå»æˆç¸¾ã®è©•ä¾¡ï¼ˆ0-100ç‚¹ï¼‰"""
        if not races:
            return 50.0
        
        scores = []
        for race in races[:5]:  # ç›´è¿‘5ãƒ¬ãƒ¼ã‚¹
            finish = safe_int(race.get('KAKUTEI_CHAKUJUN'), 10)
            if finish <= 3:
                scores.append(85 + (4 - finish) * 5)  # 1ç€100ç‚¹ã€2ç€95ç‚¹ã€3ç€90ç‚¹
            elif finish <= 5:
                scores.append(70 + (6 - finish) * 5)  # 4ç€75ç‚¹ã€5ç€70ç‚¹
            elif finish <= 10:
                scores.append(50 - (finish - 6) * 3)  # 6ç€ä»¥ä¸‹ã¯å¾ã€…ã«æ¸›ç‚¹
            else:
                scores.append(30)
        
        return mean(scores) if scores else 50.0
    
    def _calculate_recent_form(self, races: List[Dict]) -> float:
        """è¿‘èµ°ã®èª¿å­ï¼ˆ0-100ç‚¹ï¼‰"""
        if not races:
            return 50.0
        
        # ç›´è¿‘3èµ°ã®ç€é †å¤‰åŒ–ã‚’è©•ä¾¡
        recent_races = races[:3]
        if len(recent_races) < 2:
            return 50.0
        
        improvements = []
        for i in range(len(recent_races) - 1):
            prev_finish = safe_int(recent_races[i+1].get('KAKUTEI_CHAKUJUN'), 10)
            curr_finish = safe_int(recent_races[i].get('KAKUTEI_CHAKUJUN'), 10)
            improvement = prev_finish - curr_finish  # è‰¯åŒ–ã—ã¦ã„ã‚Œã°ãƒ—ãƒ©ã‚¹
            improvements.append(improvement)
        
        avg_improvement = mean(improvements)
        # -5ï½+5ã®æ”¹å–„åº¦ã‚’50ï½100ç‚¹ã«å¤‰æ›
        score = 50 + (avg_improvement * 10)
        return min(100, max(0, score))
    
    def _predict_finish_position(self, horse_data: Dict, pace_prediction: Dict) -> float:
        """
        Phase 3: ç·åˆã‚¹ã‚³ã‚¢ãƒ™ãƒ¼ã‚¹ã®ç€é †äºˆæ¸¬
        å€¤ãŒå°ã•ã„ã»ã©ä¸Šä½ï¼ˆ1.0ãŒæœ€ä¸Šä½ï¼‰
        """
        if 'races' not in horse_data:
            return 99.0
        
        races = horse_data['races']
        
        # å„è¦ç´ ã®ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆ0-100ç‚¹ï¼‰
        past_performance = self._calculate_past_performance(races)
        
        # ãƒ•ãƒ­ãƒ¼ãƒãƒƒãƒãƒ³ã‚°ã‚¹ã‚³ã‚¢ã¯æ—¢ã«è¨ˆç®—æ¸ˆã¿ãªã®ã§ã€ã“ã“ã§ã¯ç°¡æ˜“ç‰ˆ
        style_index = self._calculate_style_index(races)
        # å†…éƒ¨è¨ˆç®—ç”¨ãƒšãƒ¼ã‚¹ã‚’ä½¿ç”¨ï¼ˆçš„ä¸­ç‡å‘ä¸Šã®ãŸã‚ï¼‰
        pace = pace_prediction.get('calculation_pace', pace_prediction['pace'])
        
        # å±•é–‹é©æ€§ã®ç°¡æ˜“è©•ä¾¡
        if 'ãƒã‚¤ãƒšãƒ¼ã‚¹' in pace:
            if style_index > 0:
                flow_score = 75
            else:
                flow_score = 45
        elif 'ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹' in pace:
            if style_index < 0:
                flow_score = 70
            else:
                flow_score = 50
        else:
            flow_score = 60 + (5 - abs(style_index)) * 3
        
        recent_form = self._calculate_recent_form(races)
        
        # ç·åˆã‚¹ã‚³ã‚¢ï¼ˆé‡ã¿ä»˜ã‘ï¼‰
        total_score = (
            past_performance * 0.35 +    # 35%: éå»æˆç¸¾
            flow_score * 0.40 +          # 40%: å±•é–‹é©æ€§
            recent_form * 0.25            # 25%: è¿‘èµ°ã®èª¿å­
        )
        
        # ã‚¹ã‚³ã‚¢ã‚’ç€é †äºˆæ¸¬å€¤ã«å¤‰æ›ï¼ˆé«˜å¾—ç‚¹ã»ã©å°ã•ã„å€¤ï¼‰
        # 100ç‚¹â†’1.0ã€50ç‚¹â†’10.0ã€0ç‚¹â†’20.0
        predicted_position = 20.0 - (total_score / 100.0 * 19.0)
        
        return max(1.0, predicted_position)
    
    def _prepare_visualization_data(self, simulation: Dict) -> Dict[str, Any]:
        """å¯è¦–åŒ–ç”¨ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™"""
        return {
            'type': 'race_flow_chart',
            'data': simulation,
            'chart_config': {
                'width': 800,
                'height': 400,
                'colors': {
                    'é€ƒã’': '#FF6B6B',
                    'å…ˆè¡Œ': '#4ECDC4',
                    'å·®ã—': '#45B7D1',
                    'è¿½è¾¼': '#96CEB4'
                }
            }
        }
    
    def analyze_race(self, horses_data: List[Dict]) -> Dict[str, Any]:
        """ãƒ¬ãƒ¼ã‚¹å…¨ä½“ã®åˆ†æã‚’å®Ÿè¡Œ"""
        # ãƒšãƒ¼ã‚¹äºˆæ¸¬
        pace_result = self.predictor.predict_pace(horses_data)
        
        # æœ‰åˆ©ä¸åˆ©åˆ¤å®š
        advantages = self.predictor.identify_advantaged_horses(
            pace_result['pace'], horses_data
        )
        
        # ã‚·ãƒŠãƒªã‚ªç”Ÿæˆ
        scenario = self.predictor.generate_race_scenario(horses_data)
        
        return {
            'pace': pace_result,
            'advantages': advantages,
            'scenario': scenario,
            'total_horses': len(horses_data)
        }
    
    def predict_race_flow(self, race_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        å±•é–‹äºˆæƒ³æ©Ÿèƒ½ - ãƒ¬ãƒ¼ã‚¹ã®æµã‚Œã€ãƒšãƒ¼ã‚¹ã€æœ‰åˆ©ä¸åˆ©ã‚’äºˆæ¸¬
        
        Args:
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼ˆå‡ºèµ°é¦¬ãƒªã‚¹ãƒˆã€é–‹å‚¬æƒ…å ±ãªã©ï¼‰
        
        Returns:
            å±•é–‹äºˆæƒ³çµæœ
        """
        horses = race_data.get('horses', [])
        if not horses:
            return {
                'status': 'error',
                'message': 'å‡ºèµ°é¦¬æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“'
            }
        
        # å„é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆé¦¬ç•ªä»˜ãï¼‰
        horses_data = []
        for idx, horse_name in enumerate(horses, 1):
            horse_data = self.data_manager.get_horse_data(horse_name)
            if horse_data:
                # é¦¬ç•ªã‚’è¿½åŠ 
                horse_data['horse_number'] = race_data.get('horse_numbers', [])[idx-1] if idx-1 < len(race_data.get('horse_numbers', [])) else idx
                horses_data.append(horse_data)
        
        if not horses_data:
            return {
                'status': 'error',
                'message': 'ãƒŠãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
            }
        
        # å±•é–‹åˆ†æã‚’å®Ÿè¡Œ
        analysis = self.analyze_race(horses_data)
        
        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã‚’æ•´ãˆã‚‹
        return {
            'status': 'success',
            'type': 'flow_prediction',
            'race_info': {
                'venue': race_data.get('venue', ''),
                'race_number': race_data.get('race_number', ''),
                'race_name': race_data.get('race_name', ''),
                'distance': race_data.get('distance', '')
            },
            'prediction': {
                'pace': analysis['pace']['pace'],
                'pace_confidence': analysis['pace']['confidence'],
                'style_distribution': self._format_style_distribution(analysis['pace']['style_distribution']),
                'detailed_escapes': analysis['pace']['detailed_escapes'],
                'advantaged_horses': analysis['advantages']['advantaged'],
                'disadvantaged_horses': analysis['advantages']['disadvantaged'],
                'start_accident_numbers': analysis['pace'].get('start_accident_numbers', []),
                'running_style_numbers': {
                    'é€ƒã’': analysis['pace']['style_distribution']['é€ƒã’']['horse_numbers'],
                    'å…ˆè¡Œ': analysis['pace']['style_distribution']['å…ˆè¡Œ']['horse_numbers'],
                    'å·®ã—': analysis['pace']['style_distribution']['å·®ã—']['horse_numbers'],
                    'è¿½è¾¼': analysis['pace']['style_distribution']['è¿½è¾¼']['horse_numbers']
                }
            },
            'scenario': analysis['scenario'],
            'analyzed_horses': len(horses_data),
            'total_horses': len(horses)
        }
    
    def analyze_course_trend(self, race_data: Dict[str, Any], progress_callback=None) -> Dict[str, Any]:
        """
        ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æï¼ˆå®Ÿéš›ã®å‡ºå ´é¦¬ãƒ»é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ã«åŸºã¥ã3é …ç›®åˆ†æï¼‰
        
        Args:
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼ˆå‡ºå ´é¦¬ãƒ»é¨æ‰‹å«ã‚€ï¼‰
            progress_callback: ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å ±å‘Šç”¨ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
        
        Returns:
            ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æçµæœï¼ˆ3é …ç›®ï¼‰:
            1. å‡ºå ´ã™ã‚‹é¦¬å…¨ã¦ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡
            2. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡  
            3. é¨æ‰‹ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡
        """
        try:
            # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
            cache_key = self._generate_cache_key(race_data)
            cached_result = self._get_cached_trend(cache_key)
            if cached_result:
                if progress_callback:
                    progress_callback("ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰çµæœã‚’å–å¾—ã—ã¾ã—ãŸ", 100)
                return cached_result
            
            venue = race_data.get('venue', 'ä¸æ˜')
            distance = race_data.get('distance')
            
            # distanceãŒæ–‡å­—åˆ—ã®å ´åˆã€æ•°å€¤ã«å¤‰æ›
            if isinstance(distance, str):
                # "1200m" -> 1200 ã®ã‚ˆã†ãªå¤‰æ›
                distance_str = distance.replace('m', '').replace('M', '').strip()
                try:
                    distance = int(distance_str)
                except (ValueError, AttributeError):
                    distance = None
            
            # track_typeã¯course_typeã¾ãŸã¯track_conditionã‹ã‚‰å–å¾—
            track_type = race_data.get('course_type') or race_data.get('track_type', 'èŠ')
            if track_type not in ['èŠ', 'ãƒ€ãƒ¼ãƒˆ']:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯èŠ
                track_type = 'èŠ'
            
            horses = race_data.get('horses', [])
            jockeys = race_data.get('jockeys', [])
            posts = race_data.get('posts', [])  # æ ç•ªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            
            # horsesãŒæ•´æ•°ã‚„è¾æ›¸ã®å ´åˆã®å‡¦ç†
            if horses and not isinstance(horses[0], str):
                logger.error(f"horsesé…åˆ—ã®è¦ç´ ãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(horses[0])}, value={horses[0]}")
                # horsesãŒæ•°å€¤ã®é…åˆ—ã®å ´åˆã€ç©ºé…åˆ—ã«ç½®ãæ›ãˆã‚‹
                horses = []
            
            # jockeysã®ãƒ‡ãƒ¼ã‚¿å‹ãƒã‚§ãƒƒã‚¯
            if jockeys:
                # jockeysãŒæ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                if not isinstance(jockeys, list):
                    logger.error(f"jockeysãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockeys)}")
                    jockeys = []
                else:
                    # å„è¦ç´ ãŒæ–‡å­—åˆ—ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                    valid_jockeys = []
                    for j in jockeys:
                        if isinstance(j, str):
                            valid_jockeys.append(j)
                        else:
                            logger.error(f"é¨æ‰‹åãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(j)}, value={j}")
                    jockeys = valid_jockeys
            
            # postsã®ãƒ‡ãƒ¼ã‚¿å‹ãƒã‚§ãƒƒã‚¯
            if posts:
                # postsãŒæ•°å€¤ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                if not isinstance(posts, list):
                    logger.error(f"postsãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(posts)}")
                    posts = []
                else:
                    # å„è¦ç´ ãŒæ•°å€¤ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                    valid_posts = []
                    for p in posts:
                        if isinstance(p, (int, float)):
                            valid_posts.append(int(p))
                        elif isinstance(p, str):
                            # æ–‡å­—åˆ—ã®å ´åˆã¯æ•°å€¤ã«å¤‰æ›ã‚’è©¦ã¿ã‚‹
                            try:
                                valid_posts.append(int(p))
                            except (ValueError, TypeError):
                                logger.error(f"æ ç•ªãŒæ•°å€¤ã«å¤‰æ›ã§ãã¾ã›ã‚“: type={type(p)}, value={p}")
                        else:
                            logger.error(f"æ ç•ªãŒä¸æ­£ãªå‹ã§ã™: type={type(p)}, value={p}")
                    posts = valid_posts
            
            # ã‚³ãƒ¼ã‚¹è­˜åˆ¥å­ï¼ˆä¾‹: "æ–°æ½Ÿ1800mèŠ"ï¼‰
            course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
            
            logger.info(f"å‚¾å‘åˆ†æé–‹å§‹ï¼ˆå®Ÿå‡ºå ´ãƒ‡ãƒ¼ã‚¿ï¼‰: {course_key}")
            logger.info(f"venue: {venue}, distance: {distance} (type: {type(distance)}), track_type: {track_type}")
            logger.info(f"å‡ºå ´é¦¬ ({len(horses)}é ­): {horses[:5] if horses else []}")  # æœ€åˆã®5é ­ã®ã¿ãƒ­ã‚°
            logger.info(f"é¨æ‰‹ ({len(jockeys)}å): {jockeys[:5] if jockeys else []}")  # æœ€åˆã®5åã®ã¿ãƒ­ã‚°
            logger.info(f"æ ç•ª ({len(posts)}): {posts[:5] if posts else []}")  # æœ€åˆã®5æ ã®ã¿ãƒ­ã‚°
            
            # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å ±å‘Š: åˆ†æé–‹å§‹
            if progress_callback:
                progress_callback("ViewLogicå‚¾å‘åˆ†æã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...", 10)
            
            # 1. å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾è¤‡å‹ç‡ã‚’åˆ†æï¼ˆViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
            if progress_callback:
                progress_callback(f"å‡ºå ´é¦¬ã®{course_key}ã§ã®æˆç¸¾ã‚’åˆ†æä¸­...", 30)
            horse_course_stats = self._analyze_horses_course_performance(horses, venue, distance, track_type)
            
            # 2. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡åˆ†æï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
            if progress_callback:
                progress_callback("é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾ã‚’åˆ†æä¸­...", 50)
            jockey_post_stats = []
            if jockeys and posts and len(jockeys) == len(posts):
                jockey_post_stats = self._analyze_jockeys_post_performance(jockeys, posts)
            
            # 3. é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾è¤‡å‹ç‡åˆ†æï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
            if progress_callback:
                progress_callback(f"é¨æ‰‹ã®{course_key}ã§ã®æˆç¸¾ã‚’åˆ†æä¸­...", 70)
            jockey_course_stats = []
            if jockeys:
                jockey_course_stats = self._analyze_jockeys_course_performance(jockeys, venue, distance, track_type)
            
            # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å ±å‘Š: åˆ†æå®Œäº†
            if progress_callback:
                progress_callback("åˆ†æçµæœã‚’ã¾ã¨ã‚ã¦ã„ã¾ã™...", 95)
            
            result = {
                'status': 'success',
                'type': 'trend_analysis',
                'course_info': {
                    'venue': venue,
                    'distance': distance,
                    'track_type': track_type,
                    'course_key': course_key
                },
                'trends': {
                    'horse_course_performance': horse_course_stats,      # 1. å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾
                    'jockey_post_performance': jockey_post_stats,        # 2. é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾
                    'jockey_course_performance': jockey_course_stats     # 3. é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾
                },
                'insights': self._generate_trend_insights_from_real_data(
                    horse_course_stats, jockey_post_stats, jockey_course_stats
                ),
                'data_period': '2023-2025',
                'sample_size': len(horses) + len(jockeys),
                'course_identifier': course_key
            }
            
            # çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
            self._cache_trend_result(cache_key, result)
            
            if progress_callback:
                progress_callback("åˆ†æå®Œäº†ï¼", 100)
                
            return result
            
        except Exception as e:
            logger.error(f"ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return {
                'status': 'error',
                'message': f'ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def recommend_betting_tickets(self, race_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        é¦¬åˆ¸æ¨å¥¨æ©Ÿèƒ½ - ViewLogicå±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‚’åŸºã«æ¨å¥¨é¦¬åˆ¸ã‚’ç”Ÿæˆ
        
        Args:
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼ˆå‡ºèµ°é¦¬ã€é¨æ‰‹ã€æ ç•ªãªã©ï¼‰
        
        Returns:
            æ¨å¥¨é¦¬åˆ¸æƒ…å ±
        """
        try:
            # åŸºæœ¬æƒ…å ±ã‚’å–å¾—
            venue = race_data.get('venue', 'ä¸æ˜')
            horses = race_data.get('horses', [])
            jockeys = race_data.get('jockeys', [])
            posts = race_data.get('posts', [])
            
            # ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼
            if not horses or len(horses) < 3:
                return {
                    'status': 'error',
                    'message': 'æ¨å¥¨é¦¬åˆ¸ã®ç”Ÿæˆã«ã¯æœ€ä½3é ­ã®å‡ºèµ°é¦¬ãŒå¿…è¦ã§ã™ã€‚'
                }
            
            # ã¾ãšViewLogicå±•é–‹äºˆæƒ³ã‚’å®Ÿè¡Œã—ã¦ä¸Šä½5é ­ã‚’å–å¾—
            flow_result = self.predict_race_flow_advanced(race_data)
            
            # å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‚’å–å¾—ï¼ˆrace_simulationã®finishã‹ã‚‰å–å¾—ï¼‰
            top_5_horses = []
            if flow_result and flow_result.get('status') == 'success':
                # race_simulationã®finishã‹ã‚‰ä¸Šä½5é ­ã‚’å–å¾—
                if 'race_simulation' in flow_result and 'finish' in flow_result['race_simulation']:
                    finish_order = flow_result['race_simulation']['finish']
                    logger.info(f"å±•é–‹äºˆæƒ³çµæœï¼ˆfinishï¼‰: {finish_order[:5]}")
                    # æ—¢ã«positionã§ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãªã®ã§ã€å…ˆé ­ã‹ã‚‰5é ­å–å¾—
                    for horse_info in finish_order[:5]:
                        horse_name = horse_info.get('horse_name')
                        if horse_name and horse_name in horses:
                            top_5_horses.append(horse_name)
                    logger.info(f"å±•é–‹äºˆæƒ³ä¸Šä½5é ­: {top_5_horses}")
                            
                # ã‚‚ã—ä¸Šè¨˜ã§å–å¾—ã§ããªã‘ã‚Œã°ã€æ—§å½¢å¼ã‚’è©¦ã™ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰
                elif 'prediction' in flow_result and 'predicted_result' in flow_result['prediction']:
                    logger.info("æ—§å½¢å¼ã§ã®å±•é–‹äºˆæƒ³çµæœå–å¾—ã‚’è©¦è¡Œ")
                    for rank_info in flow_result['prediction']['predicted_result']:
                        if 'ä½' in rank_info:
                            parts = rank_info.split(':')
                            if len(parts) >= 2:
                                horse_part = parts[1].strip()
                                horse_name = horse_part.split('(')[0].strip()
                                if horse_name in horses:
                                    top_5_horses.append(horse_name)
                                    if len(top_5_horses) >= 5:
                                        break
            
            # ä¸Šä½é¦¬ãŒå–å¾—ã§ããªã„å ´åˆã¯å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if len(top_5_horses) < 3:
                logger.warning("å±•é–‹äºˆæƒ³ã‹ã‚‰ååˆ†ãªä¸Šä½é¦¬ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
                recommendations = self._generate_betting_recommendations(race_data)
            else:
                # å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‹ã‚‰å…·ä½“çš„ãªè²·ã„ç›®ã‚’ç”Ÿæˆ
                recommendations = self._generate_betting_recommendations_from_top5(
                    top_5_horses, race_data, flow_result
                )
            
            return {
                'status': 'success',
                'type': 'betting_recommendation',
                'venue': venue,
                'total_horses': len(horses),
                'top_5_horses': top_5_horses[:5],  # ä¸Šä½5é ­ã‚’å«ã‚ã‚‹
                'recommendations': recommendations,
                'last_updated': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"é¦¬åˆ¸æ¨å¥¨ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'status': 'error',
                'message': f'é¦¬åˆ¸æ¨å¥¨ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def _generate_betting_recommendations(self, race_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """é¦¬åˆ¸æ¨å¥¨ã‚’ç”Ÿæˆ"""
        try:
            # å„é¦¬ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
            horse_scores = self._calculate_horse_scores(race_data)
            
            # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            sorted_horses = sorted(horse_scores.items(), key=lambda x: x[1]['total_score'], reverse=True)
            
            # æ¨å¥¨é¦¬åˆ¸ã‚’ç”Ÿæˆ
            recommendations = []
            budget = 10000  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆäºˆç®—1ä¸‡å††
            
            if len(sorted_horses) >= 2:
                # æœ¬å‘½é¦¬åˆ¸ï¼ˆä¸Šä½2é ­ã®é¦¬é€£ï¼‰
                top_horses = [sorted_horses[0][0], sorted_horses[1][0]]
                recommendations.append({
                    'type': 'æœ¬å‘½',
                    'ticket_type': 'é¦¬é€£',
                    'horses': top_horses,
                    'confidence': 85,
                    'investment': int(budget * 0.4),
                    'reason': f'{top_horses[0]} Ã— {top_horses[1]}ã®é‰„æ¿æ§‹æˆ'
                })
                
            if len(sorted_horses) >= 4:
                # å¯¾æŠ—é¦¬åˆ¸ï¼ˆ1ä½è»¸ã®3é€£è¤‡ï¼‰
                axis_horse = sorted_horses[0][0]
                target_horses = [sorted_horses[i][0] for i in range(1, 4)]
                recommendations.append({
                    'type': 'å¯¾æŠ—',
                    'ticket_type': '3é€£è¤‡',
                    'horses': [axis_horse] + target_horses,
                    'confidence': 65,
                    'investment': int(budget * 0.35),
                    'reason': f'{axis_horse}è»¸ã®æ‰‹å …ã„çµ„ã¿åˆã‚ã›'
                })
                
            # ç©´ç‹™ã„é¦¬åˆ¸ï¼ˆç‰¹æ®Šæ¡ä»¶ã®é¦¬ã‚’æ¢ã™ï¼‰
            surprise_candidate = self._find_surprise_candidate(sorted_horses, race_data)
            if surprise_candidate and len(sorted_horses) >= 3:
                surprise_horse = surprise_candidate['horse']
                surprise_reason = surprise_candidate['reason']
                recommendations.append({
                    'type': 'ç©´ç‹™ã„',
                    'ticket_type': 'é¦¬é€£',
                    'horses': [sorted_horses[0][0], surprise_horse],
                    'confidence': 25,
                    'investment': int(budget * 0.25),
                    'reason': f'{surprise_horse}ã¯{surprise_reason}'
                })
            
            # äºˆç®—ãŒä½™ã£ãŸå ´åˆã®èª¿æ•´
            total_invested = sum(rec['investment'] for rec in recommendations)
            if total_invested < budget:
                remaining = budget - total_invested
                if recommendations:
                    recommendations[-1]['investment'] += remaining
            
            return recommendations
            
        except Exception as e:
            logger.error(f"é¦¬åˆ¸æ¨å¥¨ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return []
    
    def _format_style_distribution(self, distribution: Dict) -> List[Dict]:
        """è„šè³ªåˆ†å¸ƒã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        result = []
        for style, data in distribution.items():
            if data['count'] > 0:
                result.append({
                    'style': style,
                    'count': data['count'],
                    'horses': data['horses'][:3]  # ä¸Šä½3é ­ã¾ã§
                })
        return result
    
    def _calculate_course_statistics(self, venue: str, distance: int = None, track_type: str = None) -> Dict:
        """ã‚³ãƒ¼ã‚¹çµ±è¨ˆã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®ãƒŠãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é›†è¨ˆï¼‰"""
        venue_code_map = {
            'æ±äº¬': '05', 'ä¸­å±±': '06', 'é˜ªç¥': '09', 'äº¬éƒ½': '08',
            'ä¸­äº¬': '07', 'æ–°æ½Ÿ': '04', 'æœ­å¹Œ': '02', 'å‡½é¤¨': '01',
            'ç¦å³¶': '03', 'å°å€‰': '10'
        }
        
        venue_code = venue_code_map.get(venue, '05')
        
        # é¨æ‰‹åˆ¥ã€è¡€çµ±åˆ¥ã€æ é †åˆ¥ã€è„šè³ªåˆ¥ã®çµ±è¨ˆã‚’é›†è¨ˆ
        jockey_stats = {}
        sire_stats = {}
        post_stats = {'å†…æ ï¼ˆ1-4ï¼‰': {'runs': 0, 'fukusho': 0}, 
                      'ä¸­æ ï¼ˆ5-12ï¼‰': {'runs': 0, 'fukusho': 0},
                      'å¤–æ ï¼ˆ13-18ï¼‰': {'runs': 0, 'fukusho': 0}}
        style_stats = {'é€ƒã’': {'runs': 0, 'fukusho': 0},
                       'å…ˆè¡Œ': {'runs': 0, 'fukusho': 0},
                       'å·®ã—': {'runs': 0, 'fukusho': 0},
                       'è¿½è¾¼': {'runs': 0, 'fukusho': 0}}
        total_races = 0
        
        try:
            # å…¨é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’èµ°æŸ»ã—ã¦é–‹å‚¬å ´åˆ¥ã®çµ±è¨ˆã‚’è¨ˆç®—
            for horse_name, horse_data in self.data_manager.horses_dict.items():
                if not horse_data or 'races' not in horse_data:
                    continue
                
                # å„é¦¬ã®è©²å½“é–‹å‚¬å ´ã§ã®ãƒ¬ãƒ¼ã‚¹ã‚’é›†è¨ˆ
                for race in horse_data.get('races', []):
                    # é–‹å‚¬å ´ã‚³ãƒ¼ãƒ‰ã§ä¸€è‡´ã‚’ç¢ºèªï¼ˆvenue_codeã‚’ä½¿ç”¨ï¼‰
                    if race.get('KEIBAJO_CODE') == venue_code:
                        # distanceã®ãƒã‚§ãƒƒã‚¯ï¼ˆKYORIãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ï¼‰
                        if distance:
                            race_distance = race.get('KYORI')
                            if race_distance:
                                # æ–‡å­—åˆ—ã®å ´åˆã¯æ•°å€¤ã«å¤‰æ›
                                if isinstance(distance, str):
                                    distance_num = int(distance.replace('m', ''))
                                else:
                                    distance_num = distance
                                if abs(int(race_distance) - distance_num) > 100:  # 100mä»¥ä¸Šã®å·®ãŒã‚ã‚Œã°é™¤å¤–
                                    continue
                        
                        # track_typeã®ãƒã‚§ãƒƒã‚¯ï¼ˆTRACK_CODEãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ï¼‰
                        if track_type:
                            track_code = race.get('TRACK_CODE', '')
                            # ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èŠ/ãƒ€ãƒ¼ãƒˆã‚’åˆ¤å®š
                            # 11-19: èŠ, 21-29: ãƒ€ãƒ¼ãƒˆ
                            if track_type == 'èŠ' and not (11 <= int(track_code) <= 19 if track_code else False):
                                continue
                            if track_type == 'ãƒ€ãƒ¼ãƒˆ' and not (21 <= int(track_code) <= 29 if track_code else False):
                                continue
                        
                        total_races += 1
                        
                        # é¨æ‰‹çµ±è¨ˆ
                        jockey = race.get('KISHUMEI_RYAKUSHO')  # é¨æ‰‹åç•¥ç§°
                        if jockey:
                            if jockey not in jockey_stats:
                                jockey_stats[jockey] = {'runs': 0, 'wins': 0, 'fukusho': 0}
                            jockey_stats[jockey]['runs'] += 1
                            finish = race.get('KAKUTEI_CHAKUJUN')
                            if finish is not None:
                                if finish == 1:
                                    jockey_stats[jockey]['wins'] += 1
                                if finish <= 3:
                                    jockey_stats[jockey]['fukusho'] += 1
                        
                        # è¡€çµ±çµ±è¨ˆï¼ˆç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ï¼‰
                        # TODO: è¡€çµ±ãƒ‡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚ŒãŸã‚‰å®Ÿè£…
                        pass
                        
                        # æ é †çµ±è¨ˆï¼ˆPhase 4ãƒ‡ãƒ¼ã‚¿ãŒæ¬ è½ã—ã¦ã„ã‚‹ãŸã‚ã€ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                        # é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡ã¯å¾Œã§é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‹ã‚‰å–å¾—
                        
                        # è„šè³ªçµ±è¨ˆï¼ˆã‚³ãƒ¼ãƒŠãƒ¼é€šéé †ä½ã‹ã‚‰åˆ¤å®šï¼‰
                        corner1 = race.get('CORNER1_JUNI')
                        if corner1 is not None:
                            if corner1 <= 2:
                                style = 'é€ƒã’'
                            elif corner1 <= 5:
                                style = 'å…ˆè¡Œ'
                            elif corner1 <= 9:
                                style = 'å·®ã—'
                            else:
                                style = 'è¿½è¾¼'
                            if style in style_stats:
                                style_stats[style]['runs'] += 1
                                finish_pos = race.get('KAKUTEI_CHAKUJUN')
                                if finish_pos is not None and finish_pos <= 3:
                                    style_stats[style]['fukusho'] += 1
            
            # é¨æ‰‹çµ±è¨ˆã‚’ãƒªã‚¹ãƒˆå½¢å¼ã«å¤‰æ›ï¼ˆè¤‡å‹ç‡é †ï¼‰
            jockey_list = []
            for name, stats in jockey_stats.items():
                if stats['runs'] >= 5:  # 5å›ä»¥ä¸Šé¨ä¹—ã—ãŸé¨æ‰‹ã®ã¿
                    jockey_list.append({
                        'name': name,
                        'wins': stats['wins'],
                        'runs': stats['runs'],
                        'win_rate': stats['wins'] / stats['runs'] if stats['runs'] > 0 else 0,
                        'fukusho_rate': stats['fukusho'] / stats['runs'] if stats['runs'] > 0 else 0
                    })
            jockey_list.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            # è¡€çµ±çµ±è¨ˆã‚’ãƒªã‚¹ãƒˆå½¢å¼ã«å¤‰æ›ï¼ˆè¤‡å‹ç‡é †ï¼‰
            sire_list = []
            for name, stats in sire_stats.items():
                if stats['runs'] >= 10:  # 10é ­ä»¥ä¸Šã®ç”£é§’ãŒå‡ºèµ°
                    sire_list.append({
                        'name': name,
                        'runs': stats['runs'],
                        'fukusho_rate': stats['fukusho'] / stats['runs'] if stats['runs'] > 0 else 0
                    })
            sire_list.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‹ã‚‰æ é †åˆ¥è¤‡å‹ç‡ã‚’å–å¾—ï¼ˆä¸Šä½é¨æ‰‹ã®ã¿ï¼‰
            top_jockeys = [j['name'] for j in jockey_list[:10]]
            if top_jockeys:
                jockey_post_stats = self.jockey_manager.get_jockey_post_position_fukusho_rates(top_jockeys)
                
                # é›†è¨ˆã—ã¦å¹³å‡ã‚’è¨ˆç®—
                aggregated_post_stats = {
                    'å†…æ ï¼ˆ1-6ï¼‰': {'fukusho_rate': 0, 'race_count': 0, 'jockey_count': 0},
                    'ä¸­æ ï¼ˆ7-12ï¼‰': {'fukusho_rate': 0, 'race_count': 0, 'jockey_count': 0},
                    'å¤–æ ï¼ˆ13-18ï¼‰': {'fukusho_rate': 0, 'race_count': 0, 'jockey_count': 0}
                }
                
                for jockey_name, jockey_post_data in jockey_post_stats.items():
                    for category, stats in jockey_post_data.items():
                        if stats['race_count'] > 0:
                            prev_count = aggregated_post_stats[category]['race_count']
                            prev_rate = aggregated_post_stats[category]['fukusho_rate']
                            new_count = stats['race_count']
                            new_rate = stats['fukusho_rate']
                            
                            # é‡ã¿ä»˜ãå¹³å‡
                            total_count = prev_count + new_count
                            if total_count > 0:
                                aggregated_post_stats[category]['fukusho_rate'] = (
                                    (prev_rate * prev_count + new_rate * new_count) / total_count
                                )
                                aggregated_post_stats[category]['race_count'] = total_count
                                aggregated_post_stats[category]['jockey_count'] += 1
                
                # post_statsã‚’é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã«ç½®ãæ›ãˆ
                post_stats = aggregated_post_stats
            
            # è„šè³ªçµ±è¨ˆã«å‹ç‡ãƒ»è¤‡å‹ç‡ã‚’è¿½åŠ 
            for key in style_stats:
                runs = style_stats[key]['runs']
                if runs > 0:
                    style_stats[key]['fukusho_rate'] = style_stats[key]['fukusho'] / runs
                else:
                    style_stats[key]['fukusho_rate'] = 0
            
            return {
                'jockey_stats': jockey_list[:10],  # ä¸Šä½10å
                'sire_stats': sire_list[:10],      # ä¸Šä½10é ­
                'post_stats': post_stats,
                'style_stats': style_stats,
                'total_races': total_races
            }
            
        except Exception as e:
            logger.warning(f"ã‚³ãƒ¼ã‚¹çµ±è¨ˆã®è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'jockey_stats': [],
                'sire_stats': [],
                'post_stats': {},
                'style_stats': {},
                'total_races': 0
            }
    
    def _calculate_daily_prediction(self, date: str, venue: str, race_data: Dict[str, Any] = None) -> Dict:
        """å½“æ—¥ã®å‚¾å‘ã‚’äºˆæƒ³ï¼ˆå®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ï¼‰"""
        # race_dataãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã¯ã€ãã®ãƒ¬ãƒ¼ã‚¹ã®å‡ºèµ°é¦¬ãƒ»é¨æ‰‹ã‹ã‚‰å‚¾å‘ã‚’äºˆæƒ³
        if race_data:
            return self._predict_from_race_data(venue, race_data)
        # race_dataãŒãªã„å ´åˆã¯ã€ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é–‹å‚¬å ´ã®ä¸€èˆ¬çš„ãªå‚¾å‘ã‚’äºˆæƒ³
        return self._predict_from_knowledge(venue)
    
    def _predict_from_race_data(self, venue: str, race_data: Dict[str, Any]) -> Dict:
        """ç‰¹å®šãƒ¬ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å½“æ—¥å‚¾å‘ã‚’äºˆæƒ³"""
        horses = race_data.get('horses', [])
        jockeys = race_data.get('jockeys', [])
        
        # è„šè³ªå‚¾å‘ã‚’äºˆæƒ³
        style_prediction = self._predict_style_trend(horses)
        
        # é¨æ‰‹å‚¾å‘ã‚’äºˆæƒ³
        jockey_prediction = self._predict_jockey_trend(venue, jockeys)
        
        # æ é †å‚¾å‘ã‚’äºˆæƒ³ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‚’æ´»ç”¨ï¼‰
        post_prediction = self._predict_post_trend(venue, jockeys)
        
        return {
            'style_performance': style_prediction,
            'hot_jockeys': jockey_prediction,
            'post_trend': post_prediction,
            'track_condition': 'è‰¯',
            'track_bias': self._predict_track_bias(post_prediction),
            'races_completed': 0
        }
    
    def _predict_from_knowledge(self, venue: str) -> Dict:
        """ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ä¸€èˆ¬çš„ãªå‚¾å‘ã‚’äºˆæƒ³"""
        # _calculate_course_statisticsã‚’æ´»ç”¨
        course_stats = self._calculate_course_statistics(venue)
        
        return {
            'style_performance': course_stats.get('style_stats', {}),
            'hot_jockeys': course_stats.get('jockey_stats', [])[:3],
            'post_trend': course_stats.get('post_stats', {}),
            'track_condition': 'è‰¯',
            'track_bias': 'ãƒ•ãƒ©ãƒƒãƒˆ',
            'races_completed': 0
        }
    
    def _predict_style_trend(self, horses: List[str]) -> Dict:
        """å‡ºèµ°é¦¬ã‹ã‚‰è„šè³ªå‚¾å‘ã‚’äºˆæƒ³"""
        style_counts = {'é€ƒã’': 0, 'å…ˆè¡Œ': 0, 'å·®ã—': 0, 'è¿½è¾¼': 0}
        
        for horse_name in horses:
            horse_data = self.data_manager.get_horse_data(horse_name)
            if horse_data and 'races' in horse_data:
                style = self.style_analyzer.classify_basic_style(horse_data['races'])
                if style in style_counts:
                    style_counts[style] += 1
        
        # å‚¾å‘ã‚’åˆ¤å®š
        total = sum(style_counts.values())
        style_performance = {}
        for style, count in style_counts.items():
            style_performance[style] = {
                'runs': count,
                'ratio': count / total if total > 0 else 0
            }
        
        return style_performance
    
    def _predict_jockey_trend(self, venue: str, jockeys: List[str]) -> List[Dict]:
        """é¨æ‰‹ãƒªã‚¹ãƒˆã‹ã‚‰å¥½èª¿é¨æ‰‹ã‚’äºˆæƒ³"""
        jockey_stats = []
        
        if not jockeys or not self.jockey_manager.is_loaded():
            return jockey_stats
        
        # å„é¨æ‰‹ã®æˆç¸¾ã‚’å–å¾—ï¼ˆæ­£è¦åŒ–ã—ã¦ã‹ã‚‰æ¤œç´¢ï¼‰
        for jockey_name in jockeys:
            # é¨æ‰‹åã‚’æ­£è¦åŒ–
            normalized_name = self._normalize_jockey_name(jockey_name)
            jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
            
            # jockey_dataãŒdictã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
            if jockey_data and isinstance(jockey_data, dict):
                # é¨æ‰‹ã®ç·åˆæˆç¸¾ã‚’å–å¾—
                overall_stats = jockey_data.get('overall_stats', {})
                if overall_stats:
                    jockey_stats.append({
                        'name': jockey_name,  # å…ƒã®åå‰ã‚’è¡¨ç¤ºç”¨ã«ä½¿ç”¨
                        'results': f"{overall_stats.get('total_races_analyzed', 0)}æˆ¦",
                        'fukusho_rate': overall_stats.get('overall_fukusho_rate', 0) / 100,  # ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆã‚’å°æ•°ã«
                        'venue_course_stats': jockey_data.get('venue_course_stats', {})
                    })
            else:
                logger.warning(f"é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯ç„¡åŠ¹: {jockey_name} â†’ {normalized_name}")
        
        # è¤‡å‹ç‡é †ã«ã‚½ãƒ¼ãƒˆ
        jockey_stats.sort(key=lambda x: x['fukusho_rate'], reverse=True)
        
        return jockey_stats
    
    def _predict_post_trend(self, venue: str, jockeys: List[str] = None) -> Dict:
        """é–‹å‚¬å ´ã®æ é †å‚¾å‘ã‚’äºˆæƒ³ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‚’æ´»ç”¨ï¼‰"""
        if jockeys and self.jockey_manager.is_loaded():
            # é¨æ‰‹åã‚’æ­£è¦åŒ–ã—ã¦ã‹ã‚‰æ é †åˆ¥è¤‡å‹ç‡ã‚’å–å¾—
            normalized_jockeys = [self._normalize_jockey_name(j) for j in jockeys]
            jockey_post_stats = self.jockey_manager.get_jockey_post_position_fukusho_rates(normalized_jockeys)
            
            # é›†è¨ˆ
            aggregated_stats = {
                'å†…æ ï¼ˆ1-6ï¼‰': {'fukusho_rate': 0, 'race_count': 0},
                'ä¸­æ ï¼ˆ7-12ï¼‰': {'fukusho_rate': 0, 'race_count': 0},
                'å¤–æ ï¼ˆ13-18ï¼‰': {'fukusho_rate': 0, 'race_count': 0}
            }
            
            for jockey_name, jockey_data in jockey_post_stats.items():
                for category, stats in jockey_data.items():
                    if stats['race_count'] > 0:
                        prev_count = aggregated_stats[category]['race_count']
                        prev_rate = aggregated_stats[category]['fukusho_rate']
                        new_count = stats['race_count']
                        new_rate = stats['fukusho_rate']
                        
                        total_count = prev_count + new_count
                        if total_count > 0:
                            aggregated_stats[category]['fukusho_rate'] = (
                                (prev_rate * prev_count + new_rate * new_count) / total_count
                            )
                            aggregated_stats[category]['race_count'] = total_count
            
            return aggregated_stats
        else:
            # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯å¾“æ¥ã®æ–¹æ³•
            course_stats = self._calculate_course_statistics(venue)
            return course_stats.get('post_stats', {})
    
    def _predict_track_bias(self, post_trend: Dict) -> str:
        """æ é †å‚¾å‘ã‹ã‚‰ãƒˆãƒ©ãƒƒã‚¯ãƒã‚¤ã‚¢ã‚¹ã‚’äºˆæƒ³"""
        if not post_trend:
            return 'ãƒ•ãƒ©ãƒƒãƒˆ'
        
        # ãƒ™ã‚¤ã‚ºè£œæ­£ã‚’é©ç”¨ï¼ˆå†…æ ã¯1-6ã€å¤–æ ã¯13-18ï¼‰
        outer_rate = post_trend.get('å¤–æ ï¼ˆ13-18ï¼‰', {}).get('fukusho_rate', 0)
        inner_rate = post_trend.get('å†…æ ï¼ˆ1-6ï¼‰', {}).get('fukusho_rate', 0)
        
        if outer_rate > 0.4:
            return 'å¤–æœ‰åˆ©'
        elif inner_rate > 0.4:
            return 'å†…æœ‰åˆ©'
        return 'ãƒ•ãƒ©ãƒƒãƒˆ'
    
    def _generate_daily_prediction_text(self, daily_stats: Dict, venue: str) -> str:
        """å½“æ—¥å‚¾å‘ã®è©³ç´°ãªäºˆæƒ³æ–‡ç« ã‚’ç”Ÿæˆ"""
        lines = []
        lines.append(f"## æœ¬æ—¥ã®{venue}å‚¾å‘äºˆæƒ³")
        lines.append("")
        
        # è„šè³ªå‚¾å‘ã®è©³ç´°åˆ†æ
        style_perf = daily_stats.get('style_performance', {})
        if style_perf:
            lines.append("### è„šè³ªåˆ¥äºˆæƒ³")
            # çµ±è¨ˆã‚’æ•´ç†
            sorted_styles = sorted(style_perf.items(), key=lambda x: x[1].get('ratio', 0), reverse=True)
            
            for style, data in sorted_styles:
                if data.get('runs', 0) > 0:
                    ratio = data.get('ratio', 0)
                    lines.append(f"- **{style}**: {data['runs']}é ­ (æ§‹æˆæ¯” {ratio*100:.1f}%)")
            
            # æœ€ã‚‚æœ‰åˆ©ãªè„šè³ªã‚’åˆ¤å®š
            best_style = max(style_perf.items(), key=lambda x: x[1].get('ratio', 0))
            if best_style[1].get('ratio', 0) > 0.3:
                lines.append("")
                lines.append(f"**äºˆæƒ³**: {best_style[0]}é¦¬ãŒ{best_style[1]['runs']}é ­ã¨å¤šãã€ãƒšãƒ¼ã‚¹ãŒ{'é€Ÿã' if best_style[0] in ['é€ƒã’', 'å…ˆè¡Œ'] else 'è½ã¡ç€ã„ãŸå±•é–‹ã«'}ãªã‚Šãã†ã§ã™ã€‚")
        
        lines.append("")
        
        # å¥½èª¿é¨æ‰‹ã®è©³ç´°
        hot_jockeys = daily_stats.get('hot_jockeys', [])
        if hot_jockeys:
            lines.append("### æ³¨ç›®é¨æ‰‹")
            for i, jockey in enumerate(hot_jockeys[:3], 1):
                lines.append(f"{i}. **{jockey['name']}** - è¤‡å‹ç‡ {jockey['fukusho_rate']*100:.1f}% ({jockey.get('results', 'ãƒ‡ãƒ¼ã‚¿ãªã—')})")
            
            if hot_jockeys[0]['fukusho_rate'] > 0.5:
                lines.append("")
                lines.append(f"ç‰¹ã«**{hot_jockeys[0]['name']}é¨æ‰‹**ã¯è¤‡å‹ç‡{hot_jockeys[0]['fukusho_rate']*100:.1f}%ã¨çµ¶å¥½èª¿ã§ã™ã€‚")
        
        lines.append("")
        
        # æ é †å‚¾å‘ã®è©³ç´°
        lines.append("### æ é †å‚¾å‘")
        post_trend = daily_stats.get('post_trend', {})
        if post_trend:
            for position, stats in post_trend.items():
                fukusho_rate = stats.get('fukusho_rate', 0)
                race_count = stats.get('race_count', 0)
                if race_count > 0:
                    lines.append(f"- {position}: è¤‡å‹ç‡ **{fukusho_rate:.1f}%** ({race_count}ãƒ¬ãƒ¼ã‚¹)")
        
        # ãƒˆãƒ©ãƒƒã‚¯ãƒã‚¤ã‚¢ã‚¹åˆ¤å®š
        track_bias = daily_stats.get('track_bias', 'ãƒ•ãƒ©ãƒƒãƒˆ')
        lines.append("")
        if track_bias == 'å¤–æœ‰åˆ©':
            lines.append("**ãƒã‚¤ã‚¢ã‚¹**: å¤–æ æœ‰åˆ© - å¤–å›ã‚Šã‚³ãƒ¼ã‚¹ã§å·®ã—é¦¬ãŒå°é ­ã—ã‚„ã™ã„å‚¾å‘")
        elif track_bias == 'å†…æœ‰åˆ©':
            lines.append("**ãƒã‚¤ã‚¢ã‚¹**: å†…æ æœ‰åˆ© - å†…ãƒ©ãƒæ²¿ã„ãŒä¼¸ã³ã‚‹é¦¬å ´çŠ¶æ…‹")
        else:
            lines.append("**ãƒã‚¤ã‚¢ã‚¹**: ãƒ•ãƒ©ãƒƒãƒˆ - æ é †ã«ã‚ˆã‚‹æœ‰åˆ©ä¸åˆ©ã¯å°‘ãªã„")
        
        lines.append("")
        lines.append("---")
        
        return "\n".join(lines)
    
    def _calculate_daily_statistics(self, date: str, venue: str) -> Dict:
        """å½“æ—¥çµ±è¨ˆã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆæƒ³ï¼‰"""
        # å®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å½“æ—¥ã®å‚¾å‘ã‚’äºˆæƒ³
        # ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©²å½“é–‹å‚¬å ´ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æ
        
        # åˆæœŸåŒ–
        statistics = {
            'style_performance': {},
            'hot_jockeys': [],
            'post_trend': {},
            'track_condition': 'è‰¯',
            'track_bias': 'ãƒ•ãƒ©ãƒƒãƒˆ',
            'races_completed': 0
        }
        
        try:
            # ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é–‹å‚¬å ´åˆ¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ
            # å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿åˆ†æã‚’å®Ÿè£…ï¼ˆä»®å®Ÿè£…ã‚’å®Ÿãƒ‡ãƒ¼ã‚¿ã«ç½®ãæ›ãˆã‚‹å¿…è¦ï¼‰
            # TODO: å®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é›†è¨ˆã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
            return statistics
            
        except Exception as e:
            logger.warning(f"å½“æ—¥çµ±è¨ˆã®è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return statistics
    
    def _generate_course_insights(self, stats: Dict) -> List[str]:
        """ã‚³ãƒ¼ã‚¹å‚¾å‘ã‹ã‚‰ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’ç”Ÿæˆ"""
        insights = []
        
        # é¨æ‰‹å‚¾å‘
        if stats.get('jockey_stats'):
            top_jockey = stats['jockey_stats'][0]
            insights.append(f"é¨æ‰‹ã¯{top_jockey['name']}ãŒè¤‡å‹ç‡{top_jockey['fukusho_rate']:.0%}ã§æœ€ã‚‚å¥½æˆç¸¾")
        
        # æ é †å‚¾å‘
        post_stats = stats.get('post_stats', {})
        if 'ä¸­æ ï¼ˆ5-12ï¼‰' in post_stats:
            insights.append("ä¸­æ ã®è¤‡å‹ç‡ãŒé«˜ãæœ‰åˆ©ãªå‚¾å‘")
        
        # è„šè³ªå‚¾å‘
        style_stats = stats.get('style_stats', {})
        if style_stats.get('å…ˆè¡Œ', {}).get('win_rate', 0) > 0.18:
            insights.append("å…ˆè¡Œé¦¬ãŒæœ‰åˆ©ãªã‚³ãƒ¼ã‚¹")
        
        return insights
    
    def _generate_daily_recommendations(self, stats: Dict) -> List[str]:
        """å½“æ—¥çµ±è¨ˆã‹ã‚‰æ¨å¥¨äº‹é …ã‚’ç”Ÿæˆ"""
        recommendations = []
        
        # é¨æ‰‹æ¨å¥¨
        hot_jockeys = stats.get('hot_jockeys', [])
        if hot_jockeys:
            top_jockey = hot_jockeys[0]
            recommendations.append(f"{top_jockey['name']}é¨æ‰‹ã®é¨ä¹—é¦¬ã¯è¦æ³¨ç›®")
        
        # è„šè³ªæ¨å¥¨
        style_stats = stats.get('style_stats', {})
        best_style = max(style_stats.items(), key=lambda x: x[1].get('fukusho_rate', 0), default=None)
        if best_style and best_style[1].get('fukusho_rate', 0) > 0.3:
            recommendations.append(f"{best_style[0]}é¦¬ä¸­å¿ƒã®é¦¬åˆ¸æ§‹æˆ")
        
        return recommendations
    
    def _calculate_horse_scores(self, race_data: Dict[str, Any]) -> Dict[str, Dict]:
        """å„é¦¬ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—"""
        horses = race_data.get('horses', [])
        jockeys = race_data.get('jockeys', [])
        posts = race_data.get('posts', [])
        venue = race_data.get('venue', '')
        
        horse_scores = {}
        
        for i, horse_name in enumerate(horses):
            try:
                # ViewLogicãƒ™ãƒ¼ã‚¹ã‚¹ã‚³ã‚¢ï¼ˆé¦¬ã®åŸºæœ¬ã‚¹ã‚³ã‚¢ï¼‰
                horse_data = self.data_manager.get_horse_data(horse_name)
                base_score = 50.0  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚³ã‚¢
                
                if horse_data and 'running_style' in horse_data:
                    style_data = horse_data['running_style']
                    # ã‚¹ã‚¿ã‚¤ãƒ«è©•ä¾¡ã‹ã‚‰åŸºæœ¬ç‚¹ã‚’ç®—å‡º
                    if isinstance(style_data, dict):
                        confidence = style_data.get('confidence', 0.5)
                        base_score = 50 + (confidence * 30)  # 50-80ç‚¹ã®ç¯„å›²
                
                # é¨æ‰‹ã‚¹ã‚³ã‚¢åŠ ç®—
                jockey_bonus = 0
                if i < len(jockeys) and self.jockey_manager.is_loaded():
                    jockey_name = self._normalize_jockey_name(jockeys[i])
                    jockey_data = self.jockey_manager.get_jockey_data(jockey_name)
                    if jockey_data and isinstance(jockey_data, dict):
                        overall_stats = jockey_data.get('overall_stats', {})
                        fukusho_rate = overall_stats.get('overall_fukusho_rate', 0)
                        jockey_bonus = (fukusho_rate / 100) * 20  # æœ€å¤§20ç‚¹åŠ ç®—
                
                # æ é †ãƒœãƒ¼ãƒŠã‚¹ï¼ˆå†…æ æœ‰åˆ©ãªã©ï¼‰
                post_bonus = 0
                if i < len(posts):
                    post = posts[i]
                    if 1 <= post <= 6:
                        post_bonus = 5
                    elif 7 <= post <= 12:
                        post_bonus = 2
                    # å¤–æ ï¼ˆ13-18ï¼‰ã¯åŠ ç®—ãªã—
                
                # æœ€çµ‚ã‚¹ã‚³ã‚¢
                total_score = base_score + jockey_bonus + post_bonus
                
                horse_scores[horse_name] = {
                    'total_score': min(total_score, 100),  # 100ç‚¹ä¸Šé™
                    'base_score': base_score,
                    'jockey_bonus': jockey_bonus,
                    'post_bonus': post_bonus,
                    'jockey': jockeys[i] if i < len(jockeys) else 'ä¸æ˜',
                    'post': posts[i] if i < len(posts) else 0
                }
                
            except Exception as e:
                logger.error(f"é¦¬{horse_name}ã®ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
                horse_scores[horse_name] = {
                    'total_score': 50.0,
                    'base_score': 50.0,
                    'jockey_bonus': 0,
                    'post_bonus': 0,
                    'jockey': jockeys[i] if i < len(jockeys) else 'ä¸æ˜',
                    'post': posts[i] if i < len(posts) else 0
                }
        
        return horse_scores
    
    def _find_surprise_candidate(self, sorted_horses: List, race_data: Dict[str, Any]) -> Dict:
        """ç©´é¦¬å€™è£œã‚’æ¢ã™"""
        if len(sorted_horses) < 6:
            return None
            
        # ä¸­ä½ã‹ã‚‰ä¸‹ä½ã®é¦¬ï¼ˆ4-8ä½ï¼‰ã§ç‰¹æ®Šæ¡ä»¶ã®ã‚ã‚‹é¦¬ã‚’æ¢ã™
        candidates = sorted_horses[3:8] if len(sorted_horses) >= 8 else sorted_horses[3:]
        
        for horse_name, horse_data in candidates:
            # é¨æ‰‹ãŒå¥½èª¿
            jockey = horse_data.get('jockey', '')
            if self._is_hot_jockey(jockey):
                return {
                    'horse': horse_name,
                    'reason': f'{jockey}é¨æ‰‹ã®å¥½èª¿'
                }
            
            # å†…æ ã§é€ƒã’ãƒ»å…ˆè¡Œ
            if horse_data.get('post', 0) <= 6:
                horse_viewlogic_data = self.data_manager.get_horse_data(horse_name)
                if horse_viewlogic_data and 'running_style' in horse_viewlogic_data:
                    style_data = horse_viewlogic_data['running_style']
                    if isinstance(style_data, dict) and style_data.get('style') in ['é€ƒã’', 'å…ˆè¡Œ']:
                        return {
                            'horse': horse_name,
                            'reason': f'å†…æ {horse_data["post"]}ç•ªã‹ã‚‰ã®{style_data["style"]}'
                        }
        
        # è©²å½“ãªã—ã®å ´åˆã¯6ä½ã®é¦¬ã‚’è¿”ã™
        if len(sorted_horses) >= 6:
            return {
                'horse': sorted_horses[5][0],
                'reason': 'ä¸­ç©´å€™è£œ'
            }
        
        return None
    
    def _get_surprise_reason(self, horse_name: str, race_data: Dict[str, Any]) -> str:
        """ç©´é¦¬ã®ç†ç”±ã‚’å–å¾—"""
        horse_viewlogic_data = self.data_manager.get_horse_data(horse_name)
        if horse_viewlogic_data and 'running_style' in horse_viewlogic_data:
            style_data = horse_viewlogic_data['running_style']
            if isinstance(style_data, dict):
                return f"{style_data.get('style', 'ä¸æ˜')}ã‚¿ã‚¤ãƒ—ã®ç©´é¦¬"
        return "ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã«ã‚ˆã‚‹ç©´é¦¬"
    
    def _is_hot_jockey(self, jockey_name: str) -> bool:
        """é¨æ‰‹ãŒå¥½èª¿ã‹ã©ã†ã‹åˆ¤å®š"""
        if not jockey_name or not self.jockey_manager.is_loaded():
            return False
            
        normalized_name = self._normalize_jockey_name(jockey_name)
        jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
        
        if jockey_data and isinstance(jockey_data, dict):
            overall_stats = jockey_data.get('overall_stats', {})
            fukusho_rate = overall_stats.get('overall_fukusho_rate', 0)
            return fukusho_rate > 40  # 40%ä»¥ä¸Šã‚’å¥½èª¿ã¨ã¿ãªã™
        
        return False
    
    def _generate_betting_recommendations_from_top5(
        self, 
        top_5_horses: List[str], 
        race_data: Dict[str, Any],
        flow_result: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‹ã‚‰å®Ÿè·µçš„ãªé¦¬åˆ¸è²·ã„ç›®ã‚’ç”Ÿæˆ
        
        Args:
            top_5_horses: å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±
            flow_result: å±•é–‹äºˆæƒ³çµæœ
        
        Returns:
            æ¨å¥¨é¦¬åˆ¸ãƒªã‚¹ãƒˆ
        """
        try:
            recommendations = []
            budget = 10000  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆäºˆç®—1ä¸‡å††
            
            # æœ€ä½3é ­ã¯å¿…è¦
            if len(top_5_horses) < 3:
                return []
            
            # 1. å˜å‹ï¼ˆ1ä½ã®é¦¬ï¼‰
            if len(top_5_horses) >= 1:
                recommendations.append({
                    'type': 'å˜å‹',
                    'ticket_type': 'å˜å‹',
                    'horses': [top_5_horses[0]],
                    'confidence': 75,
                    'investment': int(budget * 0.2),  # 20%
                    'reason': f'ViewLogicå±•é–‹äºˆæƒ³1ä½ã®{top_5_horses[0]}',
                    'buy_type': 'ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆ'
                })
            
            # 2. é¦¬é€£BOXï¼ˆä¸Šä½3é ­ï¼‰
            if len(top_5_horses) >= 3:
                box_horses = top_5_horses[:3]
                recommendations.append({
                    'type': 'é¦¬é€£BOX',
                    'ticket_type': 'é¦¬é€£',
                    'horses': box_horses,
                    'confidence': 65,
                    'investment': int(budget * 0.25),  # 25%
                    'reason': f'ä¸Šä½3é ­ï¼ˆ{", ".join(box_horses)}ï¼‰ã®BOXè²·ã„',
                    'buy_type': 'BOX',
                    'combinations': 3  # 3é ­BOXã¯3é€šã‚Š
                })
            
            # 3. 3é€£å˜1ç€æµã—ï¼ˆ1ä½è»¸ã€2-3ä½ã‹ã‚‰2ç€ã€4-5ä½ã‹ã‚‰3ç€ï¼‰
            if len(top_5_horses) >= 4:
                first = top_5_horses[0]
                second_candidates = top_5_horses[1:3]  # 2-3ä½
                third_candidates = top_5_horses[2:min(5, len(top_5_horses))]  # 3-5ä½
                
                recommendations.append({
                    'type': '3é€£å˜æµã—',
                    'ticket_type': '3é€£å˜',
                    'horses': {
                        '1ç€': [first],
                        '2ç€': second_candidates,
                        '3ç€': third_candidates
                    },
                    'confidence': 45,
                    'investment': int(budget * 0.25),  # 25%
                    'reason': f'{first}ã®1ç€å›ºå®šã€2-3ç€æµã—',
                    'buy_type': 'æµã—',
                    'combinations': len(second_candidates) * len(third_candidates)
                })
            
            # 4. ãƒ¯ã‚¤ãƒ‰ï¼ˆ1ä½ã¨2-3ä½ã®çµ„ã¿åˆã‚ã›ï¼‰
            if len(top_5_horses) >= 3:
                axis = top_5_horses[0]
                partners = top_5_horses[1:3]
                recommendations.append({
                    'type': 'ãƒ¯ã‚¤ãƒ‰',
                    'ticket_type': 'ãƒ¯ã‚¤ãƒ‰',
                    'horses': {
                        'è»¸': axis,
                        'ç›¸æ‰‹': partners
                    },
                    'confidence': 80,
                    'investment': int(budget * 0.15),  # 15%
                    'reason': f'{axis}è»¸ã®ãƒ¯ã‚¤ãƒ‰ã€ç¢ºå®Ÿæ€§é‡è¦–',
                    'buy_type': 'è»¸æµã—',
                    'combinations': len(partners)
                })
            
            # 5. 3é€£è¤‡ï¼ˆä¸Šä½4é ­BOXï¼‰- ç©´ç‹™ã„
            if len(top_5_horses) >= 4:
                box_horses = top_5_horses[:4]
                recommendations.append({
                    'type': '3é€£è¤‡BOX',
                    'ticket_type': '3é€£è¤‡',
                    'horses': box_horses,
                    'confidence': 55,
                    'investment': int(budget * 0.15),  # 15%
                    'reason': f'ä¸Šä½4é ­ã®BOXã€é…å½“ç‹™ã„',
                    'buy_type': 'BOX',
                    'combinations': 4  # 4é ­ã‹ã‚‰3é ­é¸ã¶çµ„ã¿åˆã‚ã›
                })
            
            # ãƒšãƒ¼ã‚¹åˆ¤å®šã‚’è¿½åŠ æƒ…å ±ã¨ã—ã¦ä»˜ä¸
            pace_info = ""
            if flow_result and 'pace' in flow_result:
                pace_data = flow_result['pace']
                if 'predicted_pace' in pace_data:
                    pace_info = f"ï¼ˆäºˆæƒ³ãƒšãƒ¼ã‚¹: {pace_data['predicted_pace']}ï¼‰"
            
            # å„æ¨å¥¨ã«ãƒšãƒ¼ã‚¹æƒ…å ±ã‚’è¿½åŠ 
            for rec in recommendations:
                if pace_info and 'ç†ç”±' in rec:
                    rec['reason'] += pace_info
            
            return recommendations
            
        except Exception as e:
            logger.error(f"å±•é–‹äºˆæƒ³ãƒ™ãƒ¼ã‚¹ã®é¦¬åˆ¸ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return self._generate_betting_recommendations(race_data)

    # =====================================
    # ViewLogicå‚¾å‘åˆ†æï¼š4é …ç›®åˆ†æãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
    # =====================================

    def _analyze_horses_course_performance(self, horses: List[str], venue: str, distance: int, track_type: str) -> List[Dict]:
        """
        1. å‡ºå ´ã™ã‚‹é¦¬å…¨ã¦ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡ã‚’åˆ†æ
        
        Args:
            horses: å‡ºå ´é¦¬åãƒªã‚¹ãƒˆ
            venue: é–‹å‚¬å ´ï¼ˆæ–°æ½Ÿã€æ±äº¬ãªã©ï¼‰
            distance: è·é›¢ï¼ˆ1800ãªã©ï¼‰
            track_type: ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼ˆèŠã€ãƒ€ãƒ¼ãƒˆãªã©ï¼‰
            
        Returns:
            å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ãƒªã‚¹ãƒˆ
        """
        horse_performances = []
        
        # horsesãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
        logger.info(f"_analyze_horses_course_performance called with horses type: {type(horses)}, value: {horses}")
        if not isinstance(horses, list):
            logger.error(f"horses ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(horses)}")
            return []
        
        course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
        
        # é–‹å‚¬å ´ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
        venue_codes = {
            'æœ­å¹Œ': '01', 'å‡½é¤¨': '02', 'ç¦å³¶': '03', 'æ–°æ½Ÿ': '04',
            'æ±äº¬': '05', 'ä¸­å±±': '06', 'ä¸­äº¬': '07', 'äº¬éƒ½': '08',
            'é˜ªç¥': '09', 'å°å€‰': '10'
        }
        venue_code = venue_codes.get(venue, '')
        
        try:
            logger.info(f"é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æé–‹å§‹: {len(horses)}é ­, venue_code={venue_code}, distance={distance}")
            logger.info(f"data_manager loaded: {self.data_manager.is_loaded()}, total_horses: {self.data_manager.get_total_horses()}")
            
            for item in horses:
                # itemãŒæ–‡å­—åˆ—ï¼ˆé¦¬åï¼‰ã§ãªã„å ´åˆã®å‡¦ç†
                if not isinstance(item, str):
                    logger.error(f"é¦¬åãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(item)}, value={item}")
                    continue
                    
                horse_name = item
                horse_data = self.data_manager.get_horse_data(horse_name)
                
                # horse_dataã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
                if not isinstance(horse_data, dict):
                    logger.error(f"é¦¬ {horse_name} ã®ãƒ‡ãƒ¼ã‚¿ãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(horse_data)}, value={horse_data}")
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'fukusho_count': 0,
                        'fukusho_rate': 0.0,
                        'status': 'invalid_data_type'
                    })
                    continue
                
                if not horse_data or 'races' not in horse_data:
                    logger.debug(f"é¦¬ãƒ‡ãƒ¼ã‚¿ãªã—: {horse_name}")
                    # ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯è¨˜éŒ²ã—ã¦ãŠã
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'fukusho_count': 0,
                        'fukusho_rate': 0.0,
                        'status': 'no_data'
                    })
                    continue
                
                # è©²å½“ã‚³ãƒ¼ã‚¹ã®ãƒ¬ãƒ¼ã‚¹ã‚’é›†è¨ˆ
                course_runs = 0
                course_fukusho = 0
                
                races_data = horse_data.get('races', [])
                # racesãŒæ­£ã—ã„å½¢å¼ã‹ãƒã‚§ãƒƒã‚¯
                if not isinstance(races_data, list):
                    logger.error(f"é¦¬ {horse_name} ã®racesãƒ‡ãƒ¼ã‚¿ãŒé…åˆ—ã§ã¯ãªã„: {type(races_data)}")
                    continue
                    
                for race in races_data:
                    # raceãŒè¾æ›¸ã‹ãƒã‚§ãƒƒã‚¯
                    if not isinstance(race, dict):
                        logger.error(f"é¦¬ {horse_name} ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ãŒè¾æ›¸ã§ã¯ãªã„: {type(race)} = {race}")
                        continue
                        
                    # é–‹å‚¬å ´ãƒã‚§ãƒƒã‚¯
                    if race.get('KEIBAJO_CODE') != venue_code:
                        continue
                    
                    # è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆÂ±100mè¨±å®¹ï¼‰
                    if distance:
                        race_distance = race.get('KYORI')
                        if race_distance:
                            try:
                                if abs(int(race_distance) - distance) > 100:
                                    continue
                            except (ValueError, TypeError):
                                continue
                    
                    # ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼šãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ã‹ã‚‰æ¨å®šï¼‰
                    track_code = race.get('TRACK_CODE', '')
                    if track_code:
                        try:
                            track_code_num = int(track_code)
                            # 11-19: èŠ, 21-29: ãƒ€ãƒ¼ãƒˆ
                            if track_type == 'èŠ' and not (11 <= track_code_num <= 19):
                                continue
                            if track_type == 'ãƒ€ãƒ¼ãƒˆ' and not (21 <= track_code_num <= 29):
                                continue
                        except (ValueError, TypeError):
                            pass
                    
                    course_runs += 1
                    
                    # è¤‡å‹åˆ¤å®šï¼ˆ3ç€ä»¥å†…ï¼‰
                    finish = race.get('KAKUTEI_CHAKUJUN')
                    if finish is not None:
                        try:
                            if int(finish) <= 3:
                                course_fukusho += 1
                        except (ValueError, TypeError):
                            pass
                
                # æˆç¸¾ã‚’ã¾ã¨ã‚ã‚‹
                if course_runs > 0:
                    fukusho_rate = (course_fukusho / course_runs) * 100  # ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆå½¢å¼ã«å¤‰æ›
                    logger.info(f"é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ã‚ã‚Š: {horse_name}, {course_runs}æˆ¦, è¤‡å‹ç‡{fukusho_rate:.1f}%")
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': course_runs,
                        'fukusho_count': course_fukusho,
                        'fukusho_rate': fukusho_rate,  # %å½¢å¼ã§ä¿å­˜
                        'status': 'found'
                    })
                else:
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'fukusho_count': 0,
                        'fukusho_rate': 0.0,
                        'status': 'no_course_data'
                    })
            
            # è¤‡å‹ç‡é †ã«ã‚½ãƒ¼ãƒˆ
            horse_performances.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            logger.info(f"é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æå®Œäº†: {len(horse_performances)}é ­, course={course_key}")
            return horse_performances
            
        except Exception as e:
            logger.error(f"é¦¬ã®ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _analyze_jockeys_post_performance(self, jockeys: List[str], posts: List[int] = None) -> Dict[str, Dict]:
        """
        2. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡ã‚’åˆ†æï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
        
        Args:
            jockeys: é¨æ‰‹åãƒªã‚¹ãƒˆ
            posts: æ ç•ªãƒªã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            
        Returns:
            é¨æ‰‹åˆ¥æ é †æˆç¸¾è¾æ›¸
        """
        jockey_post_performances = {}
        
        # jockeysãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
        logger.info(f"_analyze_jockeys_post_performance called with jockeys type: {type(jockeys)}, posts type: {type(posts)}")
        if not isinstance(jockeys, list):
            logger.error(f"jockeys ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockeys)}, value={jockeys}")
            return {}
        
        # postsãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆNoneã§ãªã„å ´åˆï¼‰
        if posts is not None and not isinstance(posts, list):
            logger.error(f"posts ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(posts)}, value={posts}")
            return {}
        
        # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
        if not jockeys:
            logger.warning("é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™")
            return {}
        
        # å„è¦ç´ ã®å‹ãƒã‚§ãƒƒã‚¯ã¨Noneå€¤ã‚„empty stringã‚’é™¤å¤–
        valid_jockeys = []
        for i, item in enumerate(jockeys):
            if not isinstance(item, str):
                logger.error(f"é¨æ‰‹å[{i}]ãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(item)}, value={item}")
                continue
            if item and item.strip():
                valid_jockeys.append(item)
            else:
                logger.warning(f"é¨æ‰‹å[{i}]ãŒç©ºæ–‡å­—åˆ—ã§ã™")
        
        if not valid_jockeys:
            logger.warning(f"æœ‰åŠ¹ãªé¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“: {jockeys}")
            return {}
        
        if not self.jockey_manager.is_loaded():
            logger.warning("é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“")
            return {}
        
        try:
            # postsã®è¦ç´ ã‚‚ãƒã‚§ãƒƒã‚¯ï¼ˆæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
            valid_posts = None
            if posts is not None:
                valid_posts = []
                for i, post in enumerate(posts):
                    if not isinstance(post, (int, float)):
                        logger.error(f"æ ç•ª[{i}]ãŒæ•°å€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(post)}, value={post}")
                        # ä¸æ­£ãªå€¤ã¯0ã¨ã—ã¦æ‰±ã†
                        valid_posts.append(0)
                    else:
                        # floatã®å ´åˆã¯intã«å¤‰æ›
                        valid_posts.append(int(post))
                logger.info(f"æ¤œè¨¼å¾Œã®æ ç•ªãƒªã‚¹ãƒˆ: {valid_posts}")
            
            # é¨æ‰‹åã‚’æ­£è¦åŒ–ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã«åˆã‚ã›ã‚‹ï¼‰
            normalized_jockeys = []
            logger.info(f"å‚¾å‘åˆ†æã«ä½¿ç”¨ã™ã‚‹é¨æ‰‹åï¼ˆå…ƒãƒ‡ãƒ¼ã‚¿ï¼‰: {valid_jockeys}")
            for jockey in valid_jockeys:
                jockey_normalized = self._normalize_jockey_name(jockey)
                normalized_jockeys.append(jockey_normalized)
            
            logger.info(f"æ­£è¦åŒ–å¾Œã®é¨æ‰‹å: {normalized_jockeys}")
            
            # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‹ã‚‰æ é †åˆ¥è¤‡å‹ç‡ã‚’å–å¾—
            jockey_post_stats = self.jockey_manager.get_jockey_post_position_fukusho_rates(normalized_jockeys)
            
            # jockey_post_statsã®å‹ãƒã‚§ãƒƒã‚¯
            if not isinstance(jockey_post_stats, dict):
                logger.error(f"jockey_post_statsãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockey_post_stats)}, value={jockey_post_stats}")
                return {}
            
            # å…ƒã®é¨æ‰‹åã‚’ã‚­ãƒ¼ã¨ã—ã¦è¿”ã™ï¼ˆæ ç•ªæƒ…å ±ã‚‚å«ã‚€ï¼‰
            for i, original_jockey in enumerate(valid_jockeys):
                if i < len(normalized_jockeys):
                    normalized = normalized_jockeys[i]
                    result_data = {}
                    
                    # æ ç•ªãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®æ ç•ªã§ã®æˆç¸¾ã‚’å–å¾—
                    if valid_posts and i < len(valid_posts):
                        post_num = valid_posts[i]
                        # æ ç•ªã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚’åˆ¤å®š
                        if post_num <= 6:
                            category = 'å†…æ ï¼ˆ1-6ï¼‰'
                        elif post_num <= 12:
                            category = 'ä¸­æ ï¼ˆ7-12ï¼‰'
                        else:
                            category = 'å¤–æ ï¼ˆ13-18ï¼‰'
                        
                        result_data['assigned_post'] = post_num
                        result_data['post_category'] = category
                    
                    if normalized in jockey_post_stats:
                        # jockey_post_stats[normalized]ã®å‹ãƒã‚§ãƒƒã‚¯
                        jockey_stats = jockey_post_stats[normalized]
                        if not isinstance(jockey_stats, dict):
                            logger.error(f"é¨æ‰‹ {normalized} ã®post_statsãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockey_stats)}, value={jockey_stats}")
                            result_data['all_post_stats'] = {
                                'å†…æ ï¼ˆ1-6ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'error'},
                                'ä¸­æ ï¼ˆ7-12ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'error'},
                                'å¤–æ ï¼ˆ13-18ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'error'}
                            }
                        else:
                            # å…¨æ é †ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
                            result_data['all_post_stats'] = jockey_stats
                            
                            # è©²å½“æ ç•ªã§ã®æˆç¸¾ã‚’ç‰¹åˆ¥ã«æŠ½å‡º
                            if 'post_category' in result_data:
                                category = result_data['post_category']
                                if category in jockey_stats:
                                    category_stats = jockey_stats[category]
                                    # category_statsã®å‹ãƒã‚§ãƒƒã‚¯
                                    if not isinstance(category_stats, dict):
                                        logger.error(f"é¨æ‰‹ {normalized} ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ {category} ãƒ‡ãƒ¼ã‚¿ãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(category_stats)}")
                                    else:
                                        result_data['assigned_post_stats'] = category_stats
                    else:
                        # ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆ
                        result_data['all_post_stats'] = {
                            'å†…æ ï¼ˆ1-6ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'no_data'},
                            'ä¸­æ ï¼ˆ7-12ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'no_data'},
                            'å¤–æ ï¼ˆ13-18ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'no_data'}
                        }
                        
                    jockey_post_performances[original_jockey] = result_data
            
            logger.info(f"é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾åˆ†æå®Œäº†: {len(jockey_post_performances)}å")
            return jockey_post_performances
            
        except Exception as e:
            logger.error(f"é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _analyze_jockeys_course_performance(self, jockeys: List[str], venue: str, distance: int, track_type: str) -> List[Dict]:
        """
        3. é¨æ‰‹ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡ã‚’åˆ†æ
        é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´æ¥ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        
        Args:
            jockeys: é¨æ‰‹åãƒªã‚¹ãƒˆ
            venue: é–‹å‚¬å ´
            distance: è·é›¢
            track_type: ã‚³ãƒ¼ã‚¹ç¨®åˆ¥
            
        Returns:
            é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ãƒªã‚¹ãƒˆ
        """
        jockey_course_performances = []
        # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚­ãƒ¼å½¢å¼ï¼ˆç«¶é¦¬å ´_è·é›¢ï¼‰
        course_key = f"{venue}_{distance}"
        
        # jockeysãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
        logger.info(f"_analyze_jockeys_course_performance called with jockeys type: {type(jockeys)}")
        if not isinstance(jockeys, list):
            logger.error(f"jockeys ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾ï¼‰: type={type(jockeys)}, value={jockeys}")
            return []
        
        # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
        if not jockeys:
            logger.warning("é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æï¼‰")
            return []
        
        # å„è¦ç´ ã®å‹ãƒã‚§ãƒƒã‚¯ã¨Noneå€¤ã‚„empty stringã‚’é™¤å¤–
        valid_jockeys = []
        for i, item in enumerate(jockeys):
            if not isinstance(item, str):
                logger.error(f"é¨æ‰‹å[{i}]ãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾ï¼‰: type={type(item)}, value={item}")
                continue
            if item and item.strip():
                valid_jockeys.append(item)
            else:
                logger.warning(f"é¨æ‰‹å[{i}]ãŒç©ºæ–‡å­—åˆ—ã§ã™ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾ï¼‰")
        
        if not valid_jockeys:
            logger.warning(f"æœ‰åŠ¹ãªé¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æï¼‰: {jockeys}")
            return []
        
        # é¨æ‰‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ç¢ºèª
        if not self.jockey_manager or not self.jockey_manager.is_loaded():
            logger.warning("é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“")
            return []
        
        try:
            # å„é¨æ‰‹ã«ã¤ã„ã¦ã€é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©²å½“ã‚³ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            for jockey_name in valid_jockeys:
                # é¨æ‰‹åã‚’æ­£è¦åŒ–
                normalized_name = self._normalize_jockey_name(jockey_name)
                
                # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆè¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œï¼‰
                jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
                
                # è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ä»–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚è©¦ã™
                if not jockey_data:
                    # ãƒ‘ã‚¿ãƒ¼ãƒ³1: å…¥åŠ›åãã®ã¾ã¾
                    jockey_data = self.jockey_manager.get_jockey_data(jockey_name)
                    
                    # ãƒ‘ã‚¿ãƒ¼ãƒ³2: å‰å¾Œã®ç©ºç™½ã‚’é™¤å»ï¼ˆå…¨è§’ç©ºç™½å«ã‚€ï¼‰
                    if not jockey_data:
                        clean_name = jockey_name.strip().strip('ã€€')
                        jockey_data = self.jockey_manager.get_jockey_data(clean_name)
                    
                    # ãƒ‘ã‚¿ãƒ¼ãƒ³3: æœ«å°¾ã«å…¨è§’ç©ºç™½ã‚’è¿½åŠ ï¼ˆçŸ³æ©‹è„©å¯¾å¿œï¼‰
                    if not jockey_data:
                        jockey_data = self.jockey_manager.get_jockey_data(clean_name + 'ã€€')
                    
                    # ãƒ‘ã‚¿ãƒ¼ãƒ³4: å¤–å›½äººé¨æ‰‹ã®ç‰¹æ®Šå¯¾å¿œ
                    if not jockey_data and clean_name == 'ãƒ«ãƒ¡ãƒ¼ãƒ«':
                        # ï¼£ï¼ã‚’ä»˜ã‘ãšã«è©¦ã™
                        jockey_data = self.jockey_manager.get_jockey_data('ãƒ«ãƒ¡ãƒ¼ãƒ«')
                
                if not jockey_data:
                    # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
                    logger.info(f"é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {jockey_name}")
                    jockey_course_performances.append({
                        'jockey_name': jockey_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'wins': 0,
                        'fukusho_count': 0,
                        'win_rate': 0.0,
                        'fukusho_rate': 0.0,
                        'status': 'no_jockey_data'
                    })
                    continue
                
                # venue_course_statsã‹ã‚‰è©²å½“ã‚³ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ¢ã™
                venue_course_stats = jockey_data.get('venue_course_stats', {})
                
                # è©²å½“ã‚³ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                course_stats = None
                
                # å®Œå…¨ä¸€è‡´ã‚’è©¦ã¿ã‚‹
                if course_key in venue_course_stats:
                    course_stats = venue_course_stats[course_key]
                else:
                    # èŠ/ãƒ€ãƒ¼ãƒˆã‚’å«ã‚€ã‚­ãƒ¼ã‚‚è©¦ã™ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
                    alt_keys = [
                        f"{venue}_{distance}m",
                        f"{venue}_{distance}{track_type}",
                        f"{venue}_{distance}m{track_type}"
                    ]
                    
                    for key in alt_keys:
                        if key in venue_course_stats:
                            course_stats = venue_course_stats[key]
                            break
                
                # ã‚³ãƒ¼ã‚¹æˆç¸¾ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆ
                if course_stats:
                    total_runs = course_stats.get('race_count', 0)
                    fukusho_rate = course_stats.get('fukusho_rate', 0)
                    
                    # resultsã‹ã‚‰å‹åˆ©æ•°ã¨è¤‡å‹æ•°ã‚’è¨ˆç®—
                    wins = 0
                    fukusho = 0
                    results = course_stats.get('results', [])
                    for result in results:
                        position = result.get('position', 99)
                        if position == 1:
                            wins += 1
                        if position <= 3:
                            fukusho += 1
                    
                    # æˆç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
                    jockey_course_performances.append({
                        'jockey_name': jockey_name,
                        'course_key': course_key,
                        'total_runs': total_runs,
                        'wins': wins,
                        'fukusho_count': fukusho,
                        'win_rate': (wins / total_runs * 100) if total_runs > 0 else 0.0,
                        'fukusho_rate': fukusho_rate,  # æ—¢ã«%å½¢å¼
                        'status': 'found'
                    })
                else:
                    # è©²å½“ã‚³ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆ
                    logger.info(f"é¨æ‰‹ {jockey_name} ã® {course_key} ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    jockey_course_performances.append({
                        'jockey_name': jockey_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'wins': 0,
                        'fukusho_count': 0,
                        'win_rate': 0.0,
                        'fukusho_rate': 0.0,
                        'status': 'no_course_data'
                    })
            
            # è¤‡å‹ç‡é †ã«ã‚½ãƒ¼ãƒˆ
            jockey_course_performances.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            logger.info(f"é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æå®Œäº†: {len(jockey_course_performances)}å, course={course_key}")
            return jockey_course_performances
            
        except Exception as e:
            logger.error(f"é¨æ‰‹ã®ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _analyze_course_bloodline_performance(self, venue: str, distance: int, track_type: str) -> List[Dict]:
        """
        4. é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã®è¡€çµ±æˆç¸¾ä¸Šä½é †ã‚’åˆ†æ
        
        Args:
            venue: é–‹å‚¬å ´
            distance: è·é›¢
            track_type: ã‚³ãƒ¼ã‚¹ç¨®åˆ¥
            
        Returns:
            è¡€çµ±æˆç¸¾ä¸Šä½é †ãƒªã‚¹ãƒˆ
        """
        bloodline_performances = {}
        course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
        
        # é–‹å‚¬å ´ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
        venue_codes = {
            'æœ­å¹Œ': '01', 'å‡½é¤¨': '02', 'ç¦å³¶': '03', 'æ–°æ½Ÿ': '04',
            'æ±äº¬': '05', 'ä¸­å±±': '06', 'ä¸­äº¬': '07', 'äº¬éƒ½': '08',
            'é˜ªç¥': '09', 'å°å€‰': '10'
        }
        venue_code = venue_codes.get(venue, '')
        
        try:
            # å…¨é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’èµ°æŸ»ã—ã¦è¡€çµ±åˆ¥æˆç¸¾ã‚’é›†è¨ˆ
            # æ³¨ï¼šç¾åœ¨ã®ViewLogicãƒŠãƒ¬ãƒƒã‚¸ã«ã¯è¡€çµ±æƒ…å ±ãŒãªã„ãŸã‚ã€ä»£æ›¿æ¡ˆã¨ã—ã¦é¨æ‰‹çµ±è¨ˆã‚’ä½¿ç”¨
            # å°†æ¥çš„ã«è¡€çµ±ãƒ‡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚ŒãŸã‚‰ä¿®æ­£ã™ã‚‹
            
            logger.warning("è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã¯ç¾åœ¨ã®ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“")
            
            # æš«å®šçš„ã«ç©ºãƒªã‚¹ãƒˆã‚’è¿”ã™
            return []
            
        except Exception as e:
            logger.error(f"è¡€çµ±æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return []


    
    def _generate_trend_insights_from_real_data(self, horse_course_stats: List[Dict], jockey_post_stats: Dict, 
                                               jockey_course_stats: List[Dict]) -> List[str]:
        """
        å®Ÿãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå‚¾å‘åˆ†æã®ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            horse_course_stats: é¦¬ã®ã‚³ãƒ¼ã‚¹æˆç¸¾
            jockey_post_stats: é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾
            jockey_course_stats: é¨æ‰‹ã®ã‚³ãƒ¼ã‚¹æˆç¸¾  
            bloodline_stats: è¡€çµ±æˆç¸¾
            
        Returns:
            ã‚¤ãƒ³ã‚µã‚¤ãƒˆæ–‡è¨€ãƒªã‚¹ãƒˆ
        """
        insights = []
        
        try:
            # 1. é¦¬ã®ã‚³ãƒ¼ã‚¹é©æ€§ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
            strong_horses = [h for h in horse_course_stats if h['fukusho_rate'] > 50 and h['total_runs'] >= 3]
            if strong_horses:
                top_horse = strong_horses[0]
                insights.append(f"{top_horse['horse_name']}ã¯å½“ã‚³ãƒ¼ã‚¹ã§è¤‡å‹ç‡{top_horse['fukusho_rate']:.1f}%ã¨é«˜é©æ€§")
            
            # 2. é¨æ‰‹ã®æ é †å‚¾å‘ã‚¤ãƒ³ã‚µã‚¤ãƒˆ  
            if jockey_post_stats:
                # å†…æ ãƒ»ä¸­æ ãƒ»å¤–æ ã®å¹³å‡è¤‡å‹ç‡ã‚’è¨ˆç®—
                position_averages = {'å†…æ ï¼ˆ1-6ï¼‰': 0, 'ä¸­æ ï¼ˆ7-12ï¼‰': 0, 'å¤–æ ï¼ˆ13-18ï¼‰': 0}
                position_counts = {'å†…æ ï¼ˆ1-6ï¼‰': 0, 'ä¸­æ ï¼ˆ7-12ï¼‰': 0, 'å¤–æ ï¼ˆ13-18ï¼‰': 0}
                
                for jockey_name, post_data in jockey_post_stats.items():
                    # æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾å¿œ
                    if 'assigned_post_stats' in post_data:
                        # å€‹åˆ¥ã®é¨æ‰‹ã®è©²å½“æ ã§ã®æˆç¸¾
                        category = post_data.get('post_category')
                        stats = post_data['assigned_post_stats']
                        if category and stats.get('race_count', 0) > 0:
                            position_averages[category] += stats['fukusho_rate']
                            position_counts[category] += 1
                    elif 'all_post_stats' in post_data:
                        # å…¨æ é †ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                        for position, stats in post_data['all_post_stats'].items():
                            if stats.get('race_count', 0) > 0:
                                position_averages[position] += stats['fukusho_rate']
                                position_counts[position] += 1
                
                for position in position_averages:
                    if position_counts[position] > 0:
                        position_averages[position] /= position_counts[position]
                
                # æœ€ã‚‚æœ‰åˆ©ãªæ é †ã‚’åˆ¤å®š
                best_position = max(position_averages.items(), key=lambda x: x[1])
                if best_position[1] > 40:  # 40%ä»¥ä¸Š
                    insights.append(f"æ é †ã¯{best_position[0]}ãŒè¤‡å‹ç‡{best_position[1]:.1f}%ã§æœ‰åˆ©")
            
            # 3. é¨æ‰‹ã®ã‚³ãƒ¼ã‚¹é©æ€§ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
            strong_jockeys = [j for j in jockey_course_stats if j['fukusho_rate'] > 40 and j['total_runs'] >= 5]
            if strong_jockeys:
                top_jockey = strong_jockeys[0]
                insights.append(f"{top_jockey['jockey_name']}ã¯å½“ã‚³ãƒ¼ã‚¹ã§è¤‡å‹ç‡{top_jockey['fukusho_rate']:.1f}%ã®å¥½æˆç¸¾")
            
            return insights[:3]  # æœ€å¤§3ã¤ã®ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
            
        except Exception as e:
            logger.error(f"å‚¾å‘ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return ["å®Ÿãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå‚¾å‘åˆ†æã‚’å®Ÿæ–½"]
    
    def get_horse_history(self, horse_name: str) -> Dict[str, Any]:
        """
        é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ–°æ©Ÿèƒ½ï¼‰
        ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
        
        Args:
            horse_name: é¦¬å
            
        Returns:
            {
                'status': 'success' or 'error',
                'horse_name': str,
                'races': List[Dict],  # ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿
                'running_style': Dict,  # è„šè³ªæƒ…å ±
                'message': str
            }
        """
        try:
            # ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¦¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            horse_data = self.data_manager.get_horse_data(horse_name)
            
            if not horse_data:
                return {
                    'status': 'error',
                    'message': f'{horse_name}ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'
                }
            
            # ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            races = horse_data.get('races', [])
            recent_races = races[:5] if len(races) >= 5 else races
            
            # å„ãƒ¬ãƒ¼ã‚¹ã®é‡è¦ãƒ‡ãƒ¼ã‚¿ã®ã¿æŠ½å‡ºï¼ˆãƒ¢ãƒã‚¤ãƒ«å‘ã‘ç°¡ç•¥åŒ–ï¼‰
            formatted_races = []
            for race in recent_races:
                # ãƒ¬ãƒ¼ã‚¹åã®å–å¾—ï¼ˆKYOSOMEI_HONDAIãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰ï¼‰
                race_name = race.get('KYOSOMEI_HONDAI', '').strip()
                if not race_name:
                    race_name = f"{race.get('RACE_BANGO', '')}R"
                
                # ã‚¯ãƒ©ã‚¹åã®å–å¾—ï¼ˆGRADE_CODEã‹ã‚‰å¤‰æ›ï¼‰
                grade_code = race.get('GRADE_CODE', '')
                class_name = self._get_grade_name(grade_code) if grade_code else ''
                
                # è¡€çµ±æƒ…å ±ã®å–å¾—
                sire = race.get('sire', '')
                broodmare_sire = race.get('broodmare_sire', '')
                
                formatted_race = {
                    'é–‹å‚¬æ—¥': f"{race.get('KAISAI_NEN', '')}/{race.get('KAISAI_GAPPI', '')}",
                    'ç«¶é¦¬å ´': self._get_venue_name(race.get('KEIBAJO_CODE', '')),
                    'ãƒ¬ãƒ¼ã‚¹': race_name,  # ãƒ¬ãƒ¼ã‚¹åã‚’ä½¿ç”¨
                    'ã‚¯ãƒ©ã‚¹': class_name,  # ã‚¯ãƒ©ã‚¹åã‚’è¿½åŠ 
                    'ç€é †': f"{race.get('KAKUTEI_CHAKUJUN', '')}ç€",
                    'ã‚¿ã‚¤ãƒ ': race.get('SOHA_TIME', ''),
                    'ä¸Šã‚Š': f"{race.get('KOHAN_3F', '')}ç§’",
                    'äººæ°—': f"{race.get('TANSHO_NINKIJUN', '')}ç•ªäººæ°—",
                    'é¨æ‰‹': race.get('KISHUMEI_RYAKUSHO', ''),
                    'è·é›¢': f"{race.get('KYORI', '')}m",
                    'é¦¬å ´': self._get_track_condition(race.get('BABA_JOTAI', '')),
                    'é ­æ•°': f"{race.get('TOSU', '')}é ­",
                    'é¦¬ä½“é‡': race.get('BATAIJU', ''),
                    'ã‚³ãƒ¼ãƒŠãƒ¼': f"{race.get('CORNER1_JUNI', '')}-{race.get('CORNER2_JUNI', '')}-{race.get('CORNER3_JUNI', '')}-{race.get('CORNER4_JUNI', '')}",
                    'çˆ¶': sire if sire else 'ä¸æ˜',  # è¡€çµ±æƒ…å ±ã‚’è¿½åŠ 
                    'æ¯çˆ¶': broodmare_sire if broodmare_sire else 'ä¸æ˜'  # è¡€çµ±æƒ…å ±ã‚’è¿½åŠ 
                }
                formatted_races.append(formatted_race)
            
            return {
                'status': 'success',
                'horse_name': horse_name,
                'races': formatted_races,
                'running_style': horse_data.get('running_style', {}),
                'total_races': horse_data.get('total_races', len(races)),
                'message': f'{horse_name}ã®ç›´è¿‘{len(formatted_races)}èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸ'
            }
            
        except Exception as e:
            logger.error(f"é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'status': 'error',
                'message': f'ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def get_jockey_history(self, jockey_name: str) -> Dict[str, Any]:
        """
        é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ–°æ©Ÿèƒ½ï¼‰
        é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
        
        Args:
            jockey_name: é¨æ‰‹å
            
        Returns:
            {
                'status': 'success' or 'error',
                'jockey_name': str,
                'recent_rides': List[Dict],  # ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿
                'statistics': Dict,  # çµ±è¨ˆæƒ…å ±
                'message': str
            }
        """
        try:
            # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            if not self.jockey_manager.is_loaded():
                return {
                    'status': 'error',
                    'message': 'é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            # é¨æ‰‹åã‚’æ­£è¦åŒ–ï¼ˆå‹•çš„æ¤œç´¢ï¼‹é™çš„ãƒãƒƒãƒ”ãƒ³ã‚°ï¼‰
            normalized_name = self._normalize_jockey_name(jockey_name)
            jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
            
            # è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ä»–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚è©¦ã™
            if not jockey_data:
                # ãƒ‘ã‚¿ãƒ¼ãƒ³1: å…¥åŠ›åãã®ã¾ã¾
                jockey_data = self.jockey_manager.get_jockey_data(jockey_name)
                
                # ãƒ‘ã‚¿ãƒ¼ãƒ³2: å‰å¾Œã®ç©ºç™½ã‚’é™¤å»ï¼ˆå…¨è§’ç©ºç™½å«ã‚€ï¼‰
                if not jockey_data:
                    clean_name = jockey_name.strip().strip('ã€€')
                    jockey_data = self.jockey_manager.get_jockey_data(clean_name)
                
                # ãƒ‘ã‚¿ãƒ¼ãƒ³3: æœ«å°¾ã«å…¨è§’ç©ºç™½ã‚’è¿½åŠ 
                if not jockey_data:
                    jockey_data = self.jockey_manager.get_jockey_data(clean_name + 'ã€€')
                
                # ãƒ‘ã‚¿ãƒ¼ãƒ³4: éƒ¨åˆ†ä¸€è‡´æ¤œç´¢ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å…¨é¨æ‰‹åã‹ã‚‰æ¤œç´¢ï¼‰
                if not jockey_data and hasattr(self.jockey_manager, 'jockey_data'):
                    for full_name in self.jockey_manager.jockey_data.keys():
                        if clean_name in full_name:
                            jockey_data = self.jockey_manager.jockey_data[full_name]
                            break
            
            if not jockey_data:
                return {
                    'status': 'error',
                    'message': f'{jockey_name}é¨æ‰‹ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'
                }
            
            # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ€è¿‘ã®æˆç¸¾ã‚’æ§‹ç¯‰
            recent_rides = []
            
            # venue_course_statsã‹ã‚‰ç›´è¿‘ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆä¸Šä½5ä»¶ï¼‰
            if 'venue_course_stats' in jockey_data:
                count = 0
                for venue_distance, stats in jockey_data['venue_course_stats'].items():
                    if count >= 5:
                        break
                    
                    # venue_distanceã‚’åˆ†è§£ï¼ˆä¾‹: "ä¸­å±±_2500m" -> "ä¸­å±±", "2500m"ï¼‰
                    if '_' in venue_distance:
                        parts = venue_distance.split('_')
                        venue = parts[0]
                        distance = parts[1] if len(parts) > 1 else 'ä¸æ˜'
                    else:
                        venue = 'ä¸æ˜'
                        distance = venue_distance
                    
                    # å‡ºèµ°æ•°ã‚’å–å¾—ï¼ˆrace_countãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ï¼‰
                    race_count = stats.get('race_count', 0)
                    
                    # è¤‡å‹ç‡ã®å–å¾—ã¨è¡¨ç¤ºå½¢å¼ã®èª¿æ•´
                    fukusho_rate = stats.get('fukusho_rate', 0)
                    fukusho_rate_display = f"{fukusho_rate:.1f}%" if fukusho_rate > 1 else f"{fukusho_rate*100:.1f}%"
                    
                    recent_ride = {
                        'ç«¶é¦¬å ´': venue,
                        'è·é›¢': distance,
                        'å‡ºèµ°æ•°': race_count,
                        'è¤‡å‹ç‡': fukusho_rate_display
                    }
                    recent_rides.append(recent_ride)
                    count += 1
            
            # å…¨ä½“çµ±è¨ˆï¼ˆè¤‡å‹ç‡ã®æ­£è¦åŒ–ï¼‰
            overall_fukusho_rate = jockey_data.get('overall_stats', {}).get('overall_fukusho_rate', 0)
            overall_rate_display = f"{overall_fukusho_rate:.1f}%" if overall_fukusho_rate > 1 else f"{overall_fukusho_rate*100:.1f}%"
            
            statistics = {
                'ç·å‡ºèµ°æ•°': jockey_data.get('overall_stats', {}).get('total_races_analyzed', 0),
                'ç·åˆè¤‡å‹ç‡': overall_rate_display
            }
            
            # é¦¬å ´çŠ¶æ…‹åˆ¥æˆç¸¾ï¼ˆã€Œä¸æ˜(æ•°å­—)ã€å½¢å¼ã®ã‚­ãƒ¼ã‚’å‡¦ç†ï¼‰
            if 'track_condition_stats' in jockey_data:
                track_stats = []
                for condition, stats in jockey_data['track_condition_stats'].items():
                    # ã€Œä¸æ˜(17)ã€ã®ã‚ˆã†ãªå½¢å¼ã‹ã‚‰æ•°å­—ã‚’æŠ½å‡º
                    if '(' in condition and ')' in condition:
                        # æ‹¬å¼§å†…ã®æ•°å­—ã‚’å–å¾—
                        code = condition.split('(')[1].split(')')[0]
                        track_name = self._get_track_condition_from_code(code)
                    else:
                        track_name = self._get_track_condition(condition)
                    
                    fukusho_rate = stats.get('fukusho_rate', 0)
                    rate_display = f"{fukusho_rate:.1f}%" if fukusho_rate > 1 else f"{fukusho_rate*100:.1f}%"
                    track_stats.append({
                        'é¦¬å ´': track_name,
                        'è¤‡å‹ç‡': rate_display
                    })
                statistics['é¦¬å ´åˆ¥æˆç¸¾'] = track_stats
            
            # æ é †åˆ¥æˆç¸¾ï¼ˆã€Œæ 4ã€ã®ã‚ˆã†ãªå½¢å¼ã‚’å‡¦ç†ï¼‰
            if 'post_position_stats' in jockey_data:
                post_stats = []
                for position, stats in jockey_data['post_position_stats'].items():
                    # ã€Œæ 4ã€ã‹ã‚‰æ•°å­—ã ã‘ã‚’æŠ½å‡º
                    if 'æ ' in position:
                        position_num = position.replace('æ ', '')
                        display_position = f"{position_num}æ "
                    else:
                        display_position = position
                    
                    fukusho_rate = stats.get('fukusho_rate', 0)
                    rate_display = f"{fukusho_rate:.1f}%" if fukusho_rate > 1 else f"{fukusho_rate*100:.1f}%"
                    post_stats.append({
                        'æ ': display_position,
                        'è¤‡å‹ç‡': rate_display
                    })
                statistics['æ é †åˆ¥æˆç¸¾'] = post_stats
            
            return {
                'status': 'success',
                'jockey_name': jockey_name,
                'recent_rides': recent_rides,
                'statistics': statistics,
                'message': f'{jockey_name}é¨æ‰‹ã®æˆç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸ'
            }
            
        except Exception as e:
            logger.error(f"é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'status': 'error',
                'message': f'é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def _get_track_condition_from_code(self, code: str) -> str:
        """é¦¬å ´çŠ¶æ…‹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åç§°ã‚’å–å¾—ï¼ˆJVDataã‚³ãƒ¼ãƒ‰å¯¾å¿œï¼‰"""
        # JVDataã®ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ï¼ˆæ å†…ã®ä½ç½®æƒ…å ±ã¨ã—ã¦èª¤ç”¨ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ï¼‰
        track_codes = {
            '10': 'å¹³åœ°ãƒ»èŠ', '11': 'å¹³åœ°ãƒ»ãƒ€ãƒ¼ãƒˆ', '12': 'å¹³åœ°ãƒ»èŠãƒ€ãƒ¼ãƒˆ',
            '17': 'å¹³åœ°ãƒ»èŠ', '18': 'å¹³åœ°ãƒ»ãƒ€ãƒ¼ãƒˆ', '19': 'å¹³åœ°ãƒ»èŠå¤–',
            '20': 'å¹³åœ°ãƒ»ç›´ç·šèŠ', '21': 'å¹³åœ°ãƒ»ç›´ç·šãƒ€ãƒ¼ãƒˆ',
            '22': 'å¹³åœ°ãƒ»èŠå¤–â†’å†…', '23': 'å¹³åœ°ãƒ»èŠå†…â†’å¤–', '24': 'å¹³åœ°ãƒ»èŠå†…2å‘¨',
            '51': 'éšœå®³ãƒ»èŠ', '52': 'éšœå®³ãƒ»ãƒ€ãƒ¼ãƒˆ', '53': 'éšœå®³ãƒ»èŠãƒ€ãƒ¼ãƒˆ',
            '54': 'éšœå®³ãƒ»ç›´ç·š', '55': 'éšœå®³ãƒ»èŠå¤–', '56': 'éšœå®³ãƒ»èŠå¤–â†’å†…',
            '57': 'éšœå®³ãƒ»èŠå†…â†’å¤–', '58': 'éšœå®³ãƒ»èŠå†…2å‘¨', '59': 'éšœå®³ãƒ»èŠå¤–2å‘¨'
        }
        # ã‚‚ã—ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ãªã‚‰ãã‚Œã‚’è¿”ã™
        if code in track_codes:
            return track_codes[code]
        # ãã‚Œä»¥å¤–ã¯é¦¬å ´çŠ¶æ…‹ã¨ã—ã¦æ‰±ã†
        return self._get_track_condition(code)
    
    def _normalize_jockey_name(self, jockey_name: str) -> str:
        """é¨æ‰‹åã‚’æ­£è¦åŒ–ã™ã‚‹"""
        # ã€Œé¨æ‰‹ã€ã‚’å‰Šé™¤ã—ã¦ã‚¹ãƒšãƒ¼ã‚¹ã‚’ãƒˆãƒªãƒ 
        normalized = jockey_name.replace('é¨æ‰‹', '').strip()
        
        # jockey_name_mapper ã‚’ä½¿ç”¨ã—ã¦3æ–‡å­—é¨æ‰‹åã‚’æ­£è¦åŒ–
        from services.jockey_name_mapper import normalize_jockey_name
        normalized = normalize_jockey_name(normalized)
        
        # å¤–å›½äººé¨æ‰‹ã®ç‰¹æ®Šå¯¾å¿œï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã«åˆã‚ã›ã‚‹ï¼‰
        special_mapping = {
            'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«': 'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«',
            'C.ãƒ«ãƒ¡ãƒ¼ãƒ«': 'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«',
            'ãƒ«ãƒ¡ãƒ¼ãƒ«': 'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«',
            'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­': 'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­',
            'M.ãƒ‡ãƒ ãƒ¼ãƒ­': 'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­',
            'ãƒ‡ãƒ ãƒ¼ãƒ­': 'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­'
        }
        
        if normalized in special_mapping:
            return special_mapping[normalized]
        
        return normalized
    
    def _get_grade_name(self, grade_code: str) -> str:
        """ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã‚’åˆ†ã‹ã‚Šã‚„ã™ã„è¡¨è¨˜ã«å¤‰æ›"""
        grade_map = {
            'A': 'G1',
            'B': 'G2', 
            'C': 'G3',
            'D': 'ãƒªã‚¹ãƒ†ãƒƒãƒ‰',
            'E': 'ã‚ªãƒ¼ãƒ—ãƒ³',
            'F': '3å‹',
            'G': '2å‹', 
            'H': '1å‹',
            'I': 'æœªå‹åˆ©',
            'J': 'æ–°é¦¬'
        }
        return grade_map.get(grade_code, '')
    
    def _get_venue_name(self, code: str) -> str:
        """ç«¶é¦¬å ´ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åç§°ã‚’å–å¾—"""
        venue_map = {
            '01': 'æœ­å¹Œ', '02': 'å‡½é¤¨', '03': 'ç¦å³¶', '04': 'æ–°æ½Ÿ',
            '05': 'æ±äº¬', '06': 'ä¸­å±±', '07': 'ä¸­äº¬', '08': 'äº¬éƒ½',
            '09': 'é˜ªç¥', '10': 'å°å€‰'
        }
        return venue_map.get(str(code), 'ä¸æ˜')
    
    def _get_track_condition(self, code: str) -> str:
        """é¦¬å ´çŠ¶æ…‹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åç§°ã‚’å–å¾—"""
        condition_map = {
            '1': 'è‰¯', '2': 'ç¨é‡', '3': 'é‡', '4': 'ä¸è‰¯',
            1: 'è‰¯', 2: 'ç¨é‡', 3: 'é‡', 4: 'ä¸è‰¯'
        }
        return condition_map.get(code, str(code))
