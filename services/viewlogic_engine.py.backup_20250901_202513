"""
ViewLogicå±•é–‹äºˆæƒ³ã‚¨ãƒ³ã‚¸ãƒ³
è„šè³ªåˆ¤å®šã€ãƒšãƒ¼ã‚¹äºˆæ¸¬ã€å±•é–‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œã†
è¨ˆç”»æ›¸é€šã‚Šã®å®Œå…¨å®Ÿè£…ç‰ˆ
"""

import logging
import json
from typing import Dict, List, Optional, Tuple, Any
from statistics import mean, stdev
import math
import hashlib
import time
from datetime import datetime, timedelta
from .jockey_knowledge_manager import get_jockey_knowledge_manager

# numpy import with fallback
try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False
    # Fallback implementations
    class np:
        @staticmethod
        def percentile(data, percentile):
            """Simple percentile calculation without numpy"""
            if not data:
                return 0
            sorted_data = sorted(data)
            index = int(len(sorted_data) * percentile / 100)
            return sorted_data[min(index, len(sorted_data) - 1)]

logger = logging.getLogger(__name__)


class RunningStyleAnalyzer:
    """è„šè³ªåˆ¤å®šã¨3æ®µéšåˆ†é¡ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
    
    def classify_basic_style(self, horse_races: List[Dict]) -> str:
        """åŸºæœ¬4åˆ†é¡ï¼ˆé€ƒã’/å…ˆè¡Œ/å·®ã—/è¿½è¾¼ï¼‰ã‚’åˆ¤å®š"""
        if not horse_races:
            return "ä¸æ˜"
        
        # 1ã‚³ãƒ¼ãƒŠãƒ¼é€šéé †ä½ã®å¹³å‡ã‚’è¨ˆç®—
        corner1_positions = []
        for race in horse_races:
            if 'CORNER1_JUNI' in race and race['CORNER1_JUNI'] > 0:
                corner1_positions.append(race['CORNER1_JUNI'])
        
        if not corner1_positions:
            return "ä¸æ˜"
        
        avg_corner1 = mean(corner1_positions)
        
        if avg_corner1 <= 2.0:
            return "é€ƒã’"
        elif avg_corner1 <= 5.0:
            return "å…ˆè¡Œ"
        elif avg_corner1 <= 9.0:
            return "å·®ã—"
        else:
            return "è¿½è¾¼"
    
    def classify_detailed_style(self, basic_style: str, horse_races: List[Dict]) -> Tuple[str, str]:
        """3æ®µéšè©³ç´°åˆ†é¡ã‚’è¡Œã†"""
        if basic_style == "é€ƒã’":
            return self._classify_escape_details(horse_races)
        elif basic_style == "å…ˆè¡Œ":
            return self._classify_stalker_details(horse_races)
        elif basic_style == "å·®ã—":
            return self._classify_closer_details(horse_races)
        elif basic_style == "è¿½è¾¼":
            return self._classify_latecloser_details(horse_races)
        else:
            return basic_style, "æ¨™æº–"
    
    def _classify_escape_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """é€ƒã’é¦¬ã®è©³ç´°åˆ†é¡"""
        solo_escape_count = 0
        escape_success_count = 0
        escape_races = 0
        
        for race in horse_races:
            corner1 = race.get('CORNER1_JUNI', 99)
            corner2 = race.get('CORNER2_JUNI', 99)
            finish = race.get('KAKUTEI_CHAKUJUN', 99)
            
            # é€ƒã’ãŸå ´åˆ
            if corner1 <= 2:
                escape_races += 1
                
                # å˜ç‹¬é€ƒã’ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ2ã‚³ãƒ¼ãƒŠãƒ¼ã§ã‚‚å…ˆé ­ï¼‰
                if corner2 == 1:
                    solo_escape_count += 1
                
                # é€ƒã’ã¦3ç€ä»¥å†…
                if finish <= 3:
                    escape_success_count += 1
        
        if escape_races == 0:
            return "é€ƒã’", "æ¶ˆæ¥µé€ƒã’"
        
        solo_rate = solo_escape_count / escape_races
        success_rate = escape_success_count / escape_races
        
        if solo_rate > 0.6:
            return "é€ƒã’", "è¶…ç©æ¥µé€ƒã’"
        elif success_rate > 0.5:
            return "é€ƒã’", "çŠ¶æ³é€ƒã’"
        else:
            return "é€ƒã’", "æ¶ˆæ¥µé€ƒã’"
    
    def _classify_stalker_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """å…ˆè¡Œé¦¬ã®è©³ç´°åˆ†é¡"""
        corner1_positions = []
        position_stability = 0
        
        for race in horse_races:
            corner1 = race.get('CORNER1_JUNI', 99)
            if corner1 < 99:
                corner1_positions.append(corner1)
        
        if not corner1_positions:
            return "å…ˆè¡Œ", "æ¨™æº–å…ˆè¡Œ"
        
        avg_corner1 = mean(corner1_positions)
        
        # ä½ç½®å–ã‚Šã®å®‰å®šæ€§ã‚’è¨ˆç®—ï¼ˆæ¨™æº–åå·®ãŒå°ã•ã„ã»ã©å®‰å®šï¼‰
        if len(corner1_positions) > 1:
            position_stability = 1 / (1 + stdev(corner1_positions))
        else:
            position_stability = 0.5
        
        if avg_corner1 <= 3.5 and position_stability > 0.8:
            return "å…ˆè¡Œ", "å‰å¯„ã‚Šå…ˆè¡Œ"
        elif position_stability > 0.7:
            return "å…ˆè¡Œ", "å®‰å®šå…ˆè¡Œ"
        else:
            return "å…ˆè¡Œ", "å¾Œå¯„ã‚Šå…ˆè¡Œ"
    
    def _classify_closer_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """å·®ã—é¦¬ã®è©³ç´°åˆ†é¡"""
        finishing_power_scores = []
        
        for race in horse_races:
            corner4 = race.get('CORNER4_JUNI', 99)
            finish = race.get('KAKUTEI_CHAKUJUN', 99)
            
            if corner4 < 99 and finish < 99:
                # 4ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã‚‰ç€é †ã¸ã®æ”¹å–„åº¦
                improvement = corner4 - finish
                finishing_power_scores.append(improvement)
        
        if not finishing_power_scores:
            return "å·®ã—", "æ¨™æº–å·®ã—"
        
        avg_improvement = mean(finishing_power_scores)
        
        if avg_improvement > 3:
            return "å·®ã—", "å¼·çƒˆå·®ã—"
        elif avg_improvement > 1:
            return "å·®ã—", "ç¢ºå®Ÿå·®ã—"
        else:
            return "å·®ã—", "é…ã‚å·®ã—"
    
    def _classify_latecloser_details(self, horse_races: List[Dict]) -> Tuple[str, str]:
        """è¿½è¾¼é¦¬ã®è©³ç´°åˆ†é¡"""
        extreme_finishes = 0
        total_races = len(horse_races)
        
        for race in horse_races:
            corner4 = race.get('CORNER4_JUNI', 99)
            finish = race.get('KAKUTEI_CHAKUJUN', 99)
            
            if corner4 > 10 and finish <= 3:
                extreme_finishes += 1
        
        if total_races == 0:
            return "è¿½è¾¼", "æ¨™æº–è¿½è¾¼"
        
        extreme_rate = extreme_finishes / total_races
        
        if extreme_rate > 0.3:
            return "è¿½è¾¼", "æ¥µé™è¿½è¾¼"
        elif extreme_rate > 0.1:
            return "è¿½è¾¼", "å¼·åŠ›è¿½è¾¼"
        else:
            return "è¿½è¾¼", "é€šå¸¸è¿½è¾¼"
    
    def calculate_differentiation_score(self, horse_data: Dict, horse_races: List[Dict]) -> float:
        """18é ­åŒä¸€è„šè³ªã®å ´åˆã®å·®åˆ¥åŒ–ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ï¼ˆ100ç‚¹æº€ç‚¹ï¼‰"""
        score_components = {
            'solo_escape': 0,      # å˜ç‹¬é€ƒã’å®Ÿç¸¾ï¼ˆ40%ï¼‰
            'start_dash': 0,       # ã‚¹ã‚¿ãƒ¼ãƒˆãƒ€ãƒƒã‚·ãƒ¥åŠ›ï¼ˆ25%ï¼‰
            'tenacity': 0,         # é€ƒã’ç²˜ã‚Šåº¦ï¼ˆ20%ï¼‰
            'competition': 0,      # ç«¶ã‚Šåˆã„è€æ€§ï¼ˆ10%ï¼‰
            'recent_form': 0       # æœ€è¿‘ã®å‹¢ã„ï¼ˆ5%ï¼‰
        }
        
        # 1. å˜ç‹¬é€ƒã’å®Ÿç¸¾
        solo_count = 0
        total_escapes = 0
        for race in horse_races:
            if race.get('CORNER1_JUNI', 99) <= 2:
                total_escapes += 1
                if race.get('CORNER2_JUNI', 99) == 1:
                    solo_count += 1
        
        if total_escapes > 0:
            score_components['solo_escape'] = (solo_count / total_escapes) * 40
        
        # 2. ã‚¹ã‚¿ãƒ¼ãƒˆãƒ€ãƒƒã‚·ãƒ¥åŠ›ï¼ˆç°¡æ˜“è¨ˆç®—ï¼‰
        corner1_avg = mean([r.get('CORNER1_JUNI', 10) for r in horse_races[:5]])
        score_components['start_dash'] = max(0, (10 - corner1_avg) * 2.5)
        
        # 3. é€ƒã’ç²˜ã‚Šåº¦
        success_count = 0
        escape_count = 0
        for race in horse_races:
            if race.get('CORNER1_JUNI', 99) <= 3:
                escape_count += 1
                if race.get('KAKUTEI_CHAKUJUN', 99) <= 3:
                    success_count += 1
        
        if escape_count > 0:
            score_components['tenacity'] = (success_count / escape_count) * 20
        
        # 4. ç«¶ã‚Šåˆã„è€æ€§ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
        score_components['competition'] = 5  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        
        # 5. æœ€è¿‘ã®å‹¢ã„
        recent_races = horse_races[:3] if len(horse_races) >= 3 else horse_races
        recent_corner1 = [r.get('CORNER1_JUNI', 99) for r in recent_races]
        if recent_corner1:
            recent_avg = mean(recent_corner1)
            if recent_avg <= 3:
                score_components['recent_form'] = 5
        
        # ç·åˆã‚¹ã‚³ã‚¢è¨ˆç®—
        total_score = sum(score_components.values())
        return min(100, total_score)


class BayesianCorrector:
    """ãƒ™ã‚¤ã‚ºè£œæ­£ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
    
    def correct_rate(self, success_count: int, total_count: int, 
                    prior_mean: float = 0.20, prior_weight: float = 5) -> Dict[str, float]:
        """
        ãƒ™ã‚¤ã‚ºè£œæ­£ã§å°‘ãªã„ã‚µãƒ³ãƒ—ãƒ«æ•°ã®å½±éŸ¿ã‚’ç·©å’Œ
        
        Parameters:
        - success_count: æˆåŠŸå›æ•°ï¼ˆè¤‡å‹å›æ•°ï¼‰
        - total_count: ç·è©¦è¡Œå›æ•°ï¼ˆå‡ºèµ°å›æ•°ï¼‰
        - prior_mean: äº‹å‰å¹³å‡ï¼ˆå…¨ä½“ã®è¤‡å‹ç‡ï¼‰
        - prior_weight: äº‹å‰åˆ†å¸ƒã®é‡ã¿ï¼ˆä¿¡é ¼åº¦ï¼‰
        """
        if total_count == 0:
            return {
                "corrected_rate": prior_mean,
                "confidence": 0.0,
                "raw_rate": 0.0
            }
        
        # ãƒ™ã‚¤ã‚ºæ¨å®šã«ã‚ˆã‚‹äº‹å¾Œç¢ºç‡
        posterior = (success_count + prior_mean * prior_weight) / (total_count + prior_weight)
        
        # ä¿¡é ¼åŒºé–“ã®è¨ˆç®—
        confidence = min(total_count / (total_count + prior_weight), 1.0)
        
        # ç”Ÿã®ç¢ºç‡
        raw_rate = success_count / total_count if total_count > 0 else 0
        
        return {
            "corrected_rate": posterior,
            "confidence": confidence,
            "raw_rate": raw_rate
        }


class RaceFlowPredictor:
    """ãƒ¬ãƒ¼ã‚¹å±•é–‹äºˆæƒ³ã‚’è¡Œã†ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.style_analyzer = RunningStyleAnalyzer()
        self.bayesian = BayesianCorrector()
    
    def predict_pace(self, all_horses_data: List[Dict]) -> Dict[str, Any]:
        """ãƒšãƒ¼ã‚¹äºˆæ¸¬ï¼ˆãƒã‚¤/å¹³å‡/ã‚¹ãƒ­ãƒ¼ï¼‰"""
        # å„é¦¬ã®è„šè³ªã‚’åˆ¤å®šï¼ˆé¦¬ç•ªä»˜ãï¼‰
        style_distribution = {
            'é€ƒã’': {'count': 0, 'horses': [], 'horse_numbers': []},
            'å…ˆè¡Œ': {'count': 0, 'horses': [], 'horse_numbers': []},
            'å·®ã—': {'count': 0, 'horses': [], 'horse_numbers': []},
            'è¿½è¾¼': {'count': 0, 'horses': [], 'horse_numbers': []},
            'ä¸æ˜': {'count': 0, 'horses': [], 'horse_numbers': []}
        }
        
        detailed_escapes = {
            'è¶…ç©æ¥µé€ƒã’': [],
            'çŠ¶æ³é€ƒã’': [],
            'æ¶ˆæ¥µé€ƒã’': []
        }
        
        # ã‚¹ã‚¿ãƒ¼ãƒˆäº‹æ•…ãŒã‚ã‚‹é¦¬ã‚’è¨˜éŒ²
        start_accident_horses = []
        start_accident_numbers = []
        
        for idx, horse_data in enumerate(all_horses_data, 1):
            if 'races' not in horse_data:
                continue
            
            horse_name = horse_data.get('horse_name', 'ä¸æ˜')
            horse_number = horse_data.get('horse_number', idx)  # é¦¬ç•ªï¼ˆãªã‘ã‚Œã°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
            
            # è„šè³ªåˆ¤å®š
            basic_style = self.style_analyzer.classify_basic_style(horse_data['races'])
            style_distribution[basic_style]['count'] += 1
            style_distribution[basic_style]['horses'].append(horse_name)
            style_distribution[basic_style]['horse_numbers'].append(horse_number)
            
            # é€ƒã’é¦¬ã®è©³ç´°åˆ†é¡
            if basic_style == 'é€ƒã’':
                _, sub_style = self.style_analyzer.classify_detailed_style(basic_style, horse_data['races'])
                detailed_escapes[sub_style].append(horse_name)
            
            # ã‚¹ã‚¿ãƒ¼ãƒˆäº‹æ•…ãƒã‚§ãƒƒã‚¯ï¼ˆç›´è¿‘5èµ°ï¼‰
            recent_races = horse_data.get('races', [])[:5]
            for race in recent_races:
                # ç™ºèµ°é †ä½ãŒé¦¬ç•ªã‚ˆã‚Š3ä»¥ä¸Šé…ã„å ´åˆã¯å‡ºé…ã‚Œã¨åˆ¤å®š
                if 'HASSOUJUN' in race and 'UMA_BAN' in race:
                    if race['HASSOUJUN'] - race['UMA_BAN'] >= 3:
                        if horse_number not in start_accident_numbers:
                            start_accident_horses.append(horse_name)
                            start_accident_numbers.append(horse_number)
                        break
        
        # ãƒšãƒ¼ã‚¹åˆ¤å®š
        super_aggressive_count = len(detailed_escapes['è¶…ç©æ¥µé€ƒã’'])
        situational_count = len(detailed_escapes['çŠ¶æ³é€ƒã’'])
        
        if super_aggressive_count >= 2:
            pace = "ãƒã‚¤ãƒšãƒ¼ã‚¹æ¿ƒåš"
            confidence = 90
        elif super_aggressive_count == 1 and situational_count >= 3:
            pace = "ã‚„ã‚„ãƒã‚¤ãƒšãƒ¼ã‚¹"
            confidence = 70
        elif situational_count >= 5:
            pace = "å¹³å‡ãƒšãƒ¼ã‚¹"
            confidence = 60
        else:
            pace = "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹"
            confidence = 80
        
        return {
            'pace': pace,
            'confidence': confidence,
            'style_distribution': style_distribution,
            'detailed_escapes': detailed_escapes,
            'start_accident_horses': start_accident_horses,
            'start_accident_numbers': start_accident_numbers
        }
    
    def identify_advantaged_horses(self, pace: str, all_horses_data: List[Dict]) -> Dict[str, List[str]]:
        """æœ‰åˆ©/ä¸åˆ©ãªé¦¬ã‚’ç‰¹å®š"""
        advantaged = []
        disadvantaged = []
        
        for horse_data in all_horses_data:
            if 'races' not in horse_data:
                continue
            
            horse_name = horse_data.get('horse_name', 'ä¸æ˜')
            basic_style = self.style_analyzer.classify_basic_style(horse_data['races'])
            
            # ãƒšãƒ¼ã‚¹ã«å¿œã˜ãŸæœ‰åˆ©ä¸åˆ©åˆ¤å®š
            if pace in ["ãƒã‚¤ãƒšãƒ¼ã‚¹æ¿ƒåš", "ã‚„ã‚„ãƒã‚¤ãƒšãƒ¼ã‚¹"]:
                if basic_style in ["å·®ã—", "è¿½è¾¼"]:
                    advantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
                elif basic_style in ["é€ƒã’", "å…ˆè¡Œ"]:
                    disadvantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
            elif pace == "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹":
                if basic_style in ["é€ƒã’", "å…ˆè¡Œ"]:
                    advantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
                elif basic_style == "è¿½è¾¼":
                    disadvantaged.append(f"{horse_name}ï¼ˆ{basic_style}ï¼‰")
        
        return {
            'advantaged': advantaged[:5],  # ä¸Šä½5é ­ã¾ã§
            'disadvantaged': disadvantaged[:5]
        }
    
    def generate_race_scenario(self, all_horses_data: List[Dict]) -> str:
        """å±•é–‹ã‚·ãƒŠãƒªã‚ªã‚’ç”Ÿæˆ"""
        pace_result = self.predict_pace(all_horses_data)
        
        scenario = f"ã€å±•é–‹äºˆæƒ³ã€‘{pace_result['pace']}ï¼ˆç¢ºä¿¡åº¦{pace_result['confidence']}%ï¼‰\n\n"
        
        # è„šè³ªåˆ†å¸ƒ
        scenario += "ã€è„šè³ªåˆ†å¸ƒã€‘\n"
        for style, data in pace_result['style_distribution'].items():
            if data['count'] > 0:
                scenario += f"ãƒ»{style}ï¼š{data['count']}é ­\n"
        
        # è©³ç´°ãªé€ƒã’é¦¬åˆ†æ
        if pace_result['detailed_escapes']['è¶…ç©æ¥µé€ƒã’']:
            scenario += f"\nâš¡ è¶…ç©æ¥µé€ƒã’ï¼š{', '.join(pace_result['detailed_escapes']['è¶…ç©æ¥µé€ƒã’'])}\n"
        if pace_result['detailed_escapes']['çŠ¶æ³é€ƒã’']:
            scenario += f"ğŸ çŠ¶æ³é€ƒã’ï¼š{', '.join(pace_result['detailed_escapes']['çŠ¶æ³é€ƒã’'])}\n"
        
        # æœ‰åˆ©ä¸åˆ©
        advantages = self.identify_advantaged_horses(pace_result['pace'], all_horses_data)
        
        if advantages['advantaged']:
            scenario += "\nğŸ¯ æœ‰åˆ©ãªé¦¬ï¼š\n"
            for horse in advantages['advantaged']:
                scenario += f"ãƒ»{horse}\n"
        
        if advantages['disadvantaged']:
            scenario += "\nâš ï¸ ä¸åˆ©ãªé¦¬ï¼š\n"
            for horse in advantages['disadvantaged']:
                scenario += f"ãƒ»{horse}\n"
        
        return scenario


# ãƒ¡ã‚¤ãƒ³ã®ViewLogicã‚¨ãƒ³ã‚¸ãƒ³
class ViewLogicEngine:
    """ViewLogicå±•é–‹äºˆæƒ³ã‚¨ãƒ³ã‚¸ãƒ³ã®ãƒ¡ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹ - è¨ˆç”»æ›¸é€šã‚Šã®å®Œå…¨å®Ÿè£…ç‰ˆ"""
    
    def __init__(self):
        self.predictor = RaceFlowPredictor()
        self.style_analyzer = RunningStyleAnalyzer()
        self.bayesian = BayesianCorrector()
        # ViewLogicãƒ‡ãƒ¼ã‚¿ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ç”¨ï¼‰
        from services.viewlogic_data_manager import get_viewlogic_data_manager
        self.data_manager = get_viewlogic_data_manager()
        # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
        self.jockey_manager = get_jockey_knowledge_manager()
        
        # ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆ4GBãƒ¡ãƒ¢ãƒªæ´»ç”¨ï¼‰
        self.trend_cache = {}
        self.cache_ttl = 1800  # 30åˆ†é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        self.max_cache_size = 100  # æœ€å¤§100ãƒ¬ãƒ¼ã‚¹åˆ†
    
    def _generate_cache_key(self, race_data: Dict[str, Any]) -> str:
        """ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ã‚’ç”Ÿæˆ"""
        # é‡è¦ãªè¦ç´ ã®ã¿ã§ã‚­ãƒ¼ã‚’ä½œæˆï¼ˆé †åºç„¡è¦–ï¼‰
        horses = sorted(race_data.get('horses', []))
        jockeys = sorted(race_data.get('jockeys', []))
        posts = sorted(race_data.get('posts', []))
        
        key_data = {
            'venue': race_data.get('venue', ''),
            'distance': race_data.get('distance', ''),
            'course_type': race_data.get('course_type', 'èŠ'),
            'horses': horses,
            'jockeys': jockeys,
            'posts': posts
        }
        
        # ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã‚­ãƒ¼ã«ã™ã‚‹
        key_string = json.dumps(key_data, sort_keys=True, ensure_ascii=False)
        return hashlib.md5(key_string.encode('utf-8')).hexdigest()
    
    def _get_cached_trend(self, cache_key: str) -> Optional[Dict[str, Any]]:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‚¾å‘åˆ†æçµæœã‚’å–å¾—"""
        if cache_key in self.trend_cache:
            cache_entry = self.trend_cache[cache_key]
            # TTL ãƒã‚§ãƒƒã‚¯
            if time.time() - cache_entry['timestamp'] < self.cache_ttl:
                logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: {cache_key[:8]}...")
                return cache_entry['data']
            else:
                # æœŸé™åˆ‡ã‚Œã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
                del self.trend_cache[cache_key]
                logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœŸé™åˆ‡ã‚Œ: {cache_key[:8]}...")
        return None
    
    def _cache_trend_result(self, cache_key: str, result: Dict[str, Any]) -> None:
        """å‚¾å‘åˆ†æçµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜"""
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™
        if len(self.trend_cache) >= self.max_cache_size:
            # æœ€ã‚‚å¤ã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤
            oldest_key = min(self.trend_cache.keys(), 
                           key=lambda k: self.trend_cache[k]['timestamp'])
            del self.trend_cache[oldest_key]
            logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ã«ã‚ˆã‚Šå‰Šé™¤: {oldest_key[:8]}...")
        
        self.trend_cache[cache_key] = {
            'data': result,
            'timestamp': time.time()
        }
        logger.info(f"ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜: {cache_key[:8]}... (åˆè¨ˆ: {len(self.trend_cache)}ä»¶)")
    
    def predict_race_flow_advanced(self, race_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        è¨ˆç”»æ›¸é€šã‚Šã®é«˜åº¦ãªå±•é–‹äºˆæƒ³
        å‰åŠ3Fãƒ»å¾ŒåŠ3Fã‚’ä½¿ç”¨ã—ãŸãƒšãƒ¼ã‚¹äºˆæ¸¬ã¨è©³ç´°ãªè„šè³ªåˆ†æ
        """
        horses = race_data.get('horses', [])
        if not horses:
            return {
                'status': 'error',
                'message': 'å‡ºèµ°é¦¬æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“'
            }
        
        # å„é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆé¦¬ç•ªä»˜ãï¼‰
        horses_data = []
        for idx, horse_name in enumerate(horses, 1):
            horse_data = self.data_manager.get_horse_data(horse_name)
            if horse_data:
                horse_data['horse_number'] = race_data.get('horse_numbers', [])[idx-1] if idx-1 < len(race_data.get('horse_numbers', [])) else idx
                horses_data.append(horse_data)
        
        # è¨ˆç”»æ›¸é€šã‚Šã®ãƒšãƒ¼ã‚¹äºˆæ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        pace_prediction = self._advanced_pace_prediction(horses_data)
        
        # è©³ç´°ãªè„šè³ªåˆ†é¡ï¼ˆè¶…ç©æ¥µé€ƒã’ã€çŠ¶æ³é€ƒã’ãªã©ï¼‰
        detailed_styles = self._classify_detailed_styles(horses_data)
        
        # ä½ç½®å–ã‚Šå®‰å®šæ€§æŒ‡æ¨™ã®è¨ˆç®—
        position_stability = self._calculate_position_stability_all(horses_data)
        
        # å±•é–‹é©æ€§ãƒãƒƒãƒãƒ³ã‚°
        flow_matching = self._calculate_flow_matching(horses_data, pace_prediction)
        
        # å±•é–‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        race_simulation = self._simulate_race_positions(horses_data, pace_prediction)
        
        return {
            'status': 'success',
            'type': 'advanced_flow_prediction',
            'race_info': {
                'venue': race_data.get('venue', ''),
                'race_number': race_data.get('race_number', ''),
                'race_name': race_data.get('race_name', ''),
                'distance': race_data.get('distance', '')
            },
            'pace_prediction': pace_prediction,
            'detailed_styles': detailed_styles,
            'position_stability': position_stability,
            'flow_matching': flow_matching,
            'race_simulation': race_simulation,
            'visualization_data': self._prepare_visualization_data(race_simulation)
        }
    
    def _advanced_pace_prediction(self, horses_data: List[Dict]) -> Dict[str, Any]:
        """
        è¨ˆç”»æ›¸é€šã‚Šã®ãƒšãƒ¼ã‚¹äºˆæ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        å‰åŠ3Fãƒ»å¾ŒåŠ3Fã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
        """
        zenhan_times = []  # å‰åŠ3Fã‚¿ã‚¤ãƒ 
        kohan_times = []   # å¾ŒåŠ3Fã‚¿ã‚¤ãƒ 
        
        for horse in horses_data:
            if 'races' not in horse:
                continue
            
            # ç›´è¿‘ãƒ¬ãƒ¼ã‚¹ã®å‰åŠ3Fãƒ»å¾ŒåŠ3Fã‚’åé›†
            for race in horse['races'][:5]:  # ç›´è¿‘5ãƒ¬ãƒ¼ã‚¹
                if race.get('ZENHAN_3F'):
                    zenhan_value = float(race['ZENHAN_3F'])
                    # ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’åˆ¤å®šï¼ˆ100ä»¥ä¸Šãªã‚‰0.1ç§’å˜ä½ã€100æœªæº€ãªã‚‰ç§’å˜ä½ï¼‰
                    if zenhan_value >= 100:
                        # 0.1ç§’å˜ä½ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆä¾‹ï¼š355.0 = 35.5ç§’ï¼‰
                        zenhan_times.append(zenhan_value / 10)
                    else:
                        # æ—¢ã«ç§’å˜ä½ã®ãƒ‡ãƒ¼ã‚¿ï¼ˆä¾‹ï¼š35.5ï¼‰
                        zenhan_times.append(zenhan_value)
                        
                if race.get('KOHAN_3F'):
                    kohan_value = float(race['KOHAN_3F'])
                    # 999.0ã¯æ¬ æå€¤ã‚’ç¤ºã™ã®ã§é™¤å¤–
                    if kohan_value == 999.0:
                        continue
                    # ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’åˆ¤å®š
                    if kohan_value >= 100:
                        # 0.1ç§’å˜ä½ã®ãƒ‡ãƒ¼ã‚¿
                        kohan_times.append(kohan_value / 10)
                    else:
                        # æ—¢ã«ç§’å˜ä½ã®ãƒ‡ãƒ¼ã‚¿
                        kohan_times.append(kohan_value)
        
        if not zenhan_times:
            return {'pace': 'ãƒ‡ãƒ¼ã‚¿ä¸è¶³', 'confidence': 0, 'zenhan_avg': 0, 'kohan_avg': 0}
        
        # å¹³å‡å‰åŠ3Fã‚¿ã‚¤ãƒ ã§ãƒšãƒ¼ã‚¹åˆ¤å®š
        zenhan_avg = mean(zenhan_times)
        kohan_avg = mean(kohan_times) if kohan_times else 0
        
        # å®Ÿéš›ã®ç«¶é¦¬ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ããƒšãƒ¼ã‚¹åˆ¤å®šåŸºæº–
        # å‰åŠ3Fã‚¿ã‚¤ãƒ : 33ç§’å°=è¶…ãƒã‚¤ã€34ç§’å°=ãƒã‚¤ã€35ç§’å°=å¹³å‡ã€36ç§’å°ä»¥ä¸Š=ã‚¹ãƒ­ãƒ¼
        if zenhan_avg <= 33.8:
            pace = "è¶…ãƒã‚¤ãƒšãƒ¼ã‚¹"
            confidence = 95
        elif zenhan_avg <= 34.8:
            pace = "ãƒã‚¤ãƒšãƒ¼ã‚¹"
            confidence = 90
        elif zenhan_avg <= 35.8:
            pace = "å¹³å‡ãƒšãƒ¼ã‚¹"
            confidence = 85
        else:
            pace = "ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹"
            confidence = 80
        
        return {
            'pace': pace,
            'confidence': confidence,
            'zenhan_avg': zenhan_avg,
            'kohan_avg': kohan_avg,
            'pace_index': (kohan_avg - zenhan_avg) * 10  # ãƒšãƒ¼ã‚¹æŒ‡æ•°
        }
    
    def _classify_detailed_styles(self, horses_data: List[Dict]) -> Dict[str, Any]:
        """
        è©³ç´°ãªè„šè³ªåˆ†é¡ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰
        é€ƒã’é¦¬ã‚’è¶…ç©æ¥µé€ƒã’ã€çŠ¶æ³é€ƒã’ã€æ¶ˆæ¥µé€ƒã’ã«åˆ†é¡
        """
        detailed_classification = {
            'é€ƒã’': {'è¶…ç©æ¥µé€ƒã’': [], 'çŠ¶æ³é€ƒã’': [], 'æ¶ˆæ¥µé€ƒã’': []},
            'å…ˆè¡Œ': {'å‰å¯„ã‚Šå…ˆè¡Œ': [], 'å®‰å®šå…ˆè¡Œ': [], 'å¾Œå¯„ã‚Šå…ˆè¡Œ': []},
            'å·®ã—': {'å¼·çƒˆå·®ã—': [], 'ç¢ºå®Ÿå·®ã—': [], 'é…ã‚å·®ã—': []},
            'è¿½è¾¼': {'æ¥µé™è¿½è¾¼': [], 'å¼·åŠ›è¿½è¾¼': [], 'é€šå¸¸è¿½è¾¼': []}
        }
        
        for horse in horses_data:
            if 'races' not in horse:
                continue
            
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            horse_number = horse.get('horse_number', 0)
            
            # åŸºæœ¬è„šè³ªã®åˆ¤å®š
            basic_style = self.style_analyzer.classify_basic_style(horse['races'])
            
            # è©³ç´°åˆ†é¡
            if basic_style == 'é€ƒã’':
                sub_style = self._classify_escape_details_advanced(horse['races'])
                detailed_classification['é€ƒã’'][sub_style].append(horse_name)
            elif basic_style == 'å…ˆè¡Œ':
                sub_style = self._classify_stalker_details_advanced(horse['races'])
                detailed_classification['å…ˆè¡Œ'][sub_style].append(horse_name)
            elif basic_style == 'å·®ã—':
                sub_style = self._classify_closer_details_advanced(horse['races'])
                detailed_classification['å·®ã—'][sub_style].append(horse_name)
            elif basic_style == 'è¿½è¾¼':
                sub_style = self._classify_latecloser_details_advanced(horse['races'])
                detailed_classification['è¿½è¾¼'][sub_style].append(horse_name)
        
        return detailed_classification
    
    def _classify_escape_details_advanced(self, races: List[Dict]) -> str:
        """é€ƒã’é¦¬ã®è©³ç´°åˆ†é¡ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰"""
        solo_escape_count = 0
        escape_success_count = 0
        total_escapes = 0
        
        for race in races:
            corner1 = race.get('CORNER1_JUNI', 99)
            corner2 = race.get('CORNER2_JUNI', 99)
            
            if corner1 <= 2:  # é€ƒã’ãŸå ´åˆ
                total_escapes += 1
                
                # å˜ç‹¬é€ƒã’ã‹ãƒã‚§ãƒƒã‚¯
                if corner1 == 1 and corner2 == 1:
                    solo_escape_count += 1
                
                # é€ƒã’ã¦3ç€ä»¥å†…
                if race.get('KAKUTEI_CHAKUJUN', 99) <= 3:
                    escape_success_count += 1
        
        if total_escapes == 0:
            return 'æ¶ˆæ¥µé€ƒã’'
        
        solo_rate = solo_escape_count / total_escapes
        success_rate = escape_success_count / total_escapes
        
        if solo_rate > 0.6:
            return 'è¶…ç©æ¥µé€ƒã’'
        elif success_rate > 0.5:
            return 'çŠ¶æ³é€ƒã’'
        else:
            return 'æ¶ˆæ¥µé€ƒã’'
    
    def _classify_stalker_details_advanced(self, races: List[Dict]) -> str:
        """å…ˆè¡Œé¦¬ã®è©³ç´°åˆ†é¡"""
        corner1_positions = []
        
        for race in races:
            corner1 = race.get('CORNER1_JUNI', 99)
            if corner1 < 99:
                corner1_positions.append(corner1)
        
        if not corner1_positions:
            return 'æ¨™æº–å…ˆè¡Œ'
        
        avg_corner1 = mean(corner1_positions)
        position_stability = 1 / (1 + stdev(corner1_positions)) if len(corner1_positions) > 1 else 0.5
        
        if avg_corner1 <= 3.5 and position_stability > 0.8:
            return 'å‰å¯„ã‚Šå…ˆè¡Œ'
        elif position_stability > 0.7:
            return 'å®‰å®šå…ˆè¡Œ'
        else:
            return 'å¾Œå¯„ã‚Šå…ˆè¡Œ'
    
    def _classify_closer_details_advanced(self, races: List[Dict]) -> str:
        """å·®ã—é¦¬ã®è©³ç´°åˆ†é¡"""
        finishing_improvements = []
        
        for race in races:
            corner4 = race.get('CORNER4_JUNI', 99)
            finish = race.get('KAKUTEI_CHAKUJUN', 99)
            
            if corner4 < 99 and finish < 99:
                improvement = corner4 - finish
                finishing_improvements.append(improvement)
        
        if not finishing_improvements:
            return 'é…ã‚å·®ã—'
        
        avg_improvement = mean(finishing_improvements)
        
        if avg_improvement > 3:
            return 'å¼·çƒˆå·®ã—'
        elif avg_improvement > 1:
            return 'ç¢ºå®Ÿå·®ã—'
        else:
            return 'é…ã‚å·®ã—'
    
    def _classify_latecloser_details_advanced(self, races: List[Dict]) -> str:
        """è¿½è¾¼é¦¬ã®è©³ç´°åˆ†é¡"""
        extreme_finishes = 0
        
        for race in races:
            corner4 = race.get('CORNER4_JUNI', 99)
            finish = race.get('KAKUTEI_CHAKUJUN', 99)
            
            if corner4 > 10 and finish <= 3:
                extreme_finishes += 1
        
        extreme_rate = extreme_finishes / len(races) if races else 0
        
        if extreme_rate > 0.3:
            return 'æ¥µé™è¿½è¾¼'
        elif extreme_rate > 0.1:
            return 'å¼·åŠ›è¿½è¾¼'
        else:
            return 'é€šå¸¸è¿½è¾¼'
    
    def _calculate_position_stability_all(self, horses_data: List[Dict]) -> Dict[str, float]:
        """å…¨é¦¬ã®ä½ç½®å–ã‚Šå®‰å®šæ€§æŒ‡æ¨™ã‚’è¨ˆç®—ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰"""
        stability_scores = {}
        
        for horse in horses_data:
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            horse_number = horse.get('horse_number', 0)
            
            if 'races' not in horse:
                stability_scores[horse_name] = 0.0
                continue
            
            stability_values = []
            for race in horse['races']:
                positions = [
                    race.get('CORNER1_JUNI', 99),
                    race.get('CORNER2_JUNI', 99),
                    race.get('CORNER3_JUNI', 99),
                    race.get('CORNER4_JUNI', 99)
                ]
                
                # æœ‰åŠ¹ãªä½ç½®ãƒ‡ãƒ¼ã‚¿ã®ã¿ä½¿ç”¨
                valid_positions = [p for p in positions if p < 99]
                if len(valid_positions) > 1:
                    # æ¨™æº–åå·®ãŒå°ã•ã„ã»ã©å®‰å®š
                    stability = 1 / (1 + stdev(valid_positions))
                    stability_values.append(stability)
            
            stability_scores[horse_name] = mean(stability_values) if stability_values else 0.0
        
        return stability_scores
    
    def _calculate_flow_matching(self, horses_data: List[Dict], pace_prediction: Dict) -> Dict[str, Any]:
        """å±•é–‹é©æ€§ãƒãƒƒãƒãƒ³ã‚°ï¼ˆè¨ˆç”»æ›¸é€šã‚Šï¼‰"""
        flow_scores = {}
        pace = pace_prediction['pace']
        
        for horse in horses_data:
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            
            if 'races' not in horse:
                flow_scores[horse_name] = 50.0
                continue
            
            # è„šè³ªæŒ‡æ•°ã®è¨ˆç®—
            style_index = self._calculate_style_index(horse['races'])
            
            # éå»ã®æˆç¸¾ã‹ã‚‰å®Ÿç¸¾è©•ä¾¡ã‚’åŠ å‘³
            performance_bonus = self._calculate_performance_bonus(horse['races'])
            
            # ãƒšãƒ¼ã‚¹ã«å¿œã˜ãŸè©•ä¾¡èª¿æ•´ï¼ˆã‚ˆã‚Šå¤§ããªå·®åˆ¥åŒ–ï¼‰
            if 'ãƒã‚¤ãƒšãƒ¼ã‚¹' in pace:
                # å¾ŒåŠå‹æœ‰åˆ©
                if style_index > 0:  # å·®ã—ãƒ»è¿½è¾¼ã‚¿ã‚¤ãƒ—
                    base_score = 65 + (style_index * 5)  # ã‚ˆã‚Šå¤§ããªå·®ã‚’ä»˜ã‘ã‚‹
                else:  # é€ƒã’ãƒ»å…ˆè¡Œã‚¿ã‚¤ãƒ—
                    base_score = 40 - (abs(style_index) * 3)
            elif 'ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹' in pace:
                # å‰åŠå‹æœ‰åˆ©
                if style_index < 0:  # é€ƒã’ãƒ»å…ˆè¡Œã‚¿ã‚¤ãƒ—
                    base_score = 65 + (abs(style_index) * 5)
                else:  # å·®ã—ãƒ»è¿½è¾¼ã‚¿ã‚¤ãƒ—
                    base_score = 40 - (style_index * 3)
            else:
                # å¹³å‡ãƒšãƒ¼ã‚¹ - è„šè³ªã«ã‚ˆã‚‹å·®åˆ¥åŒ–ã‚’è¿½åŠ 
                if abs(style_index) < 1:  # ãƒãƒ©ãƒ³ã‚¹å‹
                    base_score = 60 + performance_bonus
                elif style_index > 0:  # å·®ã—ãƒ»è¿½è¾¼å¯„ã‚Š
                    base_score = 55 + (style_index * 2) + performance_bonus
                else:  # é€ƒã’ãƒ»å…ˆè¡Œå¯„ã‚Š
                    base_score = 55 + (abs(style_index) * 2) + performance_bonus
            
            # æœ€çµ‚ã‚¹ã‚³ã‚¢ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒœãƒ¼ãƒŠã‚¹ã‚’åŠ å‘³ï¼‰
            final_score = base_score + performance_bonus
            flow_scores[horse_name] = min(100, max(0, final_score))
        
        return flow_scores
    
    def _calculate_style_index(self, races: List[Dict]) -> float:
        """è„šè³ªæŒ‡æ•°ã®è¨ˆç®—ï¼ˆå¾ŒåŠ-å‰åŠã®å·®ï¼‰"""
        style_values = []
        
        for race in races:
            zenhan = race.get('ZENHAN_3F', 0)
            kohan = race.get('KOHAN_3F', 0)
            
            if zenhan and kohan:
                # æ­£ã®å€¤ã¯å·®ã—ãƒ»è¿½è¾¼å‹ã€è² ã®å€¤ã¯é€ƒã’ãƒ»å…ˆè¡Œå‹
                style_values.append((kohan - zenhan) / 10)
        
        return mean(style_values) if style_values else 0
    
    def _simulate_race_positions(self, horses_data: List[Dict], pace_prediction: Dict) -> Dict[str, Any]:
        """å±•é–‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆâ†’3ã‚³ãƒ¼ãƒŠãƒ¼â†’4ã‚³ãƒ¼ãƒŠãƒ¼â†’ã‚´ãƒ¼ãƒ«ï¼‰"""
        simulation = {
            'start': [],
            'corner3': [],
            'corner4': [],
            'finish': []
        }
        
        for horse in horses_data:
            horse_name = horse.get('horse_name', 'ä¸æ˜')
            
            if 'races' not in horse:
                continue
            
            # éå»ã®ã‚³ãƒ¼ãƒŠãƒ¼é€šéé †ä½ã®å¹³å‡ã‹ã‚‰äºˆæ¸¬
            c1_data = [r.get('CORNER1_JUNI', 10) for r in horse['races'] if r.get('CORNER1_JUNI')]
            c3_data = [r.get('CORNER3_JUNI', 10) for r in horse['races'] if r.get('CORNER3_JUNI')]
            c4_data = [r.get('CORNER4_JUNI', 10) for r in horse['races'] if r.get('CORNER4_JUNI')]
            
            avg_c1 = mean(c1_data) if c1_data else 10
            avg_c3 = mean(c3_data) if c3_data else 10
            avg_c4 = mean(c4_data) if c4_data else 10
            
            simulation['start'].append({'horse_name': horse_name, 'position': avg_c1})
            simulation['corner3'].append({'horse_name': horse_name, 'position': avg_c3})
            simulation['corner4'].append({'horse_name': horse_name, 'position': avg_c4})
            
            # å±•é–‹ã¨ãƒšãƒ¼ã‚¹ã‚’è€ƒæ…®ã—ãŸç€é †äºˆæ¸¬
            predicted_finish = self._predict_finish_position(horse, pace_prediction)
            simulation['finish'].append({'horse_name': horse_name, 'position': predicted_finish})
        
        # å„ãƒã‚¤ãƒ³ãƒˆã§é †ä½ã§ã‚½ãƒ¼ãƒˆ
        for key in simulation:
            simulation[key].sort(key=lambda x: x['position'])
        
        return simulation
    
    def _predict_finish_position(self, horse_data: Dict, pace_prediction: Dict) -> float:
        """ãƒšãƒ¼ã‚¹ã‚’è€ƒæ…®ã—ãŸç€é †äºˆæ¸¬"""
        if 'races' not in horse_data:
            return 10.0
        
        # åŸºæœ¬çš„ãªç€é †ã®å¹³å‡
        avg_finish = mean([r.get('KAKUTEI_CHAKUJUN', 10) for r in horse_data['races']])
        
        # ãƒšãƒ¼ã‚¹ã«ã‚ˆã‚‹è£œæ­£
        style_index = self._calculate_style_index(horse_data['races'])
        pace = pace_prediction['pace']
        
        if 'ãƒã‚¤ãƒšãƒ¼ã‚¹' in pace and style_index > 0:
            # å·®ã—ãƒ»è¿½è¾¼æœ‰åˆ©
            avg_finish -= 1.5
        elif 'ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹' in pace and style_index < 0:
            # é€ƒã’ãƒ»å…ˆè¡Œæœ‰åˆ©
            avg_finish -= 1.5
        
        return max(1.0, avg_finish)
    
    def _prepare_visualization_data(self, simulation: Dict) -> Dict[str, Any]:
        """å¯è¦–åŒ–ç”¨ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™"""
        return {
            'type': 'race_flow_chart',
            'data': simulation,
            'chart_config': {
                'width': 800,
                'height': 400,
                'colors': {
                    'é€ƒã’': '#FF6B6B',
                    'å…ˆè¡Œ': '#4ECDC4',
                    'å·®ã—': '#45B7D1',
                    'è¿½è¾¼': '#96CEB4'
                }
            }
        }
    
    def analyze_race(self, horses_data: List[Dict]) -> Dict[str, Any]:
        """ãƒ¬ãƒ¼ã‚¹å…¨ä½“ã®åˆ†æã‚’å®Ÿè¡Œ"""
        # ãƒšãƒ¼ã‚¹äºˆæ¸¬
        pace_result = self.predictor.predict_pace(horses_data)
        
        # æœ‰åˆ©ä¸åˆ©åˆ¤å®š
        advantages = self.predictor.identify_advantaged_horses(
            pace_result['pace'], horses_data
        )
        
        # ã‚·ãƒŠãƒªã‚ªç”Ÿæˆ
        scenario = self.predictor.generate_race_scenario(horses_data)
        
        return {
            'pace': pace_result,
            'advantages': advantages,
            'scenario': scenario,
            'total_horses': len(horses_data)
        }
    
    def predict_race_flow(self, race_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        å±•é–‹äºˆæƒ³æ©Ÿèƒ½ - ãƒ¬ãƒ¼ã‚¹ã®æµã‚Œã€ãƒšãƒ¼ã‚¹ã€æœ‰åˆ©ä¸åˆ©ã‚’äºˆæ¸¬
        
        Args:
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼ˆå‡ºèµ°é¦¬ãƒªã‚¹ãƒˆã€é–‹å‚¬æƒ…å ±ãªã©ï¼‰
        
        Returns:
            å±•é–‹äºˆæƒ³çµæœ
        """
        horses = race_data.get('horses', [])
        if not horses:
            return {
                'status': 'error',
                'message': 'å‡ºèµ°é¦¬æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“'
            }
        
        # å„é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆé¦¬ç•ªä»˜ãï¼‰
        horses_data = []
        for idx, horse_name in enumerate(horses, 1):
            horse_data = self.data_manager.get_horse_data(horse_name)
            if horse_data:
                # é¦¬ç•ªã‚’è¿½åŠ 
                horse_data['horse_number'] = race_data.get('horse_numbers', [])[idx-1] if idx-1 < len(race_data.get('horse_numbers', [])) else idx
                horses_data.append(horse_data)
        
        if not horses_data:
            return {
                'status': 'error',
                'message': 'ãƒŠãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
            }
        
        # å±•é–‹åˆ†æã‚’å®Ÿè¡Œ
        analysis = self.analyze_race(horses_data)
        
        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼ã‚’æ•´ãˆã‚‹
        return {
            'status': 'success',
            'type': 'flow_prediction',
            'race_info': {
                'venue': race_data.get('venue', ''),
                'race_number': race_data.get('race_number', ''),
                'race_name': race_data.get('race_name', ''),
                'distance': race_data.get('distance', '')
            },
            'prediction': {
                'pace': analysis['pace']['pace'],
                'pace_confidence': analysis['pace']['confidence'],
                'style_distribution': self._format_style_distribution(analysis['pace']['style_distribution']),
                'detailed_escapes': analysis['pace']['detailed_escapes'],
                'advantaged_horses': analysis['advantages']['advantaged'],
                'disadvantaged_horses': analysis['advantages']['disadvantaged'],
                'start_accident_numbers': analysis['pace'].get('start_accident_numbers', []),
                'running_style_numbers': {
                    'é€ƒã’': analysis['pace']['style_distribution']['é€ƒã’']['horse_numbers'],
                    'å…ˆè¡Œ': analysis['pace']['style_distribution']['å…ˆè¡Œ']['horse_numbers'],
                    'å·®ã—': analysis['pace']['style_distribution']['å·®ã—']['horse_numbers'],
                    'è¿½è¾¼': analysis['pace']['style_distribution']['è¿½è¾¼']['horse_numbers']
                }
            },
            'scenario': analysis['scenario'],
            'analyzed_horses': len(horses_data),
            'total_horses': len(horses)
        }
    
    def analyze_course_trend(self, race_data: Dict[str, Any], progress_callback=None) -> Dict[str, Any]:
        """
        ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æï¼ˆå®Ÿéš›ã®å‡ºå ´é¦¬ãƒ»é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ã«åŸºã¥ã3é …ç›®åˆ†æï¼‰
        
        Args:
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼ˆå‡ºå ´é¦¬ãƒ»é¨æ‰‹å«ã‚€ï¼‰
            progress_callback: ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å ±å‘Šç”¨ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
        
        Returns:
            ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æçµæœï¼ˆ3é …ç›®ï¼‰:
            1. å‡ºå ´ã™ã‚‹é¦¬å…¨ã¦ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡
            2. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡  
            3. é¨æ‰‹ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡
        """
        try:
            # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
            cache_key = self._generate_cache_key(race_data)
            cached_result = self._get_cached_trend(cache_key)
            if cached_result:
                if progress_callback:
                    progress_callback("ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰çµæœã‚’å–å¾—ã—ã¾ã—ãŸ", 100)
                return cached_result
            
            venue = race_data.get('venue', 'ä¸æ˜')
            distance = race_data.get('distance')
            
            # distanceãŒæ–‡å­—åˆ—ã®å ´åˆã€æ•°å€¤ã«å¤‰æ›
            if isinstance(distance, str):
                # "1200m" -> 1200 ã®ã‚ˆã†ãªå¤‰æ›
                distance_str = distance.replace('m', '').replace('M', '').strip()
                try:
                    distance = int(distance_str)
                except (ValueError, AttributeError):
                    distance = None
            
            # track_typeã¯course_typeã¾ãŸã¯track_conditionã‹ã‚‰å–å¾—
            track_type = race_data.get('course_type') or race_data.get('track_type', 'èŠ')
            if track_type not in ['èŠ', 'ãƒ€ãƒ¼ãƒˆ']:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯èŠ
                track_type = 'èŠ'
            
            horses = race_data.get('horses', [])
            jockeys = race_data.get('jockeys', [])
            posts = race_data.get('posts', [])  # æ ç•ªãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            
            # horsesãŒæ•´æ•°ã‚„è¾æ›¸ã®å ´åˆã®å‡¦ç†
            if horses and not isinstance(horses[0], str):
                logger.error(f"horsesé…åˆ—ã®è¦ç´ ãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(horses[0])}, value={horses[0]}")
                # horsesãŒæ•°å€¤ã®é…åˆ—ã®å ´åˆã€ç©ºé…åˆ—ã«ç½®ãæ›ãˆã‚‹
                horses = []
            
            # jockeysã®ãƒ‡ãƒ¼ã‚¿å‹ãƒã‚§ãƒƒã‚¯
            if jockeys:
                # jockeysãŒæ–‡å­—åˆ—ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                if not isinstance(jockeys, list):
                    logger.error(f"jockeysãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockeys)}")
                    jockeys = []
                else:
                    # å„è¦ç´ ãŒæ–‡å­—åˆ—ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                    valid_jockeys = []
                    for j in jockeys:
                        if isinstance(j, str):
                            valid_jockeys.append(j)
                        else:
                            logger.error(f"é¨æ‰‹åãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(j)}, value={j}")
                    jockeys = valid_jockeys
            
            # postsã®ãƒ‡ãƒ¼ã‚¿å‹ãƒã‚§ãƒƒã‚¯
            if posts:
                # postsãŒæ•°å€¤ã®ãƒªã‚¹ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                if not isinstance(posts, list):
                    logger.error(f"postsãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(posts)}")
                    posts = []
                else:
                    # å„è¦ç´ ãŒæ•°å€¤ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
                    valid_posts = []
                    for p in posts:
                        if isinstance(p, (int, float)):
                            valid_posts.append(int(p))
                        elif isinstance(p, str):
                            # æ–‡å­—åˆ—ã®å ´åˆã¯æ•°å€¤ã«å¤‰æ›ã‚’è©¦ã¿ã‚‹
                            try:
                                valid_posts.append(int(p))
                            except (ValueError, TypeError):
                                logger.error(f"æ ç•ªãŒæ•°å€¤ã«å¤‰æ›ã§ãã¾ã›ã‚“: type={type(p)}, value={p}")
                        else:
                            logger.error(f"æ ç•ªãŒä¸æ­£ãªå‹ã§ã™: type={type(p)}, value={p}")
                    posts = valid_posts
            
            # ã‚³ãƒ¼ã‚¹è­˜åˆ¥å­ï¼ˆä¾‹: "æ–°æ½Ÿ1800mèŠ"ï¼‰
            course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
            
            logger.info(f"å‚¾å‘åˆ†æé–‹å§‹ï¼ˆå®Ÿå‡ºå ´ãƒ‡ãƒ¼ã‚¿ï¼‰: {course_key}")
            logger.info(f"venue: {venue}, distance: {distance} (type: {type(distance)}), track_type: {track_type}")
            logger.info(f"å‡ºå ´é¦¬ ({len(horses)}é ­): {horses[:5] if horses else []}")  # æœ€åˆã®5é ­ã®ã¿ãƒ­ã‚°
            logger.info(f"é¨æ‰‹ ({len(jockeys)}å): {jockeys[:5] if jockeys else []}")  # æœ€åˆã®5åã®ã¿ãƒ­ã‚°
            logger.info(f"æ ç•ª ({len(posts)}): {posts[:5] if posts else []}")  # æœ€åˆã®5æ ã®ã¿ãƒ­ã‚°
            
            # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å ±å‘Š: åˆ†æé–‹å§‹
            if progress_callback:
                progress_callback("ViewLogicå‚¾å‘åˆ†æã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...", 10)
            
            # 1. å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾è¤‡å‹ç‡ã‚’åˆ†æï¼ˆViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
            if progress_callback:
                progress_callback(f"å‡ºå ´é¦¬ã®{course_key}ã§ã®æˆç¸¾ã‚’åˆ†æä¸­...", 30)
            horse_course_stats = self._analyze_horses_course_performance(horses, venue, distance, track_type)
            
            # 2. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡åˆ†æï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
            if progress_callback:
                progress_callback("é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾ã‚’åˆ†æä¸­...", 50)
            jockey_post_stats = []
            if jockeys and posts and len(jockeys) == len(posts):
                jockey_post_stats = self._analyze_jockeys_post_performance(jockeys, posts)
            
            # 3. é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾è¤‡å‹ç‡åˆ†æï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
            if progress_callback:
                progress_callback(f"é¨æ‰‹ã®{course_key}ã§ã®æˆç¸¾ã‚’åˆ†æä¸­...", 70)
            jockey_course_stats = []
            if jockeys:
                jockey_course_stats = self._analyze_jockeys_course_performance(jockeys, venue, distance, track_type)
            
            # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å ±å‘Š: åˆ†æå®Œäº†
            if progress_callback:
                progress_callback("åˆ†æçµæœã‚’ã¾ã¨ã‚ã¦ã„ã¾ã™...", 95)
            
            result = {
                'status': 'success',
                'type': 'trend_analysis',
                'course_info': {
                    'venue': venue,
                    'distance': distance,
                    'track_type': track_type,
                    'course_key': course_key
                },
                'trends': {
                    'horse_course_performance': horse_course_stats,      # 1. å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾
                    'jockey_post_performance': jockey_post_stats,        # 2. é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾
                    'jockey_course_performance': jockey_course_stats     # 3. é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾
                },
                'insights': self._generate_trend_insights_from_real_data(
                    horse_course_stats, jockey_post_stats, jockey_course_stats
                ),
                'data_period': '2023-2025',
                'sample_size': len(horses) + len(jockeys),
                'course_identifier': course_key
            }
            
            # çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
            self._cache_trend_result(cache_key, result)
            
            if progress_callback:
                progress_callback("åˆ†æå®Œäº†ï¼", 100)
                
            return result
            
        except Exception as e:
            logger.error(f"ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return {
                'status': 'error',
                'message': f'ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def recommend_betting_tickets(self, race_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        é¦¬åˆ¸æ¨å¥¨æ©Ÿèƒ½ - ViewLogicå±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‚’åŸºã«æ¨å¥¨é¦¬åˆ¸ã‚’ç”Ÿæˆ
        
        Args:
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼ˆå‡ºèµ°é¦¬ã€é¨æ‰‹ã€æ ç•ªãªã©ï¼‰
        
        Returns:
            æ¨å¥¨é¦¬åˆ¸æƒ…å ±
        """
        try:
            # åŸºæœ¬æƒ…å ±ã‚’å–å¾—
            venue = race_data.get('venue', 'ä¸æ˜')
            horses = race_data.get('horses', [])
            jockeys = race_data.get('jockeys', [])
            posts = race_data.get('posts', [])
            
            # ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼
            if not horses or len(horses) < 3:
                return {
                    'status': 'error',
                    'message': 'æ¨å¥¨é¦¬åˆ¸ã®ç”Ÿæˆã«ã¯æœ€ä½3é ­ã®å‡ºèµ°é¦¬ãŒå¿…è¦ã§ã™ã€‚'
                }
            
            # ã¾ãšViewLogicå±•é–‹äºˆæƒ³ã‚’å®Ÿè¡Œã—ã¦ä¸Šä½5é ­ã‚’å–å¾—
            flow_result = self.predict_race_flow_advanced(race_data)
            
            # å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‚’å–å¾—ï¼ˆrace_simulationã®finishã‹ã‚‰å–å¾—ï¼‰
            top_5_horses = []
            if flow_result and flow_result.get('status') == 'success':
                # race_simulationã®finishã‹ã‚‰ä¸Šä½5é ­ã‚’å–å¾—
                if 'race_simulation' in flow_result and 'finish' in flow_result['race_simulation']:
                    finish_order = flow_result['race_simulation']['finish']
                    logger.info(f"å±•é–‹äºˆæƒ³çµæœï¼ˆfinishï¼‰: {finish_order[:5]}")
                    # æ—¢ã«positionã§ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãªã®ã§ã€å…ˆé ­ã‹ã‚‰5é ­å–å¾—
                    for horse_info in finish_order[:5]:
                        horse_name = horse_info.get('horse_name')
                        if horse_name and horse_name in horses:
                            top_5_horses.append(horse_name)
                    logger.info(f"å±•é–‹äºˆæƒ³ä¸Šä½5é ­: {top_5_horses}")
                            
                # ã‚‚ã—ä¸Šè¨˜ã§å–å¾—ã§ããªã‘ã‚Œã°ã€æ—§å½¢å¼ã‚’è©¦ã™ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰
                elif 'prediction' in flow_result and 'predicted_result' in flow_result['prediction']:
                    logger.info("æ—§å½¢å¼ã§ã®å±•é–‹äºˆæƒ³çµæœå–å¾—ã‚’è©¦è¡Œ")
                    for rank_info in flow_result['prediction']['predicted_result']:
                        if 'ä½' in rank_info:
                            parts = rank_info.split(':')
                            if len(parts) >= 2:
                                horse_part = parts[1].strip()
                                horse_name = horse_part.split('(')[0].strip()
                                if horse_name in horses:
                                    top_5_horses.append(horse_name)
                                    if len(top_5_horses) >= 5:
                                        break
            
            # ä¸Šä½é¦¬ãŒå–å¾—ã§ããªã„å ´åˆã¯å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if len(top_5_horses) < 3:
                logger.warning("å±•é–‹äºˆæƒ³ã‹ã‚‰ååˆ†ãªä¸Šä½é¦¬ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
                recommendations = self._generate_betting_recommendations(race_data)
            else:
                # å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‹ã‚‰å…·ä½“çš„ãªè²·ã„ç›®ã‚’ç”Ÿæˆ
                recommendations = self._generate_betting_recommendations_from_top5(
                    top_5_horses, race_data, flow_result
                )
            
            return {
                'status': 'success',
                'type': 'betting_recommendation',
                'venue': venue,
                'total_horses': len(horses),
                'top_5_horses': top_5_horses[:5],  # ä¸Šä½5é ­ã‚’å«ã‚ã‚‹
                'recommendations': recommendations,
                'last_updated': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"é¦¬åˆ¸æ¨å¥¨ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'status': 'error',
                'message': f'é¦¬åˆ¸æ¨å¥¨ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def _generate_betting_recommendations(self, race_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """é¦¬åˆ¸æ¨å¥¨ã‚’ç”Ÿæˆ"""
        try:
            # å„é¦¬ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
            horse_scores = self._calculate_horse_scores(race_data)
            
            # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            sorted_horses = sorted(horse_scores.items(), key=lambda x: x[1]['total_score'], reverse=True)
            
            # æ¨å¥¨é¦¬åˆ¸ã‚’ç”Ÿæˆ
            recommendations = []
            budget = 10000  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆäºˆç®—1ä¸‡å††
            
            if len(sorted_horses) >= 2:
                # æœ¬å‘½é¦¬åˆ¸ï¼ˆä¸Šä½2é ­ã®é¦¬é€£ï¼‰
                top_horses = [sorted_horses[0][0], sorted_horses[1][0]]
                recommendations.append({
                    'type': 'æœ¬å‘½',
                    'ticket_type': 'é¦¬é€£',
                    'horses': top_horses,
                    'confidence': 85,
                    'investment': int(budget * 0.4),
                    'reason': f'{top_horses[0]} Ã— {top_horses[1]}ã®é‰„æ¿æ§‹æˆ'
                })
                
            if len(sorted_horses) >= 4:
                # å¯¾æŠ—é¦¬åˆ¸ï¼ˆ1ä½è»¸ã®3é€£è¤‡ï¼‰
                axis_horse = sorted_horses[0][0]
                target_horses = [sorted_horses[i][0] for i in range(1, 4)]
                recommendations.append({
                    'type': 'å¯¾æŠ—',
                    'ticket_type': '3é€£è¤‡',
                    'horses': [axis_horse] + target_horses,
                    'confidence': 65,
                    'investment': int(budget * 0.35),
                    'reason': f'{axis_horse}è»¸ã®æ‰‹å …ã„çµ„ã¿åˆã‚ã›'
                })
                
            # ç©´ç‹™ã„é¦¬åˆ¸ï¼ˆç‰¹æ®Šæ¡ä»¶ã®é¦¬ã‚’æ¢ã™ï¼‰
            surprise_candidate = self._find_surprise_candidate(sorted_horses, race_data)
            if surprise_candidate and len(sorted_horses) >= 3:
                surprise_horse = surprise_candidate['horse']
                surprise_reason = surprise_candidate['reason']
                recommendations.append({
                    'type': 'ç©´ç‹™ã„',
                    'ticket_type': 'é¦¬é€£',
                    'horses': [sorted_horses[0][0], surprise_horse],
                    'confidence': 25,
                    'investment': int(budget * 0.25),
                    'reason': f'{surprise_horse}ã¯{surprise_reason}'
                })
            
            # äºˆç®—ãŒä½™ã£ãŸå ´åˆã®èª¿æ•´
            total_invested = sum(rec['investment'] for rec in recommendations)
            if total_invested < budget:
                remaining = budget - total_invested
                if recommendations:
                    recommendations[-1]['investment'] += remaining
            
            return recommendations
            
        except Exception as e:
            logger.error(f"é¦¬åˆ¸æ¨å¥¨ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return []
    
    def _format_style_distribution(self, distribution: Dict) -> List[Dict]:
        """è„šè³ªåˆ†å¸ƒã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        result = []
        for style, data in distribution.items():
            if data['count'] > 0:
                result.append({
                    'style': style,
                    'count': data['count'],
                    'horses': data['horses'][:3]  # ä¸Šä½3é ­ã¾ã§
                })
        return result
    
    def _calculate_course_statistics(self, venue: str, distance: int = None, track_type: str = None) -> Dict:
        """ã‚³ãƒ¼ã‚¹çµ±è¨ˆã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®ãƒŠãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é›†è¨ˆï¼‰"""
        venue_code_map = {
            'æ±äº¬': '05', 'ä¸­å±±': '06', 'é˜ªç¥': '09', 'äº¬éƒ½': '08',
            'ä¸­äº¬': '07', 'æ–°æ½Ÿ': '04', 'æœ­å¹Œ': '02', 'å‡½é¤¨': '01',
            'ç¦å³¶': '03', 'å°å€‰': '10'
        }
        
        venue_code = venue_code_map.get(venue, '05')
        
        # é¨æ‰‹åˆ¥ã€è¡€çµ±åˆ¥ã€æ é †åˆ¥ã€è„šè³ªåˆ¥ã®çµ±è¨ˆã‚’é›†è¨ˆ
        jockey_stats = {}
        sire_stats = {}
        post_stats = {'å†…æ ï¼ˆ1-4ï¼‰': {'runs': 0, 'fukusho': 0}, 
                      'ä¸­æ ï¼ˆ5-12ï¼‰': {'runs': 0, 'fukusho': 0},
                      'å¤–æ ï¼ˆ13-18ï¼‰': {'runs': 0, 'fukusho': 0}}
        style_stats = {'é€ƒã’': {'runs': 0, 'fukusho': 0},
                       'å…ˆè¡Œ': {'runs': 0, 'fukusho': 0},
                       'å·®ã—': {'runs': 0, 'fukusho': 0},
                       'è¿½è¾¼': {'runs': 0, 'fukusho': 0}}
        total_races = 0
        
        try:
            # å…¨é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’èµ°æŸ»ã—ã¦é–‹å‚¬å ´åˆ¥ã®çµ±è¨ˆã‚’è¨ˆç®—
            for horse_name, horse_data in self.data_manager.horses_dict.items():
                if not horse_data or 'races' not in horse_data:
                    continue
                
                # å„é¦¬ã®è©²å½“é–‹å‚¬å ´ã§ã®ãƒ¬ãƒ¼ã‚¹ã‚’é›†è¨ˆ
                for race in horse_data.get('races', []):
                    # é–‹å‚¬å ´ã‚³ãƒ¼ãƒ‰ã§ä¸€è‡´ã‚’ç¢ºèªï¼ˆvenue_codeã‚’ä½¿ç”¨ï¼‰
                    if race.get('KEIBAJO_CODE') == venue_code:
                        # distanceã®ãƒã‚§ãƒƒã‚¯ï¼ˆKYORIãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ï¼‰
                        if distance:
                            race_distance = race.get('KYORI')
                            if race_distance:
                                # æ–‡å­—åˆ—ã®å ´åˆã¯æ•°å€¤ã«å¤‰æ›
                                if isinstance(distance, str):
                                    distance_num = int(distance.replace('m', ''))
                                else:
                                    distance_num = distance
                                if abs(int(race_distance) - distance_num) > 100:  # 100mä»¥ä¸Šã®å·®ãŒã‚ã‚Œã°é™¤å¤–
                                    continue
                        
                        # track_typeã®ãƒã‚§ãƒƒã‚¯ï¼ˆTRACK_CODEãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ï¼‰
                        if track_type:
                            track_code = race.get('TRACK_CODE', '')
                            # ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ã‹ã‚‰èŠ/ãƒ€ãƒ¼ãƒˆã‚’åˆ¤å®š
                            # 11-19: èŠ, 21-29: ãƒ€ãƒ¼ãƒˆ
                            if track_type == 'èŠ' and not (11 <= int(track_code) <= 19 if track_code else False):
                                continue
                            if track_type == 'ãƒ€ãƒ¼ãƒˆ' and not (21 <= int(track_code) <= 29 if track_code else False):
                                continue
                        
                        total_races += 1
                        
                        # é¨æ‰‹çµ±è¨ˆ
                        jockey = race.get('KISHUMEI_RYAKUSHO')  # é¨æ‰‹åç•¥ç§°
                        if jockey:
                            if jockey not in jockey_stats:
                                jockey_stats[jockey] = {'runs': 0, 'wins': 0, 'fukusho': 0}
                            jockey_stats[jockey]['runs'] += 1
                            finish = race.get('KAKUTEI_CHAKUJUN')
                            if finish is not None:
                                if finish == 1:
                                    jockey_stats[jockey]['wins'] += 1
                                if finish <= 3:
                                    jockey_stats[jockey]['fukusho'] += 1
                        
                        # è¡€çµ±çµ±è¨ˆï¼ˆç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ï¼‰
                        # TODO: è¡€çµ±ãƒ‡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚ŒãŸã‚‰å®Ÿè£…
                        pass
                        
                        # æ é †çµ±è¨ˆï¼ˆPhase 4ãƒ‡ãƒ¼ã‚¿ãŒæ¬ è½ã—ã¦ã„ã‚‹ãŸã‚ã€ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                        # é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡ã¯å¾Œã§é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‹ã‚‰å–å¾—
                        
                        # è„šè³ªçµ±è¨ˆï¼ˆã‚³ãƒ¼ãƒŠãƒ¼é€šéé †ä½ã‹ã‚‰åˆ¤å®šï¼‰
                        corner1 = race.get('CORNER1_JUNI')
                        if corner1 is not None:
                            if corner1 <= 2:
                                style = 'é€ƒã’'
                            elif corner1 <= 5:
                                style = 'å…ˆè¡Œ'
                            elif corner1 <= 9:
                                style = 'å·®ã—'
                            else:
                                style = 'è¿½è¾¼'
                            if style in style_stats:
                                style_stats[style]['runs'] += 1
                                finish_pos = race.get('KAKUTEI_CHAKUJUN')
                                if finish_pos is not None and finish_pos <= 3:
                                    style_stats[style]['fukusho'] += 1
            
            # é¨æ‰‹çµ±è¨ˆã‚’ãƒªã‚¹ãƒˆå½¢å¼ã«å¤‰æ›ï¼ˆè¤‡å‹ç‡é †ï¼‰
            jockey_list = []
            for name, stats in jockey_stats.items():
                if stats['runs'] >= 5:  # 5å›ä»¥ä¸Šé¨ä¹—ã—ãŸé¨æ‰‹ã®ã¿
                    jockey_list.append({
                        'name': name,
                        'wins': stats['wins'],
                        'runs': stats['runs'],
                        'win_rate': stats['wins'] / stats['runs'] if stats['runs'] > 0 else 0,
                        'fukusho_rate': stats['fukusho'] / stats['runs'] if stats['runs'] > 0 else 0
                    })
            jockey_list.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            # è¡€çµ±çµ±è¨ˆã‚’ãƒªã‚¹ãƒˆå½¢å¼ã«å¤‰æ›ï¼ˆè¤‡å‹ç‡é †ï¼‰
            sire_list = []
            for name, stats in sire_stats.items():
                if stats['runs'] >= 10:  # 10é ­ä»¥ä¸Šã®ç”£é§’ãŒå‡ºèµ°
                    sire_list.append({
                        'name': name,
                        'runs': stats['runs'],
                        'fukusho_rate': stats['fukusho'] / stats['runs'] if stats['runs'] > 0 else 0
                    })
            sire_list.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‹ã‚‰æ é †åˆ¥è¤‡å‹ç‡ã‚’å–å¾—ï¼ˆä¸Šä½é¨æ‰‹ã®ã¿ï¼‰
            top_jockeys = [j['name'] for j in jockey_list[:10]]
            if top_jockeys:
                jockey_post_stats = self.jockey_manager.get_jockey_post_position_fukusho_rates(top_jockeys)
                
                # é›†è¨ˆã—ã¦å¹³å‡ã‚’è¨ˆç®—
                aggregated_post_stats = {
                    'å†…æ ï¼ˆ1-6ï¼‰': {'fukusho_rate': 0, 'race_count': 0, 'jockey_count': 0},
                    'ä¸­æ ï¼ˆ7-12ï¼‰': {'fukusho_rate': 0, 'race_count': 0, 'jockey_count': 0},
                    'å¤–æ ï¼ˆ13-18ï¼‰': {'fukusho_rate': 0, 'race_count': 0, 'jockey_count': 0}
                }
                
                for jockey_name, jockey_post_data in jockey_post_stats.items():
                    for category, stats in jockey_post_data.items():
                        if stats['race_count'] > 0:
                            prev_count = aggregated_post_stats[category]['race_count']
                            prev_rate = aggregated_post_stats[category]['fukusho_rate']
                            new_count = stats['race_count']
                            new_rate = stats['fukusho_rate']
                            
                            # é‡ã¿ä»˜ãå¹³å‡
                            total_count = prev_count + new_count
                            if total_count > 0:
                                aggregated_post_stats[category]['fukusho_rate'] = (
                                    (prev_rate * prev_count + new_rate * new_count) / total_count
                                )
                                aggregated_post_stats[category]['race_count'] = total_count
                                aggregated_post_stats[category]['jockey_count'] += 1
                
                # post_statsã‚’é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã«ç½®ãæ›ãˆ
                post_stats = aggregated_post_stats
            
            # è„šè³ªçµ±è¨ˆã«å‹ç‡ãƒ»è¤‡å‹ç‡ã‚’è¿½åŠ 
            for key in style_stats:
                runs = style_stats[key]['runs']
                if runs > 0:
                    style_stats[key]['fukusho_rate'] = style_stats[key]['fukusho'] / runs
                else:
                    style_stats[key]['fukusho_rate'] = 0
            
            return {
                'jockey_stats': jockey_list[:10],  # ä¸Šä½10å
                'sire_stats': sire_list[:10],      # ä¸Šä½10é ­
                'post_stats': post_stats,
                'style_stats': style_stats,
                'total_races': total_races
            }
            
        except Exception as e:
            logger.warning(f"ã‚³ãƒ¼ã‚¹çµ±è¨ˆã®è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'jockey_stats': [],
                'sire_stats': [],
                'post_stats': {},
                'style_stats': {},
                'total_races': 0
            }
    
    def _calculate_daily_prediction(self, date: str, venue: str, race_data: Dict[str, Any] = None) -> Dict:
        """å½“æ—¥ã®å‚¾å‘ã‚’äºˆæƒ³ï¼ˆå®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ï¼‰"""
        # race_dataãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã¯ã€ãã®ãƒ¬ãƒ¼ã‚¹ã®å‡ºèµ°é¦¬ãƒ»é¨æ‰‹ã‹ã‚‰å‚¾å‘ã‚’äºˆæƒ³
        if race_data:
            return self._predict_from_race_data(venue, race_data)
        # race_dataãŒãªã„å ´åˆã¯ã€ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é–‹å‚¬å ´ã®ä¸€èˆ¬çš„ãªå‚¾å‘ã‚’äºˆæƒ³
        return self._predict_from_knowledge(venue)
    
    def _predict_from_race_data(self, venue: str, race_data: Dict[str, Any]) -> Dict:
        """ç‰¹å®šãƒ¬ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å½“æ—¥å‚¾å‘ã‚’äºˆæƒ³"""
        horses = race_data.get('horses', [])
        jockeys = race_data.get('jockeys', [])
        
        # è„šè³ªå‚¾å‘ã‚’äºˆæƒ³
        style_prediction = self._predict_style_trend(horses)
        
        # é¨æ‰‹å‚¾å‘ã‚’äºˆæƒ³
        jockey_prediction = self._predict_jockey_trend(venue, jockeys)
        
        # æ é †å‚¾å‘ã‚’äºˆæƒ³ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‚’æ´»ç”¨ï¼‰
        post_prediction = self._predict_post_trend(venue, jockeys)
        
        return {
            'style_performance': style_prediction,
            'hot_jockeys': jockey_prediction,
            'post_trend': post_prediction,
            'track_condition': 'è‰¯',
            'track_bias': self._predict_track_bias(post_prediction),
            'races_completed': 0
        }
    
    def _predict_from_knowledge(self, venue: str) -> Dict:
        """ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ä¸€èˆ¬çš„ãªå‚¾å‘ã‚’äºˆæƒ³"""
        # _calculate_course_statisticsã‚’æ´»ç”¨
        course_stats = self._calculate_course_statistics(venue)
        
        return {
            'style_performance': course_stats.get('style_stats', {}),
            'hot_jockeys': course_stats.get('jockey_stats', [])[:3],
            'post_trend': course_stats.get('post_stats', {}),
            'track_condition': 'è‰¯',
            'track_bias': 'ãƒ•ãƒ©ãƒƒãƒˆ',
            'races_completed': 0
        }
    
    def _predict_style_trend(self, horses: List[str]) -> Dict:
        """å‡ºèµ°é¦¬ã‹ã‚‰è„šè³ªå‚¾å‘ã‚’äºˆæƒ³"""
        style_counts = {'é€ƒã’': 0, 'å…ˆè¡Œ': 0, 'å·®ã—': 0, 'è¿½è¾¼': 0}
        
        for horse_name in horses:
            horse_data = self.data_manager.get_horse_data(horse_name)
            if horse_data and 'races' in horse_data:
                style = self.style_analyzer.classify_basic_style(horse_data['races'])
                if style in style_counts:
                    style_counts[style] += 1
        
        # å‚¾å‘ã‚’åˆ¤å®š
        total = sum(style_counts.values())
        style_performance = {}
        for style, count in style_counts.items():
            style_performance[style] = {
                'runs': count,
                'ratio': count / total if total > 0 else 0
            }
        
        return style_performance
    
    def _predict_jockey_trend(self, venue: str, jockeys: List[str]) -> List[Dict]:
        """é¨æ‰‹ãƒªã‚¹ãƒˆã‹ã‚‰å¥½èª¿é¨æ‰‹ã‚’äºˆæƒ³"""
        jockey_stats = []
        
        if not jockeys or not self.jockey_manager.is_loaded():
            return jockey_stats
        
        # å„é¨æ‰‹ã®æˆç¸¾ã‚’å–å¾—ï¼ˆæ­£è¦åŒ–ã—ã¦ã‹ã‚‰æ¤œç´¢ï¼‰
        for jockey_name in jockeys:
            # é¨æ‰‹åã‚’æ­£è¦åŒ–
            normalized_name = self._normalize_jockey_name(jockey_name)
            jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
            
            # jockey_dataãŒdictã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
            if jockey_data and isinstance(jockey_data, dict):
                # é¨æ‰‹ã®ç·åˆæˆç¸¾ã‚’å–å¾—
                overall_stats = jockey_data.get('overall_stats', {})
                if overall_stats:
                    jockey_stats.append({
                        'name': jockey_name,  # å…ƒã®åå‰ã‚’è¡¨ç¤ºç”¨ã«ä½¿ç”¨
                        'results': f"{overall_stats.get('total_races_analyzed', 0)}æˆ¦",
                        'fukusho_rate': overall_stats.get('overall_fukusho_rate', 0) / 100,  # ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆã‚’å°æ•°ã«
                        'venue_course_stats': jockey_data.get('venue_course_stats', {})
                    })
            else:
                logger.warning(f"é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯ç„¡åŠ¹: {jockey_name} â†’ {normalized_name}")
        
        # è¤‡å‹ç‡é †ã«ã‚½ãƒ¼ãƒˆ
        jockey_stats.sort(key=lambda x: x['fukusho_rate'], reverse=True)
        
        return jockey_stats
    
    def _predict_post_trend(self, venue: str, jockeys: List[str] = None) -> Dict:
        """é–‹å‚¬å ´ã®æ é †å‚¾å‘ã‚’äºˆæƒ³ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‚’æ´»ç”¨ï¼‰"""
        if jockeys and self.jockey_manager.is_loaded():
            # é¨æ‰‹åã‚’æ­£è¦åŒ–ã—ã¦ã‹ã‚‰æ é †åˆ¥è¤‡å‹ç‡ã‚’å–å¾—
            normalized_jockeys = [self._normalize_jockey_name(j) for j in jockeys]
            jockey_post_stats = self.jockey_manager.get_jockey_post_position_fukusho_rates(normalized_jockeys)
            
            # é›†è¨ˆ
            aggregated_stats = {
                'å†…æ ï¼ˆ1-6ï¼‰': {'fukusho_rate': 0, 'race_count': 0},
                'ä¸­æ ï¼ˆ7-12ï¼‰': {'fukusho_rate': 0, 'race_count': 0},
                'å¤–æ ï¼ˆ13-18ï¼‰': {'fukusho_rate': 0, 'race_count': 0}
            }
            
            for jockey_name, jockey_data in jockey_post_stats.items():
                for category, stats in jockey_data.items():
                    if stats['race_count'] > 0:
                        prev_count = aggregated_stats[category]['race_count']
                        prev_rate = aggregated_stats[category]['fukusho_rate']
                        new_count = stats['race_count']
                        new_rate = stats['fukusho_rate']
                        
                        total_count = prev_count + new_count
                        if total_count > 0:
                            aggregated_stats[category]['fukusho_rate'] = (
                                (prev_rate * prev_count + new_rate * new_count) / total_count
                            )
                            aggregated_stats[category]['race_count'] = total_count
            
            return aggregated_stats
        else:
            # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯å¾“æ¥ã®æ–¹æ³•
            course_stats = self._calculate_course_statistics(venue)
            return course_stats.get('post_stats', {})
    
    def _predict_track_bias(self, post_trend: Dict) -> str:
        """æ é †å‚¾å‘ã‹ã‚‰ãƒˆãƒ©ãƒƒã‚¯ãƒã‚¤ã‚¢ã‚¹ã‚’äºˆæƒ³"""
        if not post_trend:
            return 'ãƒ•ãƒ©ãƒƒãƒˆ'
        
        # ãƒ™ã‚¤ã‚ºè£œæ­£ã‚’é©ç”¨ï¼ˆå†…æ ã¯1-6ã€å¤–æ ã¯13-18ï¼‰
        outer_rate = post_trend.get('å¤–æ ï¼ˆ13-18ï¼‰', {}).get('fukusho_rate', 0)
        inner_rate = post_trend.get('å†…æ ï¼ˆ1-6ï¼‰', {}).get('fukusho_rate', 0)
        
        if outer_rate > 0.4:
            return 'å¤–æœ‰åˆ©'
        elif inner_rate > 0.4:
            return 'å†…æœ‰åˆ©'
        return 'ãƒ•ãƒ©ãƒƒãƒˆ'
    
    def _generate_daily_prediction_text(self, daily_stats: Dict, venue: str) -> str:
        """å½“æ—¥å‚¾å‘ã®è©³ç´°ãªäºˆæƒ³æ–‡ç« ã‚’ç”Ÿæˆ"""
        lines = []
        lines.append(f"## æœ¬æ—¥ã®{venue}å‚¾å‘äºˆæƒ³")
        lines.append("")
        
        # è„šè³ªå‚¾å‘ã®è©³ç´°åˆ†æ
        style_perf = daily_stats.get('style_performance', {})
        if style_perf:
            lines.append("### è„šè³ªåˆ¥äºˆæƒ³")
            # çµ±è¨ˆã‚’æ•´ç†
            sorted_styles = sorted(style_perf.items(), key=lambda x: x[1].get('ratio', 0), reverse=True)
            
            for style, data in sorted_styles:
                if data.get('runs', 0) > 0:
                    ratio = data.get('ratio', 0)
                    lines.append(f"- **{style}**: {data['runs']}é ­ (æ§‹æˆæ¯” {ratio*100:.1f}%)")
            
            # æœ€ã‚‚æœ‰åˆ©ãªè„šè³ªã‚’åˆ¤å®š
            best_style = max(style_perf.items(), key=lambda x: x[1].get('ratio', 0))
            if best_style[1].get('ratio', 0) > 0.3:
                lines.append("")
                lines.append(f"**äºˆæƒ³**: {best_style[0]}é¦¬ãŒ{best_style[1]['runs']}é ­ã¨å¤šãã€ãƒšãƒ¼ã‚¹ãŒ{'é€Ÿã' if best_style[0] in ['é€ƒã’', 'å…ˆè¡Œ'] else 'è½ã¡ç€ã„ãŸå±•é–‹ã«'}ãªã‚Šãã†ã§ã™ã€‚")
        
        lines.append("")
        
        # å¥½èª¿é¨æ‰‹ã®è©³ç´°
        hot_jockeys = daily_stats.get('hot_jockeys', [])
        if hot_jockeys:
            lines.append("### æ³¨ç›®é¨æ‰‹")
            for i, jockey in enumerate(hot_jockeys[:3], 1):
                lines.append(f"{i}. **{jockey['name']}** - è¤‡å‹ç‡ {jockey['fukusho_rate']*100:.1f}% ({jockey.get('results', 'ãƒ‡ãƒ¼ã‚¿ãªã—')})")
            
            if hot_jockeys[0]['fukusho_rate'] > 0.5:
                lines.append("")
                lines.append(f"ç‰¹ã«**{hot_jockeys[0]['name']}é¨æ‰‹**ã¯è¤‡å‹ç‡{hot_jockeys[0]['fukusho_rate']*100:.1f}%ã¨çµ¶å¥½èª¿ã§ã™ã€‚")
        
        lines.append("")
        
        # æ é †å‚¾å‘ã®è©³ç´°
        lines.append("### æ é †å‚¾å‘")
        post_trend = daily_stats.get('post_trend', {})
        if post_trend:
            for position, stats in post_trend.items():
                fukusho_rate = stats.get('fukusho_rate', 0)
                race_count = stats.get('race_count', 0)
                if race_count > 0:
                    lines.append(f"- {position}: è¤‡å‹ç‡ **{fukusho_rate:.1f}%** ({race_count}ãƒ¬ãƒ¼ã‚¹)")
        
        # ãƒˆãƒ©ãƒƒã‚¯ãƒã‚¤ã‚¢ã‚¹åˆ¤å®š
        track_bias = daily_stats.get('track_bias', 'ãƒ•ãƒ©ãƒƒãƒˆ')
        lines.append("")
        if track_bias == 'å¤–æœ‰åˆ©':
            lines.append("**ãƒã‚¤ã‚¢ã‚¹**: å¤–æ æœ‰åˆ© - å¤–å›ã‚Šã‚³ãƒ¼ã‚¹ã§å·®ã—é¦¬ãŒå°é ­ã—ã‚„ã™ã„å‚¾å‘")
        elif track_bias == 'å†…æœ‰åˆ©':
            lines.append("**ãƒã‚¤ã‚¢ã‚¹**: å†…æ æœ‰åˆ© - å†…ãƒ©ãƒæ²¿ã„ãŒä¼¸ã³ã‚‹é¦¬å ´çŠ¶æ…‹")
        else:
            lines.append("**ãƒã‚¤ã‚¢ã‚¹**: ãƒ•ãƒ©ãƒƒãƒˆ - æ é †ã«ã‚ˆã‚‹æœ‰åˆ©ä¸åˆ©ã¯å°‘ãªã„")
        
        lines.append("")
        lines.append("---")
        
        return "\n".join(lines)
    
    def _calculate_daily_statistics(self, date: str, venue: str) -> Dict:
        """å½“æ—¥çµ±è¨ˆã‚’è¨ˆç®—ï¼ˆå®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰äºˆæƒ³ï¼‰"""
        # å®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å½“æ—¥ã®å‚¾å‘ã‚’äºˆæƒ³
        # ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©²å½“é–‹å‚¬å ´ã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æ
        
        # åˆæœŸåŒ–
        statistics = {
            'style_performance': {},
            'hot_jockeys': [],
            'post_trend': {},
            'track_condition': 'è‰¯',
            'track_bias': 'ãƒ•ãƒ©ãƒƒãƒˆ',
            'races_completed': 0
        }
        
        try:
            # ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é–‹å‚¬å ´åˆ¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’é›†è¨ˆ
            # å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿åˆ†æã‚’å®Ÿè£…ï¼ˆä»®å®Ÿè£…ã‚’å®Ÿãƒ‡ãƒ¼ã‚¿ã«ç½®ãæ›ãˆã‚‹å¿…è¦ï¼‰
            # TODO: å®Ÿéš›ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é›†è¨ˆã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
            return statistics
            
        except Exception as e:
            logger.warning(f"å½“æ—¥çµ±è¨ˆã®è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
            return statistics
    
    def _generate_course_insights(self, stats: Dict) -> List[str]:
        """ã‚³ãƒ¼ã‚¹å‚¾å‘ã‹ã‚‰ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’ç”Ÿæˆ"""
        insights = []
        
        # é¨æ‰‹å‚¾å‘
        if stats.get('jockey_stats'):
            top_jockey = stats['jockey_stats'][0]
            insights.append(f"é¨æ‰‹ã¯{top_jockey['name']}ãŒè¤‡å‹ç‡{top_jockey['fukusho_rate']:.0%}ã§æœ€ã‚‚å¥½æˆç¸¾")
        
        # æ é †å‚¾å‘
        post_stats = stats.get('post_stats', {})
        if 'ä¸­æ ï¼ˆ5-12ï¼‰' in post_stats:
            insights.append("ä¸­æ ã®è¤‡å‹ç‡ãŒé«˜ãæœ‰åˆ©ãªå‚¾å‘")
        
        # è„šè³ªå‚¾å‘
        style_stats = stats.get('style_stats', {})
        if style_stats.get('å…ˆè¡Œ', {}).get('win_rate', 0) > 0.18:
            insights.append("å…ˆè¡Œé¦¬ãŒæœ‰åˆ©ãªã‚³ãƒ¼ã‚¹")
        
        return insights
    
    def _generate_daily_recommendations(self, stats: Dict) -> List[str]:
        """å½“æ—¥çµ±è¨ˆã‹ã‚‰æ¨å¥¨äº‹é …ã‚’ç”Ÿæˆ"""
        recommendations = []
        
        # é¨æ‰‹æ¨å¥¨
        hot_jockeys = stats.get('hot_jockeys', [])
        if hot_jockeys:
            top_jockey = hot_jockeys[0]
            recommendations.append(f"{top_jockey['name']}é¨æ‰‹ã®é¨ä¹—é¦¬ã¯è¦æ³¨ç›®")
        
        # è„šè³ªæ¨å¥¨
        style_stats = stats.get('style_stats', {})
        best_style = max(style_stats.items(), key=lambda x: x[1].get('fukusho_rate', 0), default=None)
        if best_style and best_style[1].get('fukusho_rate', 0) > 0.3:
            recommendations.append(f"{best_style[0]}é¦¬ä¸­å¿ƒã®é¦¬åˆ¸æ§‹æˆ")
        
        return recommendations
    
    def _calculate_horse_scores(self, race_data: Dict[str, Any]) -> Dict[str, Dict]:
        """å„é¦¬ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—"""
        horses = race_data.get('horses', [])
        jockeys = race_data.get('jockeys', [])
        posts = race_data.get('posts', [])
        venue = race_data.get('venue', '')
        
        horse_scores = {}
        
        for i, horse_name in enumerate(horses):
            try:
                # ViewLogicãƒ™ãƒ¼ã‚¹ã‚¹ã‚³ã‚¢ï¼ˆé¦¬ã®åŸºæœ¬ã‚¹ã‚³ã‚¢ï¼‰
                horse_data = self.data_manager.get_horse_data(horse_name)
                base_score = 50.0  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚³ã‚¢
                
                if horse_data and 'running_style' in horse_data:
                    style_data = horse_data['running_style']
                    # ã‚¹ã‚¿ã‚¤ãƒ«è©•ä¾¡ã‹ã‚‰åŸºæœ¬ç‚¹ã‚’ç®—å‡º
                    if isinstance(style_data, dict):
                        confidence = style_data.get('confidence', 0.5)
                        base_score = 50 + (confidence * 30)  # 50-80ç‚¹ã®ç¯„å›²
                
                # é¨æ‰‹ã‚¹ã‚³ã‚¢åŠ ç®—
                jockey_bonus = 0
                if i < len(jockeys) and self.jockey_manager.is_loaded():
                    jockey_name = self._normalize_jockey_name(jockeys[i])
                    jockey_data = self.jockey_manager.get_jockey_data(jockey_name)
                    if jockey_data and isinstance(jockey_data, dict):
                        overall_stats = jockey_data.get('overall_stats', {})
                        fukusho_rate = overall_stats.get('overall_fukusho_rate', 0)
                        jockey_bonus = (fukusho_rate / 100) * 20  # æœ€å¤§20ç‚¹åŠ ç®—
                
                # æ é †ãƒœãƒ¼ãƒŠã‚¹ï¼ˆå†…æ æœ‰åˆ©ãªã©ï¼‰
                post_bonus = 0
                if i < len(posts):
                    post = posts[i]
                    if 1 <= post <= 6:
                        post_bonus = 5
                    elif 7 <= post <= 12:
                        post_bonus = 2
                    # å¤–æ ï¼ˆ13-18ï¼‰ã¯åŠ ç®—ãªã—
                
                # æœ€çµ‚ã‚¹ã‚³ã‚¢
                total_score = base_score + jockey_bonus + post_bonus
                
                horse_scores[horse_name] = {
                    'total_score': min(total_score, 100),  # 100ç‚¹ä¸Šé™
                    'base_score': base_score,
                    'jockey_bonus': jockey_bonus,
                    'post_bonus': post_bonus,
                    'jockey': jockeys[i] if i < len(jockeys) else 'ä¸æ˜',
                    'post': posts[i] if i < len(posts) else 0
                }
                
            except Exception as e:
                logger.error(f"é¦¬{horse_name}ã®ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼: {e}")
                horse_scores[horse_name] = {
                    'total_score': 50.0,
                    'base_score': 50.0,
                    'jockey_bonus': 0,
                    'post_bonus': 0,
                    'jockey': jockeys[i] if i < len(jockeys) else 'ä¸æ˜',
                    'post': posts[i] if i < len(posts) else 0
                }
        
        return horse_scores
    
    def _find_surprise_candidate(self, sorted_horses: List, race_data: Dict[str, Any]) -> Dict:
        """ç©´é¦¬å€™è£œã‚’æ¢ã™"""
        if len(sorted_horses) < 6:
            return None
            
        # ä¸­ä½ã‹ã‚‰ä¸‹ä½ã®é¦¬ï¼ˆ4-8ä½ï¼‰ã§ç‰¹æ®Šæ¡ä»¶ã®ã‚ã‚‹é¦¬ã‚’æ¢ã™
        candidates = sorted_horses[3:8] if len(sorted_horses) >= 8 else sorted_horses[3:]
        
        for horse_name, horse_data in candidates:
            # é¨æ‰‹ãŒå¥½èª¿
            jockey = horse_data.get('jockey', '')
            if self._is_hot_jockey(jockey):
                return {
                    'horse': horse_name,
                    'reason': f'{jockey}é¨æ‰‹ã®å¥½èª¿'
                }
            
            # å†…æ ã§é€ƒã’ãƒ»å…ˆè¡Œ
            if horse_data.get('post', 0) <= 6:
                horse_viewlogic_data = self.data_manager.get_horse_data(horse_name)
                if horse_viewlogic_data and 'running_style' in horse_viewlogic_data:
                    style_data = horse_viewlogic_data['running_style']
                    if isinstance(style_data, dict) and style_data.get('style') in ['é€ƒã’', 'å…ˆè¡Œ']:
                        return {
                            'horse': horse_name,
                            'reason': f'å†…æ {horse_data["post"]}ç•ªã‹ã‚‰ã®{style_data["style"]}'
                        }
        
        # è©²å½“ãªã—ã®å ´åˆã¯6ä½ã®é¦¬ã‚’è¿”ã™
        if len(sorted_horses) >= 6:
            return {
                'horse': sorted_horses[5][0],
                'reason': 'ä¸­ç©´å€™è£œ'
            }
        
        return None
    
    def _get_surprise_reason(self, horse_name: str, race_data: Dict[str, Any]) -> str:
        """ç©´é¦¬ã®ç†ç”±ã‚’å–å¾—"""
        horse_viewlogic_data = self.data_manager.get_horse_data(horse_name)
        if horse_viewlogic_data and 'running_style' in horse_viewlogic_data:
            style_data = horse_viewlogic_data['running_style']
            if isinstance(style_data, dict):
                return f"{style_data.get('style', 'ä¸æ˜')}ã‚¿ã‚¤ãƒ—ã®ç©´é¦¬"
        return "ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã«ã‚ˆã‚‹ç©´é¦¬"
    
    def _is_hot_jockey(self, jockey_name: str) -> bool:
        """é¨æ‰‹ãŒå¥½èª¿ã‹ã©ã†ã‹åˆ¤å®š"""
        if not jockey_name or not self.jockey_manager.is_loaded():
            return False
            
        normalized_name = self._normalize_jockey_name(jockey_name)
        jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
        
        if jockey_data and isinstance(jockey_data, dict):
            overall_stats = jockey_data.get('overall_stats', {})
            fukusho_rate = overall_stats.get('overall_fukusho_rate', 0)
            return fukusho_rate > 40  # 40%ä»¥ä¸Šã‚’å¥½èª¿ã¨ã¿ãªã™
        
        return False
    
    def _generate_betting_recommendations_from_top5(
        self, 
        top_5_horses: List[str], 
        race_data: Dict[str, Any],
        flow_result: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‹ã‚‰å®Ÿè·µçš„ãªé¦¬åˆ¸è²·ã„ç›®ã‚’ç”Ÿæˆ
        
        Args:
            top_5_horses: å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­
            race_data: ãƒ¬ãƒ¼ã‚¹æƒ…å ±
            flow_result: å±•é–‹äºˆæƒ³çµæœ
        
        Returns:
            æ¨å¥¨é¦¬åˆ¸ãƒªã‚¹ãƒˆ
        """
        try:
            recommendations = []
            budget = 10000  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆäºˆç®—1ä¸‡å††
            
            # æœ€ä½3é ­ã¯å¿…è¦
            if len(top_5_horses) < 3:
                return []
            
            # 1. å˜å‹ï¼ˆ1ä½ã®é¦¬ï¼‰
            if len(top_5_horses) >= 1:
                recommendations.append({
                    'type': 'å˜å‹',
                    'ticket_type': 'å˜å‹',
                    'horses': [top_5_horses[0]],
                    'confidence': 75,
                    'investment': int(budget * 0.2),  # 20%
                    'reason': f'ViewLogicå±•é–‹äºˆæƒ³1ä½ã®{top_5_horses[0]}',
                    'buy_type': 'ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆ'
                })
            
            # 2. é¦¬é€£BOXï¼ˆä¸Šä½3é ­ï¼‰
            if len(top_5_horses) >= 3:
                box_horses = top_5_horses[:3]
                recommendations.append({
                    'type': 'é¦¬é€£BOX',
                    'ticket_type': 'é¦¬é€£',
                    'horses': box_horses,
                    'confidence': 65,
                    'investment': int(budget * 0.25),  # 25%
                    'reason': f'ä¸Šä½3é ­ï¼ˆ{", ".join(box_horses)}ï¼‰ã®BOXè²·ã„',
                    'buy_type': 'BOX',
                    'combinations': 3  # 3é ­BOXã¯3é€šã‚Š
                })
            
            # 3. 3é€£å˜1ç€æµã—ï¼ˆ1ä½è»¸ã€2-3ä½ã‹ã‚‰2ç€ã€4-5ä½ã‹ã‚‰3ç€ï¼‰
            if len(top_5_horses) >= 4:
                first = top_5_horses[0]
                second_candidates = top_5_horses[1:3]  # 2-3ä½
                third_candidates = top_5_horses[2:min(5, len(top_5_horses))]  # 3-5ä½
                
                recommendations.append({
                    'type': '3é€£å˜æµã—',
                    'ticket_type': '3é€£å˜',
                    'horses': {
                        '1ç€': [first],
                        '2ç€': second_candidates,
                        '3ç€': third_candidates
                    },
                    'confidence': 45,
                    'investment': int(budget * 0.25),  # 25%
                    'reason': f'{first}ã®1ç€å›ºå®šã€2-3ç€æµã—',
                    'buy_type': 'æµã—',
                    'combinations': len(second_candidates) * len(third_candidates)
                })
            
            # 4. ãƒ¯ã‚¤ãƒ‰ï¼ˆ1ä½ã¨2-3ä½ã®çµ„ã¿åˆã‚ã›ï¼‰
            if len(top_5_horses) >= 3:
                axis = top_5_horses[0]
                partners = top_5_horses[1:3]
                recommendations.append({
                    'type': 'ãƒ¯ã‚¤ãƒ‰',
                    'ticket_type': 'ãƒ¯ã‚¤ãƒ‰',
                    'horses': {
                        'è»¸': axis,
                        'ç›¸æ‰‹': partners
                    },
                    'confidence': 80,
                    'investment': int(budget * 0.15),  # 15%
                    'reason': f'{axis}è»¸ã®ãƒ¯ã‚¤ãƒ‰ã€ç¢ºå®Ÿæ€§é‡è¦–',
                    'buy_type': 'è»¸æµã—',
                    'combinations': len(partners)
                })
            
            # 5. 3é€£è¤‡ï¼ˆä¸Šä½4é ­BOXï¼‰- ç©´ç‹™ã„
            if len(top_5_horses) >= 4:
                box_horses = top_5_horses[:4]
                recommendations.append({
                    'type': '3é€£è¤‡BOX',
                    'ticket_type': '3é€£è¤‡',
                    'horses': box_horses,
                    'confidence': 55,
                    'investment': int(budget * 0.15),  # 15%
                    'reason': f'ä¸Šä½4é ­ã®BOXã€é…å½“ç‹™ã„',
                    'buy_type': 'BOX',
                    'combinations': 4  # 4é ­ã‹ã‚‰3é ­é¸ã¶çµ„ã¿åˆã‚ã›
                })
            
            # ãƒšãƒ¼ã‚¹åˆ¤å®šã‚’è¿½åŠ æƒ…å ±ã¨ã—ã¦ä»˜ä¸
            pace_info = ""
            if flow_result and 'pace' in flow_result:
                pace_data = flow_result['pace']
                if 'predicted_pace' in pace_data:
                    pace_info = f"ï¼ˆäºˆæƒ³ãƒšãƒ¼ã‚¹: {pace_data['predicted_pace']}ï¼‰"
            
            # å„æ¨å¥¨ã«ãƒšãƒ¼ã‚¹æƒ…å ±ã‚’è¿½åŠ 
            for rec in recommendations:
                if pace_info and 'ç†ç”±' in rec:
                    rec['reason'] += pace_info
            
            return recommendations
            
        except Exception as e:
            logger.error(f"å±•é–‹äºˆæƒ³ãƒ™ãƒ¼ã‚¹ã®é¦¬åˆ¸ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¾“æ¥ã®æ–¹æ³•ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return self._generate_betting_recommendations(race_data)

    # =====================================
    # ViewLogicå‚¾å‘åˆ†æï¼š4é …ç›®åˆ†æãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
    # =====================================

    def _analyze_horses_course_performance(self, horses: List[str], venue: str, distance: int, track_type: str) -> List[Dict]:
        """
        1. å‡ºå ´ã™ã‚‹é¦¬å…¨ã¦ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡ã‚’åˆ†æ
        
        Args:
            horses: å‡ºå ´é¦¬åãƒªã‚¹ãƒˆ
            venue: é–‹å‚¬å ´ï¼ˆæ–°æ½Ÿã€æ±äº¬ãªã©ï¼‰
            distance: è·é›¢ï¼ˆ1800ãªã©ï¼‰
            track_type: ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼ˆèŠã€ãƒ€ãƒ¼ãƒˆãªã©ï¼‰
            
        Returns:
            å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ãƒªã‚¹ãƒˆ
        """
        horse_performances = []
        
        # horsesãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
        logger.info(f"_analyze_horses_course_performance called with horses type: {type(horses)}, value: {horses}")
        if not isinstance(horses, list):
            logger.error(f"horses ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(horses)}")
            return []
        
        course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
        
        # é–‹å‚¬å ´ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
        venue_codes = {
            'æœ­å¹Œ': '01', 'å‡½é¤¨': '02', 'ç¦å³¶': '03', 'æ–°æ½Ÿ': '04',
            'æ±äº¬': '05', 'ä¸­å±±': '06', 'ä¸­äº¬': '07', 'äº¬éƒ½': '08',
            'é˜ªç¥': '09', 'å°å€‰': '10'
        }
        venue_code = venue_codes.get(venue, '')
        
        try:
            logger.info(f"é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æé–‹å§‹: {len(horses)}é ­, venue_code={venue_code}, distance={distance}")
            logger.info(f"data_manager loaded: {self.data_manager.is_loaded()}, total_horses: {self.data_manager.get_total_horses()}")
            
            for item in horses:
                # itemãŒæ–‡å­—åˆ—ï¼ˆé¦¬åï¼‰ã§ãªã„å ´åˆã®å‡¦ç†
                if not isinstance(item, str):
                    logger.error(f"é¦¬åãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(item)}, value={item}")
                    continue
                    
                horse_name = item
                horse_data = self.data_manager.get_horse_data(horse_name)
                
                # horse_dataã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
                if not isinstance(horse_data, dict):
                    logger.error(f"é¦¬ {horse_name} ã®ãƒ‡ãƒ¼ã‚¿ãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(horse_data)}, value={horse_data}")
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'fukusho_count': 0,
                        'fukusho_rate': 0.0,
                        'status': 'invalid_data_type'
                    })
                    continue
                
                if not horse_data or 'races' not in horse_data:
                    logger.debug(f"é¦¬ãƒ‡ãƒ¼ã‚¿ãªã—: {horse_name}")
                    # ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯è¨˜éŒ²ã—ã¦ãŠã
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'fukusho_count': 0,
                        'fukusho_rate': 0.0,
                        'status': 'no_data'
                    })
                    continue
                
                # è©²å½“ã‚³ãƒ¼ã‚¹ã®ãƒ¬ãƒ¼ã‚¹ã‚’é›†è¨ˆ
                course_runs = 0
                course_fukusho = 0
                
                races_data = horse_data.get('races', [])
                # racesãŒæ­£ã—ã„å½¢å¼ã‹ãƒã‚§ãƒƒã‚¯
                if not isinstance(races_data, list):
                    logger.error(f"é¦¬ {horse_name} ã®racesãƒ‡ãƒ¼ã‚¿ãŒé…åˆ—ã§ã¯ãªã„: {type(races_data)}")
                    continue
                    
                for race in races_data:
                    # raceãŒè¾æ›¸ã‹ãƒã‚§ãƒƒã‚¯
                    if not isinstance(race, dict):
                        logger.error(f"é¦¬ {horse_name} ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ãŒè¾æ›¸ã§ã¯ãªã„: {type(race)} = {race}")
                        continue
                        
                    # é–‹å‚¬å ´ãƒã‚§ãƒƒã‚¯
                    if race.get('KEIBAJO_CODE') != venue_code:
                        continue
                    
                    # è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆÂ±100mè¨±å®¹ï¼‰
                    if distance:
                        race_distance = race.get('KYORI')
                        if race_distance:
                            try:
                                if abs(int(race_distance) - distance) > 100:
                                    continue
                            except (ValueError, TypeError):
                                continue
                    
                    # ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼šãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ã‹ã‚‰æ¨å®šï¼‰
                    track_code = race.get('TRACK_CODE', '')
                    if track_code:
                        try:
                            track_code_num = int(track_code)
                            # 11-19: èŠ, 21-29: ãƒ€ãƒ¼ãƒˆ
                            if track_type == 'èŠ' and not (11 <= track_code_num <= 19):
                                continue
                            if track_type == 'ãƒ€ãƒ¼ãƒˆ' and not (21 <= track_code_num <= 29):
                                continue
                        except (ValueError, TypeError):
                            pass
                    
                    course_runs += 1
                    
                    # è¤‡å‹åˆ¤å®šï¼ˆ3ç€ä»¥å†…ï¼‰
                    finish = race.get('KAKUTEI_CHAKUJUN')
                    if finish is not None:
                        try:
                            if int(finish) <= 3:
                                course_fukusho += 1
                        except (ValueError, TypeError):
                            pass
                
                # æˆç¸¾ã‚’ã¾ã¨ã‚ã‚‹
                if course_runs > 0:
                    fukusho_rate = course_fukusho / course_runs
                    logger.info(f"é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ã‚ã‚Š: {horse_name}, {course_runs}æˆ¦, è¤‡å‹ç‡{fukusho_rate:.1%}")
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': course_runs,
                        'fukusho_count': course_fukusho,
                        'fukusho_rate': fukusho_rate,
                        'status': 'found'
                    })
                else:
                    horse_performances.append({
                        'horse_name': horse_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'fukusho_count': 0,
                        'fukusho_rate': 0.0,
                        'status': 'no_course_data'
                    })
            
            # è¤‡å‹ç‡é †ã«ã‚½ãƒ¼ãƒˆ
            horse_performances.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            logger.info(f"é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æå®Œäº†: {len(horse_performances)}é ­, course={course_key}")
            return horse_performances
            
        except Exception as e:
            logger.error(f"é¦¬ã®ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _analyze_jockeys_post_performance(self, jockeys: List[str], posts: List[int] = None) -> Dict[str, Dict]:
        """
        2. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡ã‚’åˆ†æï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨ï¼‰
        
        Args:
            jockeys: é¨æ‰‹åãƒªã‚¹ãƒˆ
            posts: æ ç•ªãƒªã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            
        Returns:
            é¨æ‰‹åˆ¥æ é †æˆç¸¾è¾æ›¸
        """
        jockey_post_performances = {}
        
        # jockeysãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
        logger.info(f"_analyze_jockeys_post_performance called with jockeys type: {type(jockeys)}, posts type: {type(posts)}")
        if not isinstance(jockeys, list):
            logger.error(f"jockeys ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockeys)}, value={jockeys}")
            return {}
        
        # postsãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆNoneã§ãªã„å ´åˆï¼‰
        if posts is not None and not isinstance(posts, list):
            logger.error(f"posts ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(posts)}, value={posts}")
            return {}
        
        # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
        if not jockeys:
            logger.warning("é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™")
            return {}
        
        # å„è¦ç´ ã®å‹ãƒã‚§ãƒƒã‚¯ã¨Noneå€¤ã‚„empty stringã‚’é™¤å¤–
        valid_jockeys = []
        for i, item in enumerate(jockeys):
            if not isinstance(item, str):
                logger.error(f"é¨æ‰‹å[{i}]ãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(item)}, value={item}")
                continue
            if item and item.strip():
                valid_jockeys.append(item)
            else:
                logger.warning(f"é¨æ‰‹å[{i}]ãŒç©ºæ–‡å­—åˆ—ã§ã™")
        
        if not valid_jockeys:
            logger.warning(f"æœ‰åŠ¹ãªé¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“: {jockeys}")
            return {}
        
        if not self.jockey_manager.is_loaded():
            logger.warning("é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“")
            return {}
        
        try:
            # postsã®è¦ç´ ã‚‚ãƒã‚§ãƒƒã‚¯ï¼ˆæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰
            valid_posts = None
            if posts is not None:
                valid_posts = []
                for i, post in enumerate(posts):
                    if not isinstance(post, (int, float)):
                        logger.error(f"æ ç•ª[{i}]ãŒæ•°å€¤ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(post)}, value={post}")
                        # ä¸æ­£ãªå€¤ã¯0ã¨ã—ã¦æ‰±ã†
                        valid_posts.append(0)
                    else:
                        # floatã®å ´åˆã¯intã«å¤‰æ›
                        valid_posts.append(int(post))
                logger.info(f"æ¤œè¨¼å¾Œã®æ ç•ªãƒªã‚¹ãƒˆ: {valid_posts}")
            
            # é¨æ‰‹åã‚’æ­£è¦åŒ–ï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã«åˆã‚ã›ã‚‹ï¼‰
            normalized_jockeys = []
            logger.info(f"å‚¾å‘åˆ†æã«ä½¿ç”¨ã™ã‚‹é¨æ‰‹åï¼ˆå…ƒãƒ‡ãƒ¼ã‚¿ï¼‰: {valid_jockeys}")
            for jockey in valid_jockeys:
                jockey_normalized = self._normalize_jockey_name(jockey)
                normalized_jockeys.append(jockey_normalized)
            
            logger.info(f"æ­£è¦åŒ–å¾Œã®é¨æ‰‹å: {normalized_jockeys}")
            
            # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ã‹ã‚‰æ é †åˆ¥è¤‡å‹ç‡ã‚’å–å¾—
            jockey_post_stats = self.jockey_manager.get_jockey_post_position_fukusho_rates(normalized_jockeys)
            
            # jockey_post_statsã®å‹ãƒã‚§ãƒƒã‚¯
            if not isinstance(jockey_post_stats, dict):
                logger.error(f"jockey_post_statsãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockey_post_stats)}, value={jockey_post_stats}")
                return {}
            
            # å…ƒã®é¨æ‰‹åã‚’ã‚­ãƒ¼ã¨ã—ã¦è¿”ã™ï¼ˆæ ç•ªæƒ…å ±ã‚‚å«ã‚€ï¼‰
            for i, original_jockey in enumerate(valid_jockeys):
                if i < len(normalized_jockeys):
                    normalized = normalized_jockeys[i]
                    result_data = {}
                    
                    # æ ç•ªãŒæä¾›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®æ ç•ªã§ã®æˆç¸¾ã‚’å–å¾—
                    if valid_posts and i < len(valid_posts):
                        post_num = valid_posts[i]
                        # æ ç•ªã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚’åˆ¤å®š
                        if post_num <= 6:
                            category = 'å†…æ ï¼ˆ1-6ï¼‰'
                        elif post_num <= 12:
                            category = 'ä¸­æ ï¼ˆ7-12ï¼‰'
                        else:
                            category = 'å¤–æ ï¼ˆ13-18ï¼‰'
                        
                        result_data['assigned_post'] = post_num
                        result_data['post_category'] = category
                    
                    if normalized in jockey_post_stats:
                        # jockey_post_stats[normalized]ã®å‹ãƒã‚§ãƒƒã‚¯
                        jockey_stats = jockey_post_stats[normalized]
                        if not isinstance(jockey_stats, dict):
                            logger.error(f"é¨æ‰‹ {normalized} ã®post_statsãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockey_stats)}, value={jockey_stats}")
                            result_data['all_post_stats'] = {
                                'å†…æ ï¼ˆ1-6ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'error'},
                                'ä¸­æ ï¼ˆ7-12ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'error'},
                                'å¤–æ ï¼ˆ13-18ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'error'}
                            }
                        else:
                            # å…¨æ é †ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
                            result_data['all_post_stats'] = jockey_stats
                            
                            # è©²å½“æ ç•ªã§ã®æˆç¸¾ã‚’ç‰¹åˆ¥ã«æŠ½å‡º
                            if 'post_category' in result_data:
                                category = result_data['post_category']
                                if category in jockey_stats:
                                    category_stats = jockey_stats[category]
                                    # category_statsã®å‹ãƒã‚§ãƒƒã‚¯
                                    if not isinstance(category_stats, dict):
                                        logger.error(f"é¨æ‰‹ {normalized} ã®ã‚«ãƒ†ã‚´ãƒªãƒ¼ {category} ãƒ‡ãƒ¼ã‚¿ãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(category_stats)}")
                                    else:
                                        result_data['assigned_post_stats'] = category_stats
                    else:
                        # ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆ
                        result_data['all_post_stats'] = {
                            'å†…æ ï¼ˆ1-6ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'no_data'},
                            'ä¸­æ ï¼ˆ7-12ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'no_data'},
                            'å¤–æ ï¼ˆ13-18ï¼‰': {'race_count': 0, 'fukusho_rate': 0.0, 'status': 'no_data'}
                        }
                        
                    jockey_post_performances[original_jockey] = result_data
            
            logger.info(f"é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾åˆ†æå®Œäº†: {len(jockey_post_performances)}å")
            return jockey_post_performances
            
        except Exception as e:
            logger.error(f"é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _analyze_jockeys_course_performance(self, jockeys: List[str], venue: str, distance: int, track_type: str) -> List[Dict]:
        """
        3. é¨æ‰‹ã®é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã§ã®æˆç¸¾è¤‡å‹ç‡ã‚’åˆ†æ
        ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®racesãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é¨æ‰‹åˆ¥ã«é›†è¨ˆ
        
        Args:
            jockeys: é¨æ‰‹åãƒªã‚¹ãƒˆ
            venue: é–‹å‚¬å ´
            distance: è·é›¢
            track_type: ã‚³ãƒ¼ã‚¹ç¨®åˆ¥
            
        Returns:
            é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ãƒªã‚¹ãƒˆ
        """
        jockey_course_performances = []
        course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
        
        # jockeysãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã‚’ãƒã‚§ãƒƒã‚¯
        logger.info(f"_analyze_jockeys_course_performance called with jockeys type: {type(jockeys)}")
        if not isinstance(jockeys, list):
            logger.error(f"jockeys ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãƒªã‚¹ãƒˆã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾ï¼‰: type={type(jockeys)}, value={jockeys}")
            return []
        
        # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
        if not jockeys:
            logger.warning("é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æï¼‰")
            return []
        
        # å„è¦ç´ ã®å‹ãƒã‚§ãƒƒã‚¯ã¨Noneå€¤ã‚„empty stringã‚’é™¤å¤–
        valid_jockeys = []
        for i, item in enumerate(jockeys):
            if not isinstance(item, str):
                logger.error(f"é¨æ‰‹å[{i}]ãŒæ–‡å­—åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾ï¼‰: type={type(item)}, value={item}")
                continue
            if item and item.strip():
                valid_jockeys.append(item)
            else:
                logger.warning(f"é¨æ‰‹å[{i}]ãŒç©ºæ–‡å­—åˆ—ã§ã™ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾ï¼‰")
        
        if not valid_jockeys:
            logger.warning(f"æœ‰åŠ¹ãªé¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æï¼‰: {jockeys}")
            return []
        
        if not self.data_manager.is_loaded():
            logger.warning("ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“")
            return []
        
        try:
            # å„é¨æ‰‹ã«ã¤ã„ã¦ã€ViewLogicã®å…¨é¦¬ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è©²å½“ã‚³ãƒ¼ã‚¹ã§ã®é¨ä¹—æˆç¸¾ã‚’é›†è¨ˆ
            for jockey_name in valid_jockeys:
                wins = 0
                fukusho = 0
                total_runs = 0
                
                # å…¨é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
                for horse_name, horse_data in self.data_manager.horses_dict.items():
                    if 'races' not in horse_data:
                        continue
                    
                    # è©²å½“é¦¬ã®ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é¨æ‰‹ã®æˆç¸¾ã‚’é›†è¨ˆ
                    for race in horse_data['races']:
                        # ViewLogicã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’ä½¿ç”¨
                        race_jockey = race.get('KISHUMEI_RYAKUSHO', '')
                        race_venue_code = race.get('KEIBAJO_CODE', '')
                        race_distance = race.get('KYORI', 0)
                        race_track_code = race.get('TRACK_CODE', '')
                        
                        # ä¼šå ´ã‚³ãƒ¼ãƒ‰ã‚’ä¼šå ´åã«å¤‰æ›
                        venue_map = {
                            '01': 'æœ­å¹Œ', '02': 'å‡½é¤¨', '03': 'ç¦å³¶', '04': 'æ–°æ½Ÿ',
                            '05': 'æ±äº¬', '06': 'ä¸­å±±', '07': 'ä¸­äº¬', '08': 'äº¬éƒ½',
                            '09': 'é˜ªç¥', '10': 'å°å€‰'
                        }
                        race_venue = venue_map.get(race_venue_code, '')
                        
                        # ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ã«å¤‰æ›ï¼ˆ11-29ã¯èŠã€ãã‚Œä»¥å¤–ã¯ãƒ€ãƒ¼ãƒˆï¼‰
                        race_track = 'èŠ' if 11 <= int(race_track_code) <= 29 else 'ãƒ€ãƒ¼ãƒˆ'
                        
                        # é¨æ‰‹åã®æ­£è¦åŒ–ï¼ˆã‚¹ãƒšãƒ¼ã‚¹ã‚„è¨˜å·ã®é•ã„ã‚’å¸åï¼‰
                        if self._normalize_jockey_name(race_jockey) == self._normalize_jockey_name(jockey_name):
                            # ã‚³ãƒ¼ã‚¹æ¡ä»¶ã®ä¸€è‡´ç¢ºèª
                            if race_venue == venue and race_track == track_type:
                                if not distance or race_distance == distance:
                                    total_runs += 1
                                    place = race.get('KAKUTEI_CHAKUJUN', 99)
                                    if place == 1:
                                        wins += 1
                                    if place <= 3:
                                        fukusho += 1
                
                # æˆç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
                if total_runs > 0:
                    jockey_course_performances.append({
                        'jockey_name': jockey_name,
                        'course_key': course_key,
                        'total_runs': total_runs,
                        'wins': wins,
                        'fukusho_count': fukusho,
                        'win_rate': wins / total_runs if total_runs > 0 else 0.0,
                        'fukusho_rate': fukusho / total_runs if total_runs > 0 else 0.0,
                        'status': 'found'
                    })
                else:
                    jockey_course_performances.append({
                        'jockey_name': jockey_name,
                        'course_key': course_key,
                        'total_runs': 0,
                        'wins': 0,
                        'fukusho_count': 0,
                        'win_rate': 0.0,
                        'fukusho_rate': 0.0,
                        'status': 'no_course_data'
                    })
            
            # è¤‡å‹ç‡é †ã«ã‚½ãƒ¼ãƒˆ
            jockey_course_performances.sort(key=lambda x: x['fukusho_rate'], reverse=True)
            
            logger.info(f"é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æå®Œäº†: {len(jockey_course_performances)}å, course={course_key}")
            return jockey_course_performances
            
        except Exception as e:
            logger.error(f"é¨æ‰‹ã®ã‚³ãƒ¼ã‚¹æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _analyze_course_bloodline_performance(self, venue: str, distance: int, track_type: str) -> List[Dict]:
        """
        4. é–‹å‚¬å ´æ‰€ï¼ˆé–‹å‚¬å ´+è·é›¢+ã‚³ãƒ¼ã‚¹ç¨®åˆ¥ï¼‰ã®è¡€çµ±æˆç¸¾ä¸Šä½é †ã‚’åˆ†æ
        
        Args:
            venue: é–‹å‚¬å ´
            distance: è·é›¢
            track_type: ã‚³ãƒ¼ã‚¹ç¨®åˆ¥
            
        Returns:
            è¡€çµ±æˆç¸¾ä¸Šä½é †ãƒªã‚¹ãƒˆ
        """
        bloodline_performances = {}
        course_key = f"{venue}{distance}m{track_type}" if distance else f"{venue}{track_type}"
        
        # é–‹å‚¬å ´ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
        venue_codes = {
            'æœ­å¹Œ': '01', 'å‡½é¤¨': '02', 'ç¦å³¶': '03', 'æ–°æ½Ÿ': '04',
            'æ±äº¬': '05', 'ä¸­å±±': '06', 'ä¸­äº¬': '07', 'äº¬éƒ½': '08',
            'é˜ªç¥': '09', 'å°å€‰': '10'
        }
        venue_code = venue_codes.get(venue, '')
        
        try:
            # å…¨é¦¬ã®ãƒ‡ãƒ¼ã‚¿ã‚’èµ°æŸ»ã—ã¦è¡€çµ±åˆ¥æˆç¸¾ã‚’é›†è¨ˆ
            # æ³¨ï¼šç¾åœ¨ã®ViewLogicãƒŠãƒ¬ãƒƒã‚¸ã«ã¯è¡€çµ±æƒ…å ±ãŒãªã„ãŸã‚ã€ä»£æ›¿æ¡ˆã¨ã—ã¦é¨æ‰‹çµ±è¨ˆã‚’ä½¿ç”¨
            # å°†æ¥çš„ã«è¡€çµ±ãƒ‡ãƒ¼ã‚¿ãŒè¿½åŠ ã•ã‚ŒãŸã‚‰ä¿®æ­£ã™ã‚‹
            
            logger.warning("è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã¯ç¾åœ¨ã®ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“")
            
            # æš«å®šçš„ã«ç©ºãƒªã‚¹ãƒˆã‚’è¿”ã™
            return []
            
        except Exception as e:
            logger.error(f"è¡€çµ±æˆç¸¾åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return []


    
    def _generate_trend_insights_from_real_data(self, horse_course_stats: List[Dict], jockey_post_stats: Dict, 
                                               jockey_course_stats: List[Dict]) -> List[str]:
        """
        å®Ÿãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå‚¾å‘åˆ†æã®ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            horse_course_stats: é¦¬ã®ã‚³ãƒ¼ã‚¹æˆç¸¾
            jockey_post_stats: é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾
            jockey_course_stats: é¨æ‰‹ã®ã‚³ãƒ¼ã‚¹æˆç¸¾  
            bloodline_stats: è¡€çµ±æˆç¸¾
            
        Returns:
            ã‚¤ãƒ³ã‚µã‚¤ãƒˆæ–‡è¨€ãƒªã‚¹ãƒˆ
        """
        insights = []
        
        try:
            # 1. é¦¬ã®ã‚³ãƒ¼ã‚¹é©æ€§ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
            strong_horses = [h for h in horse_course_stats if h['fukusho_rate'] > 0.5 and h['total_runs'] >= 3]
            if strong_horses:
                top_horse = strong_horses[0]
                insights.append(f"{top_horse['horse_name']}ã¯å½“ã‚³ãƒ¼ã‚¹ã§è¤‡å‹ç‡{top_horse['fukusho_rate']:.1%}ã¨é«˜é©æ€§")
            
            # 2. é¨æ‰‹ã®æ é †å‚¾å‘ã‚¤ãƒ³ã‚µã‚¤ãƒˆ  
            if jockey_post_stats:
                # å†…æ ãƒ»ä¸­æ ãƒ»å¤–æ ã®å¹³å‡è¤‡å‹ç‡ã‚’è¨ˆç®—
                position_averages = {'å†…æ ï¼ˆ1-6ï¼‰': 0, 'ä¸­æ ï¼ˆ7-12ï¼‰': 0, 'å¤–æ ï¼ˆ13-18ï¼‰': 0}
                position_counts = {'å†…æ ï¼ˆ1-6ï¼‰': 0, 'ä¸­æ ï¼ˆ7-12ï¼‰': 0, 'å¤–æ ï¼ˆ13-18ï¼‰': 0}
                
                for jockey_name, post_data in jockey_post_stats.items():
                    # æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾å¿œ
                    if 'assigned_post_stats' in post_data:
                        # å€‹åˆ¥ã®é¨æ‰‹ã®è©²å½“æ ã§ã®æˆç¸¾
                        category = post_data.get('post_category')
                        stats = post_data['assigned_post_stats']
                        if category and stats.get('race_count', 0) > 0:
                            position_averages[category] += stats['fukusho_rate']
                            position_counts[category] += 1
                    elif 'all_post_stats' in post_data:
                        # å…¨æ é †ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                        for position, stats in post_data['all_post_stats'].items():
                            if stats.get('race_count', 0) > 0:
                                position_averages[position] += stats['fukusho_rate']
                                position_counts[position] += 1
                
                for position in position_averages:
                    if position_counts[position] > 0:
                        position_averages[position] /= position_counts[position]
                
                # æœ€ã‚‚æœ‰åˆ©ãªæ é †ã‚’åˆ¤å®š
                best_position = max(position_averages.items(), key=lambda x: x[1])
                if best_position[1] > 40:  # 40%ä»¥ä¸Š
                    insights.append(f"æ é †ã¯{best_position[0]}ãŒè¤‡å‹ç‡{best_position[1]:.1f}%ã§æœ‰åˆ©")
            
            # 3. é¨æ‰‹ã®ã‚³ãƒ¼ã‚¹é©æ€§ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
            strong_jockeys = [j for j in jockey_course_stats if j['fukusho_rate'] > 0.4 and j['total_runs'] >= 5]
            if strong_jockeys:
                top_jockey = strong_jockeys[0]
                insights.append(f"{top_jockey['jockey_name']}ã¯å½“ã‚³ãƒ¼ã‚¹ã§è¤‡å‹ç‡{top_jockey['fukusho_rate']*100:.1f}%ã®å¥½æˆç¸¾")
            
            return insights[:3]  # æœ€å¤§3ã¤ã®ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
            
        except Exception as e:
            logger.error(f"å‚¾å‘ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return ["å®Ÿãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ãå‚¾å‘åˆ†æã‚’å®Ÿæ–½"]
    
    def get_horse_history(self, horse_name: str) -> Dict[str, Any]:
        """
        é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ–°æ©Ÿèƒ½ï¼‰
        ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
        
        Args:
            horse_name: é¦¬å
            
        Returns:
            {
                'status': 'success' or 'error',
                'horse_name': str,
                'races': List[Dict],  # ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿
                'running_style': Dict,  # è„šè³ªæƒ…å ±
                'message': str
            }
        """
        try:
            # ViewLogicãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¦¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            horse_data = self.data_manager.get_horse_data(horse_name)
            
            if not horse_data:
                return {
                    'status': 'error',
                    'message': f'{horse_name}ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'
                }
            
            # ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            races = horse_data.get('races', [])
            recent_races = races[:5] if len(races) >= 5 else races
            
            # å„ãƒ¬ãƒ¼ã‚¹ã®é‡è¦ãƒ‡ãƒ¼ã‚¿ã®ã¿æŠ½å‡ºï¼ˆãƒ¢ãƒã‚¤ãƒ«å‘ã‘ç°¡ç•¥åŒ–ï¼‰
            formatted_races = []
            for race in recent_races:
                formatted_race = {
                    'é–‹å‚¬æ—¥': f"{race.get('KAISAI_NEN', '')}/{race.get('KAISAI_GAPPI', '')}",
                    'ç«¶é¦¬å ´': self._get_venue_name(race.get('KEIBAJO_CODE', '')),
                    'ãƒ¬ãƒ¼ã‚¹': f"{race.get('RACE_BANGO', '')}R",
                    'ç€é †': race.get('KAKUTEI_CHAKUJUN', ''),
                    'ã‚¿ã‚¤ãƒ ': race.get('SOHA_TIME', ''),
                    'ä¸Šã‚Š': race.get('KOHAN_3F', ''),
                    'äººæ°—': race.get('TANSHO_NINKIJUN', ''),
                    'é¨æ‰‹': race.get('KISHUMEI_RYAKUSHO', ''),
                    'è·é›¢': f"{race.get('KYORI', '')}m",
                    'é¦¬å ´': self._get_track_condition(race.get('BABA_JOTAI', '')),
                    'é ­æ•°': race.get('TOSU', ''),
                    'é¦¬ä½“é‡': race.get('BATAIJU', ''),
                    'ã‚³ãƒ¼ãƒŠãƒ¼': f"{race.get('CORNER1_JUNI', '')}-{race.get('CORNER2_JUNI', '')}-{race.get('CORNER3_JUNI', '')}-{race.get('CORNER4_JUNI', '')}"
                }
                formatted_races.append(formatted_race)
            
            return {
                'status': 'success',
                'horse_name': horse_name,
                'races': formatted_races,
                'running_style': horse_data.get('running_style', {}),
                'total_races': horse_data.get('total_races', len(races)),
                'message': f'{horse_name}ã®ç›´è¿‘{len(formatted_races)}èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸ'
            }
            
        except Exception as e:
            logger.error(f"é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'status': 'error',
                'message': f'ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def get_jockey_history(self, jockey_name: str) -> Dict[str, Any]:
        """
        é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ–°æ©Ÿèƒ½ï¼‰
        é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
        
        Args:
            jockey_name: é¨æ‰‹å
            
        Returns:
            {
                'status': 'success' or 'error',
                'jockey_name': str,
                'recent_rides': List[Dict],  # ç›´è¿‘5èµ°ã®ãƒ‡ãƒ¼ã‚¿
                'statistics': Dict,  # çµ±è¨ˆæƒ…å ±
                'message': str
            }
        """
        try:
            # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            if not self.jockey_manager.is_loaded():
                return {
                    'status': 'error',
                    'message': 'é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            # é¨æ‰‹åã‚’æ­£è¦åŒ–ï¼ˆå‹•çš„æ¤œç´¢ï¼‹é™çš„ãƒãƒƒãƒ”ãƒ³ã‚°ï¼‰
            normalized_name = self._normalize_jockey_name(jockey_name)
            jockey_data = self.jockey_manager.get_jockey_data(normalized_name)
            
            if not jockey_data:
                return {
                    'status': 'error',
                    'message': f'{jockey_name}é¨æ‰‹ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ'
                }
            
            # é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ€è¿‘ã®æˆç¸¾ã‚’æ§‹ç¯‰
            recent_rides = []
            
            # venue_course_statsã‹ã‚‰ç›´è¿‘ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡ºï¼ˆä¸Šä½5ä»¶ï¼‰
            if 'venue_course_stats' in jockey_data:
                count = 0
                for venue_distance, stats in jockey_data['venue_course_stats'].items():
                    if count >= 5:
                        break
                    
                    # venue_distanceã‚’åˆ†è§£ï¼ˆä¾‹: "ä¸­å±±_2500m" -> "ä¸­å±±", "2500m"ï¼‰
                    if '_' in venue_distance:
                        parts = venue_distance.split('_')
                        venue = parts[0]
                        distance = parts[1] if len(parts) > 1 else 'ä¸æ˜'
                    else:
                        venue = 'ä¸æ˜'
                        distance = venue_distance
                    
                    # å‡ºèµ°æ•°ã‚’å–å¾—ï¼ˆrace_countãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ï¼‰
                    race_count = stats.get('race_count', 0)
                    
                    # è¤‡å‹ç‡ã®å–å¾—ã¨è¡¨ç¤ºå½¢å¼ã®èª¿æ•´
                    fukusho_rate = stats.get('fukusho_rate', 0)
                    fukusho_rate_display = f"{fukusho_rate:.1f}%" if fukusho_rate > 1 else f"{fukusho_rate*100:.1f}%"
                    
                    recent_ride = {
                        'ç«¶é¦¬å ´': venue,
                        'è·é›¢': distance,
                        'å‡ºèµ°æ•°': race_count,
                        'è¤‡å‹ç‡': fukusho_rate_display
                    }
                    recent_rides.append(recent_ride)
                    count += 1
            
            # å…¨ä½“çµ±è¨ˆï¼ˆè¤‡å‹ç‡ã®æ­£è¦åŒ–ï¼‰
            overall_fukusho_rate = jockey_data.get('overall_stats', {}).get('overall_fukusho_rate', 0)
            overall_rate_display = f"{overall_fukusho_rate:.1f}%" if overall_fukusho_rate > 1 else f"{overall_fukusho_rate*100:.1f}%"
            
            statistics = {
                'ç·å‡ºèµ°æ•°': jockey_data.get('overall_stats', {}).get('total_races_analyzed', 0),
                'ç·åˆè¤‡å‹ç‡': overall_rate_display
            }
            
            # é¦¬å ´çŠ¶æ…‹åˆ¥æˆç¸¾ï¼ˆã€Œä¸æ˜(æ•°å­—)ã€å½¢å¼ã®ã‚­ãƒ¼ã‚’å‡¦ç†ï¼‰
            if 'track_condition_stats' in jockey_data:
                track_stats = []
                for condition, stats in jockey_data['track_condition_stats'].items():
                    # ã€Œä¸æ˜(17)ã€ã®ã‚ˆã†ãªå½¢å¼ã‹ã‚‰æ•°å­—ã‚’æŠ½å‡º
                    if '(' in condition and ')' in condition:
                        # æ‹¬å¼§å†…ã®æ•°å­—ã‚’å–å¾—
                        code = condition.split('(')[1].split(')')[0]
                        track_name = self._get_track_condition_from_code(code)
                    else:
                        track_name = self._get_track_condition(condition)
                    
                    fukusho_rate = stats.get('fukusho_rate', 0)
                    rate_display = f"{fukusho_rate:.1f}%" if fukusho_rate > 1 else f"{fukusho_rate*100:.1f}%"
                    track_stats.append({
                        'é¦¬å ´': track_name,
                        'è¤‡å‹ç‡': rate_display
                    })
                statistics['é¦¬å ´åˆ¥æˆç¸¾'] = track_stats
            
            # æ é †åˆ¥æˆç¸¾ï¼ˆã€Œæ 4ã€ã®ã‚ˆã†ãªå½¢å¼ã‚’å‡¦ç†ï¼‰
            if 'post_position_stats' in jockey_data:
                post_stats = []
                for position, stats in jockey_data['post_position_stats'].items():
                    # ã€Œæ 4ã€ã‹ã‚‰æ•°å­—ã ã‘ã‚’æŠ½å‡º
                    if 'æ ' in position:
                        position_num = position.replace('æ ', '')
                        display_position = f"{position_num}æ "
                    else:
                        display_position = position
                    
                    fukusho_rate = stats.get('fukusho_rate', 0)
                    rate_display = f"{fukusho_rate:.1f}%" if fukusho_rate > 1 else f"{fukusho_rate*100:.1f}%"
                    post_stats.append({
                        'æ ': display_position,
                        'è¤‡å‹ç‡': rate_display
                    })
                statistics['æ é †åˆ¥æˆç¸¾'] = post_stats
            
            return {
                'status': 'success',
                'jockey_name': jockey_name,
                'recent_rides': recent_rides,
                'statistics': statistics,
                'message': f'{jockey_name}é¨æ‰‹ã®æˆç¸¾ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸ'
            }
            
        except Exception as e:
            logger.error(f"é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'status': 'error',
                'message': f'é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}'
            }
    
    def _get_track_condition_from_code(self, code: str) -> str:
        """é¦¬å ´çŠ¶æ…‹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åç§°ã‚’å–å¾—ï¼ˆJVDataã‚³ãƒ¼ãƒ‰å¯¾å¿œï¼‰"""
        # JVDataã®ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ï¼ˆæ å†…ã®ä½ç½®æƒ…å ±ã¨ã—ã¦èª¤ç”¨ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ï¼‰
        track_codes = {
            '10': 'å¹³åœ°ãƒ»èŠ', '11': 'å¹³åœ°ãƒ»ãƒ€ãƒ¼ãƒˆ', '12': 'å¹³åœ°ãƒ»èŠãƒ€ãƒ¼ãƒˆ',
            '17': 'å¹³åœ°ãƒ»èŠ', '18': 'å¹³åœ°ãƒ»ãƒ€ãƒ¼ãƒˆ', '19': 'å¹³åœ°ãƒ»èŠå¤–',
            '20': 'å¹³åœ°ãƒ»ç›´ç·šèŠ', '21': 'å¹³åœ°ãƒ»ç›´ç·šãƒ€ãƒ¼ãƒˆ',
            '22': 'å¹³åœ°ãƒ»èŠå¤–â†’å†…', '23': 'å¹³åœ°ãƒ»èŠå†…â†’å¤–', '24': 'å¹³åœ°ãƒ»èŠå†…2å‘¨',
            '51': 'éšœå®³ãƒ»èŠ', '52': 'éšœå®³ãƒ»ãƒ€ãƒ¼ãƒˆ', '53': 'éšœå®³ãƒ»èŠãƒ€ãƒ¼ãƒˆ',
            '54': 'éšœå®³ãƒ»ç›´ç·š', '55': 'éšœå®³ãƒ»èŠå¤–', '56': 'éšœå®³ãƒ»èŠå¤–â†’å†…',
            '57': 'éšœå®³ãƒ»èŠå†…â†’å¤–', '58': 'éšœå®³ãƒ»èŠå†…2å‘¨', '59': 'éšœå®³ãƒ»èŠå¤–2å‘¨'
        }
        # ã‚‚ã—ãƒˆãƒ©ãƒƒã‚¯ã‚³ãƒ¼ãƒ‰ãªã‚‰ãã‚Œã‚’è¿”ã™
        if code in track_codes:
            return track_codes[code]
        # ãã‚Œä»¥å¤–ã¯é¦¬å ´çŠ¶æ…‹ã¨ã—ã¦æ‰±ã†
        return self._get_track_condition(code)
    
    def _normalize_jockey_name(self, jockey_name: str) -> str:
        """é¨æ‰‹åã‚’æ­£è¦åŒ–ã™ã‚‹"""
        # ã€Œé¨æ‰‹ã€ã‚’å‰Šé™¤ã—ã¦ã‚¹ãƒšãƒ¼ã‚¹ã‚’ãƒˆãƒªãƒ 
        normalized = jockey_name.replace('é¨æ‰‹', '').strip()
        
        # jockey_name_mapper ã‚’ä½¿ç”¨ã—ã¦3æ–‡å­—é¨æ‰‹åã‚’æ­£è¦åŒ–
        from services.jockey_name_mapper import normalize_jockey_name
        normalized = normalize_jockey_name(normalized)
        
        # å¤–å›½äººé¨æ‰‹ã®ç‰¹æ®Šå¯¾å¿œï¼ˆé¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ã«åˆã‚ã›ã‚‹ï¼‰
        special_mapping = {
            'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«': 'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«',
            'C.ãƒ«ãƒ¡ãƒ¼ãƒ«': 'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«',
            'ãƒ«ãƒ¡ãƒ¼ãƒ«': 'ï¼£ï¼ãƒ«ãƒ¡ãƒ¼ãƒ«',
            'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­': 'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­',
            'M.ãƒ‡ãƒ ãƒ¼ãƒ­': 'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­',
            'ãƒ‡ãƒ ãƒ¼ãƒ­': 'ï¼­ï¼ãƒ‡ãƒ ãƒ¼ãƒ­'
        }
        
        if normalized in special_mapping:
            return special_mapping[normalized]
        
        return normalized
    
    def _get_venue_name(self, code: str) -> str:
        """ç«¶é¦¬å ´ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åç§°ã‚’å–å¾—"""
        venue_map = {
            '01': 'æœ­å¹Œ', '02': 'å‡½é¤¨', '03': 'ç¦å³¶', '04': 'æ–°æ½Ÿ',
            '05': 'æ±äº¬', '06': 'ä¸­å±±', '07': 'ä¸­äº¬', '08': 'äº¬éƒ½',
            '09': 'é˜ªç¥', '10': 'å°å€‰'
        }
        return venue_map.get(str(code), 'ä¸æ˜')
    
    def _get_track_condition(self, code: str) -> str:
        """é¦¬å ´çŠ¶æ…‹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åç§°ã‚’å–å¾—"""
        condition_map = {
            '1': 'è‰¯', '2': 'ç¨é‡', '3': 'é‡', '4': 'ä¸è‰¯',
            1: 'è‰¯', 2: 'ç¨é‡', 3: 'é‡', 4: 'ä¸è‰¯'
        }
        return condition_map.get(code, str(code))
