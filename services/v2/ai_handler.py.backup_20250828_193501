"""
V2 AIçµ±åˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
ãƒ¬ãƒ¼ã‚¹é™å®šåˆ†æã¨AIè‡ªç„¶è¨€èªåˆ‡ã‚Šæ›¿ãˆã‚’å®Ÿè£…
"""
import re
import json
import logging
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime
from services.imlogic_engine import IMLogicEngine
from services.dlogic_raw_data_manager import DLogicRawDataManager
try:
    from anthropic import Anthropic
except ImportError:
    Anthropic = None
import os

logger = logging.getLogger(__name__)

class V2AIHandler:
    """V2ã‚·ã‚¹ãƒ†ãƒ ç”¨ã®AIãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
    
    def __init__(self):
        # IMLogicEngineã¯æ¯å›æ–°è¦ä½œæˆã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯åˆæœŸåŒ–ã—ãªã„
        # /logic-chatã¨åŒã˜å‹•ä½œã‚’ä¿è¨¼
        # DLogicRawDataManagerã¯å‰Šé™¤ï¼ˆIMLogicEngineå†…ã§æ—¢ã«åˆæœŸåŒ–ã•ã‚Œã‚‹ï¼‰
        # self.dlogic_manager = DLogicRawDataManager()  # ãƒ¡ãƒ¢ãƒªé‡è¤‡ã‚’é¿ã‘ã‚‹
        self.anthropic_client = Anthropic(api_key=os.environ.get("ANTHROPIC_API_KEY")) if Anthropic else None
        
        # AIé¸æŠã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        self.AI_KEYWORDS = {
            'imlogic': ['åˆ†æ', 'è©•ä¾¡', 'IMLogic', 'IM', 'ã‚¢ã‚¤ã‚¨ãƒ '],
            'viewlogic_trend': ['å‚¾å‘', 'ãƒˆãƒ¬ãƒ³ãƒ‰', 'çµ±è¨ˆ', 'ãƒ‡ãƒ¼ã‚¿', 'éå»'],
            'viewlogic_opinion': ['è¦‹è§£', 'æ„è¦‹', 'äºˆæƒ³', 'æ¨å¥¨', 'ãŠã™ã™ã‚'],
            'dlogic': ['d-logic', 'ãƒ‡ã‚£ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯', 'D-Logic', 'Dãƒ­ã‚¸ãƒƒã‚¯', 'æŒ‡æ•°', 'ã‚¹ã‚³ã‚¢', '12é …ç›®', 'è©•ä¾¡ç‚¹'],
            'ilogic': ['i-logic', 'ã‚¢ã‚¤ãƒ­ã‚¸ãƒƒã‚¯', 'I-Logic', 'Iãƒ­ã‚¸ãƒƒã‚¯', 'é¨æ‰‹', 'ç·åˆ', 'ãƒ¬ãƒ¼ã‚¹ã‚¢ãƒŠãƒªã‚·ã‚¹', 'ã‚¢ãƒŠãƒªã‚·ã‚¹']
        }
    
        
    def determine_ai_type(self, message: str) -> Tuple[str, str]:
        """
        ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰AIã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Returns:
            (ai_type, sub_type) ã®ã‚¿ãƒ—ãƒ«
            - ai_type: 'imlogic', 'viewlogic', 'dlogic', 'ilogic'
            - sub_type: 'analysis', 'trend', 'opinion' ãªã©
        """
        message_lower = message.lower()
        
        # D-Logicåˆ†æ
        for keyword in self.AI_KEYWORDS['dlogic']:
            if keyword.lower() in message_lower:
                return ('dlogic', 'analysis')
        
        # I-Logicåˆ†æ
        for keyword in self.AI_KEYWORDS['ilogic']:
            if keyword.lower() in message_lower:
                return ('ilogic', 'analysis')
        
        # ViewLogicå‚¾å‘åˆ†æ
        for keyword in self.AI_KEYWORDS['viewlogic_trend']:
            if keyword in message_lower:
                return ('viewlogic', 'trend')
        
        # ViewLogicè¦‹è§£
        for keyword in self.AI_KEYWORDS['viewlogic_opinion']:
            if keyword in message_lower:
                return ('viewlogic', 'opinion')
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯IMLogicåˆ†æ
        return ('imlogic', 'analysis')
    
    def create_race_context_prompt(self, race_data: Dict[str, Any]) -> str:
        """
        ãƒ¬ãƒ¼ã‚¹é™å®šã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
        """
        horses_list = race_data.get('horses', [])
        horses_str = 'ã€'.join(horses_list) if horses_list else 'æƒ…å ±ãªã—'
        
        prompt = f"""
ã‚ãªãŸã¯ç«¶é¦¬äºˆæƒ³ã®å°‚é–€AIã§ã™ã€‚ä»¥ä¸‹ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦ã®ã¿åˆ†æãƒ»å›ç­”ã—ã¦ãã ã•ã„ã€‚

ã€å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã€‘
- é–‹å‚¬æ—¥: {race_data.get('race_date', 'ä¸æ˜')}
- é–‹å‚¬å ´: {race_data.get('venue', 'ä¸æ˜')}
- ãƒ¬ãƒ¼ã‚¹ç•ªå·: {race_data.get('race_number', 'ä¸æ˜')}R
- ãƒ¬ãƒ¼ã‚¹å: {race_data.get('race_name', 'ä¸æ˜')}
- è·é›¢: {race_data.get('distance', 'ä¸æ˜')}
- é¦¬å ´çŠ¶æ…‹: {race_data.get('track_condition', 'ä¸æ˜')}
- å‡ºèµ°é¦¬: {horses_str}

ã€é‡è¦ãªåˆ¶ç´„ã€‘
1. ä¸Šè¨˜ãƒ¬ãƒ¼ã‚¹ä»¥å¤–ã®æƒ…å ±ã‚„åˆ†æã¯ä¸€åˆ‡è¡Œã‚ãªã„ã§ãã ã•ã„
2. ä»–ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦èã‹ã‚Œã¦ã‚‚ã€Œã“ã®ãƒãƒ£ãƒƒãƒˆã¯{race_data.get('venue')} {race_data.get('race_number')}Rå°‚ç”¨ã§ã™ã€ã¨å›ç­”
3. å‡ºèµ°é¦¬ãƒªã‚¹ãƒˆã«ãªã„é¦¬ã«ã¤ã„ã¦ã¯åˆ†æã§ãã¾ã›ã‚“
4. ãƒ¬ãƒ¼ã‚¹å½“æ—¥ã®æœ€æ–°æƒ…å ±ï¼ˆã‚ªãƒƒã‚ºã€é¦¬ä½“é‡ç­‰ï¼‰ã¯æŒã£ã¦ã„ã¾ã›ã‚“
"""
        return prompt
    
    async def process_imlogic_message(
        self,
        message: str,
        race_data: Dict[str, Any],
        settings: Optional[Dict[str, Any]] = None
    ) -> Tuple[str, Optional[Dict]]:
        """
        IMLogicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆæ—¢å­˜ã®IMLogicEngineã‚’ä½¿ç”¨ï¼‰
        """
        try:
            # åˆ†æã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ
            if self._should_analyze(message):
                # é‡è¦: /logic-chatã¨åŒã˜ã‚ˆã†ã«æ¯å›æ–°ã—ã„ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½œæˆ
                # ãƒ¡ãƒ¢ãƒªã‚ˆã‚Šã‚‚æ­£ç¢ºæ€§ã‚’å„ªå…ˆ
                from services.imlogic_engine import IMLogicEngine
                imlogic_engine_temp = IMLogicEngine()
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã‚’ä½¿ç”¨ï¼ˆè¨­å®šãŒç„¡ã„å ´åˆï¼‰
                if not settings:
                    settings = self._get_default_imlogic_settings()
                
                # IMLogicEngineã§åˆ†æ
                # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾å¿œ
                horse_weight = settings.get('horse_weight') or settings.get('horse_ratio', 70)
                jockey_weight = settings.get('jockey_weight') or settings.get('jockey_ratio', 30)
                raw_weights = settings.get('item_weights') or settings.get('weights', {})
                
                # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ã‚­ãƒ¼å½¢å¼ãŒç•ªå·ä»˜ãã‹ç•ªå·ãªã—ã‹ã‚’åˆ¤å®š
                if '1_distance_aptitude' in raw_weights:
                    # ã™ã§ã«ç•ªå·ä»˜ãå½¢å¼
                    item_weights = raw_weights
                elif 'distance_aptitude' in raw_weights:
                    # ç•ªå·ãªã—å½¢å¼ã‹ã‚‰ç•ªå·ä»˜ãå½¢å¼ã«å¤‰æ›
                    item_weights = {
                        '1_distance_aptitude': raw_weights.get('distance_aptitude', 8.33),
                        '2_bloodline_evaluation': raw_weights.get('bloodline_evaluation', 8.33),
                        '3_jockey_compatibility': raw_weights.get('jockey_compatibility', 8.33),
                        '4_trainer_evaluation': raw_weights.get('trainer_evaluation', 8.33),
                        '5_track_aptitude': raw_weights.get('track_aptitude', 8.33),
                        '6_weather_aptitude': raw_weights.get('weather_aptitude', 8.33),
                        '7_popularity_factor': raw_weights.get('popularity_factor', 8.33),
                        '8_weight_impact': raw_weights.get('weight_impact', 8.33),
                        '9_horse_weight_impact': raw_weights.get('horse_weight_impact', 8.33),
                        '10_corner_specialist': raw_weights.get('corner_specialist', 8.33),
                        '11_margin_analysis': raw_weights.get('margin_analysis', 8.33),
                        '12_time_index': raw_weights.get('time_index', 8.37)
                    }
                else:
                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
                    item_weights = {
                        '1_distance_aptitude': 8.33,
                        '2_bloodline_evaluation': 8.33,
                        '3_jockey_compatibility': 8.33,
                        '4_trainer_evaluation': 8.33,
                        '5_track_aptitude': 8.33,
                        '6_weather_aptitude': 8.33,
                        '7_popularity_factor': 8.33,
                        '8_weight_impact': 8.33,
                        '9_horse_weight_impact': 8.33,
                        '10_corner_specialist': 8.33,
                        '11_margin_analysis': 8.33,
                        '12_time_index': 8.37
                    }
                
                # ä¸€æ™‚çš„ãªã‚¨ãƒ³ã‚¸ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§åˆ†æ
                analysis_result = imlogic_engine_temp.analyze_race(
                    race_data=race_data,
                    horse_weight=horse_weight,
                    jockey_weight=jockey_weight,
                    item_weights=item_weights
                )
                
                # çµæœãŒç©ºã®å ´åˆã®ãƒã‚§ãƒƒã‚¯ï¼ˆ'scores'ã¨'results'ã®ä¸¡æ–¹ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
                if not analysis_result or (not analysis_result.get('scores') and not analysis_result.get('results')):
                    logger.error(f"IMLogicåˆ†æçµæœãŒç©º: {analysis_result}")
                    return ("åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸã€‚é¦¬åãŒæ­£ã—ã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚", None)
                
                # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                formatted_content = self._format_imlogic_result(analysis_result, race_data)
                return (formatted_content, analysis_result)
            
            # é€šå¸¸ã®ä¼šè©±ã®å ´åˆ
            else:
                # ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                race_context = self.create_race_context_prompt(race_data)
                
                # IMLogicã®è¨­å®šèª¬æ˜
                if settings:
                    imlogic_prompt = self._create_imlogic_prompt(settings)
                else:
                    imlogic_prompt = """
IMLogicã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªåˆ†æã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
é¦¬ã¨é¨æ‰‹ã®æ¯”ç‡ã€12é …ç›®ã®é‡ã¿ä»˜ã‘ã‚’è‡ªç”±ã«è¨­å®šã§ãã¾ã™ã€‚
"""
                
                # Claude APIã‚’å‘¼ã³å‡ºã—ï¼ˆä¼šè©±ç”¨ï¼‰
                if self.anthropic_client:
                    full_prompt = f"{race_context}\n\n{imlogic_prompt}\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: {message}"
                    response = self.anthropic_client.messages.create(
                        model="claude-3-haiku-20240307",
                        max_tokens=2000,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": full_prompt}
                        ]
                    )
                    return (response.content[0].text, None)
                else:
                    return ("ä¼šè©±æ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“", None)
            
        except Exception as e:
            logger.error(f"IMLogicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return (f"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚IMLogicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    def _should_analyze(self, message: str) -> bool:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒåˆ†æè¦æ±‚ã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
        analyze_keywords = ['åˆ†æ', 'è©•ä¾¡', 'é †ä½', 'ä¸Šä½', 'äºˆæƒ³', 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°', 'ã‚¹ã‚³ã‚¢']
        message_lower = message.lower()
        return any(keyword in message_lower for keyword in analyze_keywords)
    
    def _get_default_imlogic_settings(self) -> Dict[str, Any]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®IMLogicè¨­å®šã‚’è¿”ã™"""
        return {
            'horse_ratio': 70,
            'jockey_ratio': 30,
            'weights': self._get_default_weights()
        }
    
    def _get_default_weights(self) -> Dict[str, float]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®12é …ç›®é‡ã¿ä»˜ã‘ã‚’è¿”ã™"""
        return {
            'distance_aptitude': 10,
            'track_aptitude': 8,
            'growth_potential': 7,
            'trainer_skill': 6,
            'breakthrough_potential': 8,
            'strength_score': 10,
            'winning_percentage': 9,
            'recent_performance': 10,
            'course_experience': 8,
            'distance_experience': 8,
            'stability': 8,
            'jockey_compatibility': 8
        }
    
    def _format_imlogic_result(self, analysis_result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """IMLogicåˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        try:
            # 'scores'ã¨'results'ã®ä¸¡æ–¹ã«å¯¾å¿œ
            scores = analysis_result.get('scores') or analysis_result.get('results', [])
            if not scores:
                return "åˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆï¼ˆNoneã®å ´åˆã¯-1ã¨ã—ã¦æ‰±ã†ï¼‰
            scores.sort(key=lambda x: x.get('total_score') if x.get('total_score') is not None else -1, reverse=True)
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ¯ IMLogicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R")
            lines.append("")
            
            # ä¸Šä½5é ­ã‚’è¡¨ç¤ºï¼ˆã‚¹ã‚³ã‚¢ãŒã‚ã‚‹é¦¬ã®ã¿ï¼‰
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ä½:', '5ä½:']
            valid_scores = [s for s in scores if s.get('total_score') is not None]
            
            for i, score_data in enumerate(valid_scores[:5]):
                emoji = emojis[i] if i < 5 else f"{i+1}."
                # 'horse_name'ã¨'horse'ã®ä¸¡æ–¹ã«å¯¾å¿œ
                horse_name = score_data.get('horse_name') or score_data.get('horse', 'ä¸æ˜')
                total_score = score_data.get('total_score', 0)
                horse_score = score_data.get('horse_score', 0)
                jockey_score = score_data.get('jockey_score', 0)
                
                lines.append(f"{emoji} {horse_name}: {total_score:.1f}ç‚¹")
                lines.append(f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹")
            
            # 6ä½ä»¥ä¸‹ã‚‚ç°¡æ½”ã«è¡¨ç¤ºï¼ˆã‚¹ã‚³ã‚¢ãŒã‚ã‚‹é¦¬ã®ã¿ï¼‰
            if len(valid_scores) > 5:
                lines.append("")
                lines.append("ã€6ä½ä»¥ä¸‹ã€‘")
                for score_data in valid_scores[5:]:
                    # 'horse_name'ã¨'horse'ã®ä¸¡æ–¹ã«å¯¾å¿œ
                    horse_name = score_data.get('horse_name') or score_data.get('horse', 'ä¸æ˜')
                    total_score = score_data.get('total_score', 0)
                    lines.append(f"{horse_name}: {total_score:.1f}ç‚¹")
            
            # ãƒ‡ãƒ¼ã‚¿ãŒãªã„é¦¬ãŒã„ã‚‹å ´åˆã®æ³¨è¨˜
            no_data_horses = [s.get('horse_name') or s.get('horse', 'ä¸æ˜') 
                            for s in scores if s.get('total_score') is None]
            if no_data_horses:
                lines.append("")
                lines.append("ã€ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã€‘")
                lines.append(f"ä»¥ä¸‹ã®é¦¬ã¯ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã®ãŸã‚åˆ†æã§ãã¾ã›ã‚“ã§ã—ãŸ: {', '.join(no_data_horses)}")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"çµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "åˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    async def process_viewlogic_message(
        self,
        message: str,
        race_data: Dict[str, Any],
        sub_type: str = 'trend'
    ) -> str:
        """
        ViewLogicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆå°†æ¥å®Ÿè£…ç”¨ï¼‰
        """
        # ç¾åœ¨ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
        venue = race_data.get('venue', 'ä¸æ˜')
        race_number = race_data.get('race_number', 'ä¸æ˜')
        
        if sub_type == 'trend':
            return f"""
ViewLogicå‚¾å‘åˆ†æï¼ˆé–‹ç™ºä¸­ï¼‰
{venue} {race_number}Rã®å‚¾å‘åˆ†ææ©Ÿèƒ½ã¯ç¾åœ¨é–‹ç™ºä¸­ã§ã™ã€‚
è¿‘æ—¥ä¸­ã«ä»¥ä¸‹ã®åˆ†æãŒå¯èƒ½ã«ãªã‚Šã¾ã™ï¼š
- éå»ã®é¡ä¼¼ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿åˆ†æ
- é–‹å‚¬å ´åˆ¥ã®å‚¾å‘
- é¨æ‰‹ãƒ»èª¿æ•™å¸«ã®æˆç¸¾å‚¾å‘
"""
        elif sub_type == 'opinion':
            return f"""
ViewLogicè¦‹è§£ï¼ˆé–‹ç™ºä¸­ï¼‰
{venue} {race_number}Rã®è¦‹è§£æ©Ÿèƒ½ã¯ç¾åœ¨é–‹ç™ºä¸­ã§ã™ã€‚
è¿‘æ—¥ä¸­ã«ä»¥ä¸‹ã®æƒ…å ±ãŒæä¾›ã•ã‚Œã¾ã™ï¼š
- AIã«ã‚ˆã‚‹æ¨å¥¨é¦¬
- ç©´é¦¬ã®å¯èƒ½æ€§
- é¦¬åˆ¸ã®çµ„ã¿ç«‹ã¦ææ¡ˆ
"""
        else:
            return "ViewLogicæ©Ÿèƒ½ã¯ç¾åœ¨é–‹ç™ºä¸­ã§ã™ã€‚"
    
    def _create_imlogic_prompt(self, settings: Dict[str, Any]) -> str:
        """
        IMLogicè¨­å®šã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
        """
        weights = settings.get('weights', {})
        horse_ratio = settings.get('horse_ratio', 70)
        jockey_ratio = settings.get('jockey_ratio', 30)
        
        prompt_parts = [
            f"IMLogicã‚«ã‚¹ã‚¿ãƒ è¨­å®šã«ã‚ˆã‚‹åˆ†æ",
            f"é¦¬ã®èƒ½åŠ›: {horse_ratio}%ã€é¨æ‰‹ã®èƒ½åŠ›: {jockey_ratio}%ã®æ¯”ç‡ã§è©•ä¾¡",
            "",
            "é‡è¦–ã™ã‚‹é …ç›®ï¼ˆå„ªå…ˆé †ä½ï¼‰:"
        ]
        
        # é‡ã¿ä»˜ã‘ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å„ªå…ˆé †ä½ã‚’æ±ºå®š
        sorted_weights = sorted(
            weights.items(),
            key=lambda x: x[1],
            reverse=True
        )
        
        for i, (item, weight) in enumerate(sorted_weights, 1):
            if weight > 0:
                item_name = self._get_item_display_name(item)
                prompt_parts.append(f"{i}. {item_name} (é‡è¦åº¦: {weight})")
        
        return "\n".join(prompt_parts)
    
    def _get_item_display_name(self, item_key: str) -> str:
        """
        é …ç›®ã‚­ãƒ¼ã‹ã‚‰è¡¨ç¤ºåã‚’å–å¾—
        """
        display_names = {
            'distance_aptitude': 'è·é›¢é©æ€§',
            'track_aptitude': 'ã‚³ãƒ¼ã‚¹é©æ€§',
            'growth_potential': 'æˆé•·åŠ›',
            'trainer_skill': 'èª¿æ•™å¸«',
            'breakthrough_potential': 'çˆ†ç™ºåŠ›',
            'strength_score': 'å¼·ã•',
            'winning_percentage': 'å‹ç‡',
            'recent_performance': 'è¿‘èµ°',
            'course_experience': 'ã‚³ãƒ¼ã‚¹çµŒé¨“',
            'distance_experience': 'è·é›¢å®Ÿç¸¾',
            'stability': 'å®‰å®šæ„Ÿ',
            'jockey_compatibility': 'é¨æ‰‹ç›¸æ€§'
        }
        return display_names.get(item_key, item_key)
    
    async def process_message(
        self,
        message: str,
        race_data: Dict[str, Any],
        ai_type: Optional[str] = None,
        settings: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        çµ±åˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
        
        Returns:
            {
                'content': str,  # å¿œç­”å†…å®¹
                'ai_type': str,  # ä½¿ç”¨ã—ãŸAI
                'sub_type': str,  # ã‚µãƒ–ã‚¿ã‚¤ãƒ—
                'analysis_data': dict  # åˆ†æãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ã‚Œã°ï¼‰
            }
        """
        # AI ã‚¿ã‚¤ãƒ—ã®æ±ºå®š
        if ai_type:
            determined_ai = ai_type
            sub_type = 'manual'
        else:
            determined_ai, sub_type = self.determine_ai_type(message)
        
        # ãƒ¬ãƒ¼ã‚¹å¤–ã®è³ªå•ã‚’ãƒã‚§ãƒƒã‚¯
        if self._is_out_of_scope(message, race_data):
            venue = race_data.get('venue', '')
            race_number = race_data.get('race_number', '')
            
            # ãƒ¬ãƒ¼ã‚¹ã«å­˜åœ¨ã—ãªã„é¦¬åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            race_horses = race_data.get('horses', [])
            potential_horses = re.findall(r'[ã‚¢-ãƒ³ãƒ¼]+|[A-Za-z]+', message)
            
            for potential_horse in potential_horses:
                if len(potential_horse) >= 3:
                    is_in_race = False
                    for race_horse in race_horses:
                        if potential_horse in race_horse or race_horse in potential_horse:
                            is_in_race = True
                            break
                    
                    if not is_in_race and re.search(f'{potential_horse}(ã®|ã¯|ãŒ|ã‚’|ã¨|ã£ã¦|ã¨ã„ã†)', message):
                        common_words = ['ãƒ‡ãƒ¼ã‚¿', 'ãƒ¬ãƒ¼ã‚¹', 'ã‚¹ã‚³ã‚¢', 'ãƒã‚¤ãƒ³ãƒˆ', 'ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¨ãƒ©ãƒ¼']
                        if potential_horse not in common_words:
                            return {
                                'content': f"ã€Œ{potential_horse}ã€ã¯ã€{venue} {race_number}Rã«ã¯å‡ºèµ°ã—ã¾ã›ã‚“ã€‚\nã“ã®ãƒ¬ãƒ¼ã‚¹ã®å‡ºèµ°é¦¬ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:\n" + "ã€".join(race_horses[:5]) + ("..." if len(race_horses) > 5 else ""),
                                'ai_type': determined_ai,
                                'sub_type': 'out_of_scope',
                                'analysis_data': None
                            }
            
            # ä»–ã®ãƒ¬ãƒ¼ã‚¹ã‚„é–‹å‚¬å ´ã¸ã®è¨€åŠã®å ´åˆ
            return {
                'content': f"ã“ã®ãƒãƒ£ãƒƒãƒˆã¯{venue} {race_number}Rå°‚ç”¨ã§ã™ã€‚ä»–ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦ã¯æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚",
                'ai_type': determined_ai,
                'sub_type': 'out_of_scope',
                'analysis_data': None
            }
        
        # AIç¨®åˆ¥ã«å¿œã˜ã¦å‡¦ç†
        analysis_data = None
        if determined_ai == 'imlogic':
            result = await self.process_imlogic_message(message, race_data, settings)
            # ã‚¿ãƒ—ãƒ«ã¾ãŸã¯è¾æ›¸ã®å ´åˆã¯åˆ†è§£
            if isinstance(result, tuple):
                content, analysis_data = result
            elif isinstance(result, dict):
                content = result.get('content', '')
                analysis_data = result.get('analysis_data')
            else:
                content = result
        elif determined_ai == 'dlogic':
            result = await self.process_dlogic_message(message, race_data)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        elif determined_ai == 'ilogic':
            result = await self.process_ilogic_message(message, race_data)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        else:  # viewlogic
            content = await self.process_viewlogic_message(message, race_data, sub_type)
        
        return {
            'content': content,
            'ai_type': determined_ai,
            'sub_type': sub_type,
            'analysis_data': analysis_data
        }
    
    def _is_out_of_scope(self, message: str, race_data: Dict[str, Any]) -> bool:
        """
        ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãƒ¬ãƒ¼ã‚¹ç¯„å›²å¤–ã‹ãƒã‚§ãƒƒã‚¯
        """
        # ä»–ã®ãƒ¬ãƒ¼ã‚¹ç•ªå·ã¸ã®è¨€åŠã‚’ãƒã‚§ãƒƒã‚¯
        other_race_pattern = r'\d+R(?![\d])'  # æ•°å­—+Rï¼ˆå¾Œã«æ•°å­—ãŒç¶šã‹ãªã„ï¼‰
        matches = re.findall(other_race_pattern, message)
        
        current_race_num = str(race_data.get('race_number', ''))
        for match in matches:
            race_num = match[:-1]  # 'R'ã‚’é™¤å»
            if race_num != current_race_num:
                return True
        
        # ä»–ã®é–‹å‚¬å ´ã¸ã®è¨€åŠã‚’ãƒã‚§ãƒƒã‚¯
        venues = ['æ±äº¬', 'ä¸­å±±', 'é˜ªç¥', 'äº¬éƒ½', 'ä¸­äº¬', 'å°å€‰', 'æ–°æ½Ÿ', 'ç¦å³¶', 'æœ­å¹Œ', 'å‡½é¤¨']
        current_venue = race_data.get('venue', '')
        
        for venue in venues:
            if venue in message and venue != current_venue:
                # æ˜ç¢ºã«ä»–ã®é–‹å‚¬å ´ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦èã„ã¦ã„ã‚‹å ´åˆ
                if re.search(f'{venue}\\d+R', message):
                    return True
        
        # ãƒ¬ãƒ¼ã‚¹ã«å­˜åœ¨ã—ãªã„é¦¬åã‚’ãƒã‚§ãƒƒã‚¯
        race_horses = race_data.get('horses', [])
        if race_horses:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰é¦¬åã‚‰ã—ã„å˜èªã‚’æŠ½å‡ºï¼ˆã‚«ã‚¿ã‚«ãƒŠã¾ãŸã¯è‹±å­—ã®é€£ç¶šï¼‰
            potential_horses = re.findall(r'[ã‚¢-ãƒ³ãƒ¼]+|[A-Za-z]+', message)
            
            for potential_horse in potential_horses:
                # 3æ–‡å­—ä»¥ä¸Šã§ã€ã‹ã¤ãƒ¬ãƒ¼ã‚¹ã®é¦¬åãƒªã‚¹ãƒˆã«å­˜åœ¨ã—ãªã„å ´åˆ
                if len(potential_horse) >= 3:
                    # ãƒ¬ãƒ¼ã‚¹ã®é¦¬åãƒªã‚¹ãƒˆã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    is_in_race = False
                    for race_horse in race_horses:
                        if potential_horse in race_horse or race_horse in potential_horse:
                            is_in_race = True
                            break
                    
                    # æ˜ã‚‰ã‹ã«é¦¬åã¨ã—ã¦è¨€åŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼ˆã€œã®ã€ã€œã¯ã€ãªã©ï¼‰
                    if not is_in_race and re.search(f'{potential_horse}(ã®|ã¯|ãŒ|ã‚’|ã¨|ã£ã¦|ã¨ã„ã†)', message):
                        # ä¸€èˆ¬çš„ãªå˜èªã‚„åŠ©è©ã§ãªã„ã“ã¨ã‚’ç¢ºèª
                        common_words = ['ãƒ‡ãƒ¼ã‚¿', 'ãƒ¬ãƒ¼ã‚¹', 'ã‚¹ã‚³ã‚¢', 'ãƒã‚¤ãƒ³ãƒˆ', 'ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¨ãƒ©ãƒ¼']
                        if potential_horse not in common_words:
                            return True
        
        return False
    
    async def process_dlogic_message(
        self,
        message: str,
        race_data: Dict[str, Any]
    ) -> Tuple[str, Optional[Dict]]:
        """
        D-Logicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
        """
        try:
            # D-Logicåˆ†æã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ
            if self._should_analyze(message):
                # æ—¢å­˜ã®D-Logic APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å‘¼ã³å‡ºã—
                import requests
                import json
                
                api_url = "https://uma-i30n.onrender.com/api/chat/message"
                
                # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã‹ã‚‰é¦¬åã‚’æŠ½å‡º
                horses = race_data.get('horses', [])
                if not horses:
                    return ("åˆ†æå¯¾è±¡ã®é¦¬ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None)
                
                # D-Logicåˆ†æç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½œæˆ
                venue = race_data.get('venue', '')
                race_number = race_data.get('race_number', '')
                race_name = race_data.get('race_name', '')
                
                prompt = f"{venue}{race_number}R {race_name}\nå‡ºèµ°é¦¬: {', '.join(horses)}"
                
                # APIãƒªã‚¯ã‚¨ã‚¹ãƒˆ
                response = requests.post(
                    api_url,
                    json={
                        'message': prompt,
                        'user_id': 'v2-system'
                    },
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    content = result.get('response', 'åˆ†æçµæœã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚')
                    
                    # D-Logicçµæœã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆã‚¹ã‚³ã‚¢æŠ½å‡ºï¼‰
                    analysis_data = self._parse_dlogic_result(content)
                    
                    return (content, analysis_data)
                else:
                    logger.error(f"D-Logic API error: {response.status_code}")
                    return ("D-Logicåˆ†æã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚å°‘ã—æ™‚é–“ã‚’ãŠã„ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚", None)
            
            # é€šå¸¸ã®ä¼šè©±ã®å ´åˆ
            else:
                # ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                race_context = self.create_race_context_prompt(race_data)
                
                # D-Logicã®èª¬æ˜
                dlogic_prompt = """
D-Logicã¯ã€12é …ç›®ã«ã‚ˆã‚‹é¦¬ã®ç·åˆè©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
å„é¦¬ã®èƒ½åŠ›ã‚’0-100ç‚¹ã§è©•ä¾¡ã—ã€ãƒ©ãƒ³ã‚­ãƒ³ã‚°å½¢å¼ã§è¡¨ç¤ºã—ã¾ã™ã€‚
åˆ†æã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€ŒD-LogicæŒ‡æ•°ã‚’æ•™ãˆã¦ã€ã€Œè©•ä¾¡ã—ã¦ã€ãªã©ã¨ãŠèããã ã•ã„ã€‚
"""
                
                # Claude APIã‚’å‘¼ã³å‡ºã—ï¼ˆä¼šè©±ç”¨ï¼‰
                if self.anthropic_client:
                    full_prompt = f"{race_context}\n\n{dlogic_prompt}\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: {message}"
                    response = self.anthropic_client.messages.create(
                        model="claude-3-haiku-20240307",
                        max_tokens=2000,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": full_prompt}
                        ]
                    )
                    return (response.content[0].text, None)
                else:
                    return ("ä¼šè©±æ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“", None)
            
        except Exception as e:
            logger.error(f"D-Logicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return (f"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚D-Logicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    async def process_ilogic_message(
        self,
        message: str,
        race_data: Dict[str, Any]
    ) -> Tuple[str, Optional[Dict]]:
        """
        I-Logicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
        """
        try:
            # I-Logicåˆ†æã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ
            if self._should_analyze(message):
                # ãƒ¬ãƒ¼ã‚¹ã‚¢ãƒŠãƒªã‚·ã‚¹V2 APIã‚’å‘¼ã³å‡ºã—
                import requests
                
                api_url = "https://uma-i30n.onrender.com/api/race_analysis/analyze"
                
                # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã‚’æº–å‚™
                horses = race_data.get('horses', [])
                jockeys = race_data.get('jockeys', [])
                posts = race_data.get('posts', [])
                horse_numbers = race_data.get('horse_numbers', [])
                
                if not horses:
                    return ("åˆ†æå¯¾è±¡ã®é¦¬ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None)
                
                # é¨æ‰‹ãƒ»æ é †ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆ
                if not jockeys or not posts:
                    return ("I-Logicåˆ†æã«ã¯é¨æ‰‹ãƒ»æ é †æƒ…å ±ãŒå¿…è¦ã§ã™ã€‚ã“ã®ãƒ¬ãƒ¼ã‚¹ã§ã¯åˆ†æã§ãã¾ã›ã‚“ã€‚", None)
                
                # APIãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
                request_data = {
                    'venue': race_data.get('venue', ''),
                    'race_number': race_data.get('race_number', 1),
                    'horses': horses,
                    'jockeys': jockeys,
                    'posts': posts,
                    'horse_numbers': horse_numbers or list(range(1, len(horses) + 1)),
                    'distance': race_data.get('distance', '1600m'),
                    'track_condition': race_data.get('track_condition', 'è‰¯')
                }
                
                # APIãƒªã‚¯ã‚¨ã‚¹ãƒˆå®Ÿè¡Œ
                response = requests.post(
                    api_url,
                    json=request_data,
                    timeout=60
                )
                
                if response.status_code == 200:
                    result = response.json()
                    analysis_result = result.get('race_analysis', {})
                    
                    # çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                    content = self._format_ilogic_result(analysis_result, race_data)
                    
                    return (content, analysis_result)
                else:
                    logger.error(f"I-Logic API error: {response.status_code}")
                    return ("I-Logicåˆ†æã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚å°‘ã—æ™‚é–“ã‚’ãŠã„ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚", None)
            
            # é€šå¸¸ã®ä¼šè©±ã®å ´åˆ
            else:
                # ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                race_context = self.create_race_context_prompt(race_data)
                
                # I-Logicã®èª¬æ˜
                ilogic_prompt = """
I-Logicã¯ã€é¦¬ã®èƒ½åŠ›ï¼ˆ70%ï¼‰ã¨é¨æ‰‹ã®é©æ€§ï¼ˆ30%ï¼‰ã‚’ç·åˆã—ãŸåˆ†æã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
é–‹å‚¬å ´é©æ€§ã€ã‚¯ãƒ©ã‚¹è£œæ­£ã€é¨æ‰‹ã®æ é †é©æ€§ãªã©ã‚’è€ƒæ…®ã—ãŸç²¾å¯†ãªè©•ä¾¡ã‚’è¡Œã„ã¾ã™ã€‚
åˆ†æã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€ŒI-Logicåˆ†æã—ã¦ã€ã€Œç·åˆè©•ä¾¡ã¯ï¼Ÿã€ãªã©ã¨ãŠèããã ã•ã„ã€‚
"""
                
                # Claude APIã‚’å‘¼ã³å‡ºã—ï¼ˆä¼šè©±ç”¨ï¼‰
                if self.anthropic_client:
                    full_prompt = f"{race_context}\n\n{ilogic_prompt}\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: {message}"
                    response = self.anthropic_client.messages.create(
                        model="claude-3-haiku-20240307",
                        max_tokens=2000,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": full_prompt}
                        ]
                    )
                    return (response.content[0].text, None)
                else:
                    return ("ä¼šè©±æ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“", None)
            
        except Exception as e:
            logger.error(f"I-Logicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return (f"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚I-Logicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    def _parse_dlogic_result(self, content: str) -> Optional[Dict]:
        """
        D-Logicçµæœã‹ã‚‰ã‚¹ã‚³ã‚¢æƒ…å ±ã‚’æŠ½å‡º
        """
        try:
            import re
            
            # D-Logicä¸Šä½5é ­ã‚’æŠ½å‡ºã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
            top5_pattern = r'D-Logicä¸Šä½5é ­[ï¼š:]\s*([^ã€\n]+(?:ã€[^ã€\n]+){0,4})'
            match = re.search(top5_pattern, content)
            
            if match:
                top5_horses = [horse.strip() for horse in match.group(1).split('ã€')]
                return {
                    'type': 'dlogic',
                    'top_horses': top5_horses
                }
            
            return None
            
        except Exception as e:
            logger.error(f"D-Logicçµæœãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _format_ilogic_result(self, analysis_result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """
        I-Logicåˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        """
        try:
            top_horses = analysis_result.get('top_horses', [])
            detailed_scores = analysis_result.get('detailed_scores', {})
            
            if not top_horses:
                return "I-Logicåˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ‘‘ I-Logicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R")
            lines.append("")
            
            # ä¸Šä½5é ­ã‚’è¡¨ç¤º
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ä½:', '5ä½:']
            for i, horse_name in enumerate(top_horses[:5]):
                emoji = emojis[i] if i < 5 else f"{i+1}."
                
                # è©³ç´°ã‚¹ã‚³ã‚¢ãŒã‚ã‚Œã°è¡¨ç¤º
                if horse_name in detailed_scores:
                    score_info = detailed_scores[horse_name]
                    total_score = score_info.get('total_score', 0)
                    horse_score = score_info.get('horse_score', 0)
                    jockey_score = score_info.get('jockey_score', 0)
                    
                    lines.append(f"{emoji} {horse_name}: {total_score:.1f}ç‚¹")
                    lines.append(f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹")
                else:
                    lines.append(f"{emoji} {horse_name}")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"I-Logicçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "I-Logicåˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"