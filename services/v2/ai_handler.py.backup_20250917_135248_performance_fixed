"""
V2 AIçµ±åˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
ãƒ¬ãƒ¼ã‚¹é™å®šåˆ†æã¨AIè‡ªç„¶è¨€èªåˆ‡ã‚Šæ›¿ãˆã‚’å®Ÿè£…
"""
import re
import json
import logging
import traceback
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime
from services.imlogic_engine import IMLogicEngine
from services.dlogic_raw_data_manager import DLogicRawDataManager
try:
    from anthropic import Anthropic
except ImportError:
    Anthropic = None
try:
    import httpx
except ImportError:
    httpx = None
import os

logger = logging.getLogger(__name__)

class V2AIHandler:
    """V2ã‚·ã‚¹ãƒ†ãƒ ç”¨ã®AIãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
    
    def __init__(self):
        # IMLogicEngineã¯æ¯å›æ–°è¦ä½œæˆã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯åˆæœŸåŒ–ã—ãªã„
        # /logic-chatã¨åŒã˜å‹•ä½œã‚’ä¿è¨¼
        # DLogicRawDataManagerã¯è¡€çµ±åˆ†æã§ä½¿ç”¨ã™ã‚‹ãŸã‚åˆæœŸåŒ–
        from services.dlogic_raw_data_manager import DLogicRawDataManager
        self.dlogic_manager = DLogicRawDataManager()  # è¡€çµ±åˆ†æç”¨ï¼ˆä¸€åº¦ã ã‘åˆæœŸåŒ–ï¼‰
        self.anthropic_client = Anthropic(api_key=os.environ.get("ANTHROPIC_API_KEY")) if Anthropic else None
        
        # åœ°æ–¹ç«¶é¦¬å ´ãƒªã‚¹ãƒˆï¼ˆå—é–¢æ±4å ´ï¼‰
        self.LOCAL_VENUES = ['å·å´', 'å¤§äº•', 'èˆ¹æ©‹', 'æµ¦å’Œ']
        
        # AIé¸æŠã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        self.AI_KEYWORDS = {
            'imlogic': ['åˆ†æ', 'è©•ä¾¡', 'IMLogic', 'IM', 'ã‚¢ã‚¤ã‚¨ãƒ '],
            'viewlogic_trend': ['é¨æ‰‹åˆ†æ', 'å‚¾å‘', 'ãƒˆãƒ¬ãƒ³ãƒ‰', 'çµ±è¨ˆ', 'ãƒ‡ãƒ¼ã‚¿', 'éå»', 'ã‚³ãƒ¼ã‚¹å‚¾å‘', 'é¨æ‰‹æˆç¸¾', 'è¡€çµ±', 'æ é †'],
            'viewlogic_recommendation': ['æ¨å¥¨', 'ãŠã™ã™ã‚', 'è²·ã„ç›®', 'é¦¬åˆ¸', 'äºˆæƒ³'],
            'viewlogic_flow': ['å±•é–‹', 'ãƒšãƒ¼ã‚¹', 'é€ƒã’', 'å…ˆè¡Œ', 'å·®ã—', 'è¿½è¾¼', 'è„šè³ª', 'ãƒã‚¤ãƒšãƒ¼ã‚¹', 'ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹', 'æµã‚Œ'],
            'viewlogic_history': ['éå»ãƒ‡ãƒ¼ã‚¿', 'ç›´è¿‘', 'å‰èµ°', 'æˆ¦ç¸¾', 'æˆç¸¾', 'æœ€è¿‘ã®ãƒ¬ãƒ¼ã‚¹', 'éå»ã®ãƒ¬ãƒ¼ã‚¹', 'ï¼•èµ°', '5èµ°', 'ä½¿ã„æ–¹'],  # æ–°è¦è¿½åŠ 
            'viewlogic_sire': ['ç¨®ç‰¡é¦¬åˆ†æ', 'ç¨®ç‰¡é¦¬', 'çˆ¶', 'æ¯çˆ¶', 'è¡€çµ±åˆ†æ', 'çˆ¶é¦¬', 'æ¯é¦¬', 'æ¯çˆ¶é¦¬', 'sire', 'dam', 'broodmare'],  # ç¨®ç‰¡é¦¬åˆ†æã‚µãƒ–ã‚¨ãƒ³ã‚¸ãƒ³
            'dlogic': ['d-logic', 'ãƒ‡ã‚£ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯', 'D-Logic', 'Dãƒ­ã‚¸ãƒƒã‚¯', 'æŒ‡æ•°', 'ã‚¹ã‚³ã‚¢', '12é …ç›®', 'è©•ä¾¡ç‚¹'],
            'ilogic': ['i-logic', 'ilogic', 'ã‚¢ã‚¤ãƒ­ã‚¸ãƒƒã‚¯', 'I-Logic', 'Iãƒ­ã‚¸ãƒƒã‚¯', 'é¨æ‰‹', 'ç·åˆ', 'ãƒ¬ãƒ¼ã‚¹ã‚¢ãƒŠãƒªã‚·ã‚¹', 'ã‚¢ãƒŠãƒªã‚·ã‚¹'],
            'flogic': ['f-logic', 'flogic', 'ã‚¨ãƒ•ãƒ­ã‚¸ãƒƒã‚¯', 'F-Logic', 'Fãƒ­ã‚¸ãƒƒã‚¯', 'ãƒ•ã‚§ã‚¢å€¤']
        }
    
        
    def determine_ai_type(self, message: str) -> Tuple[str, str]:
        """
        ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰AIã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š

        Returns:
            (ai_type, sub_type) ã®ã‚¿ãƒ—ãƒ«
            - ai_type: 'imlogic', 'viewlogic', 'dlogic', 'ilogic', 'column'
            - sub_type: 'analysis', 'trend', 'opinion', 'display' ãªã©
        """
        message_lower = message.lower()

        # ã‚³ãƒ©ãƒ è¡¨ç¤ºã®åˆ¤å®šï¼ˆæœ€å„ªå…ˆï¼‰
        if 'ã‚³ãƒ©ãƒ ' in message and ('è¡¨ç¤º' in message or 'è¦‹ã›ã¦' in message or 'è¦‹ã‚‹' in message or 'ã‚’æ•™ãˆã¦' in message):
            return ('column', 'display')

        # ç‰¹å®šã®AIã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æœ€å„ªå…ˆã§åˆ¤å®šï¼ˆä»–ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚ˆã‚Šå„ªå…ˆï¼‰
        # MetaLogicåˆ†æï¼ˆãƒ¡ã‚¿äºˆæƒ³ã‚·ã‚¹ãƒ†ãƒ  - æœ€å„ªå…ˆï¼‰
        if 'metalogic' in message_lower or 'meta-logic' in message_lower or 'ãƒ¡ã‚¿ãƒ­ã‚¸ãƒƒã‚¯' in message or 'ãƒ¡ã‚¿äºˆæƒ³' in message or 'ãƒ¡ã‚¿ãƒ­ã‚°ic' in message:
            return ('metalogic', 'analysis')
        
        # F-Logicåˆ†æï¼ˆæ˜ç¤ºçš„ãªæŒ‡å®šã‚’æœ€å„ªå…ˆï¼‰
        if 'f-logic' in message_lower or 'flogic' in message_lower or 'ã‚¨ãƒ•ãƒ­ã‚¸ãƒƒã‚¯' in message or 'ãƒ•ã‚§ã‚¢å€¤' in message:
            return ('flogic', 'analysis')
        
        # D-Logicåˆ†æï¼ˆæ˜ç¤ºçš„ãªæŒ‡å®šã‚’å„ªå…ˆï¼‰
        if 'd-logic' in message_lower or 'dlogic' in message_lower or 'ãƒ‡ã‚£ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯' in message:
            return ('dlogic', 'analysis')
        
        # IMLogicåˆ†æï¼ˆæ˜ç¤ºçš„ãªæŒ‡å®šã‚’å„ªå…ˆï¼‰
        if 'imlogic' in message_lower or 'ã‚¢ã‚¤ã‚¨ãƒ ãƒ­ã‚¸ãƒƒã‚¯' in message:
            return ('imlogic', 'analysis')
        
        # ã€Œé¦¬70é¨æ‰‹30ã€ãªã©ã®IMLogicç‰¹æœ‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
        if 'é¦¬' in message and 'é¨æ‰‹' in message and ('ï¼…' in message or '%' in message or 'åˆ†æ' in message):
            return ('imlogic', 'analysis')
        
        # ViewLogicï¼•èµ°ã®ä½¿ã„æ–¹æ¡ˆå†…ï¼ˆæœ€å„ªå…ˆï¼‰
        if 'ä½¿ã„æ–¹' in message and ('ViewLogic' in message or 'viewlogic' in message_lower or 'ï¼•èµ°' in message or '5èµ°' in message):
            return ('viewlogic', 'history')
        
        # ViewLogicéå»ãƒ‡ãƒ¼ã‚¿ï¼ˆé¦¬åãƒ»é¨æ‰‹åãŒå«ã¾ã‚Œã‚‹å ´åˆã‚’å„ªå…ˆï¼‰
        # ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é¦¬åã¨é¨æ‰‹åã‚’å–å¾—ã—ã¦åˆ¤å®šã«ä½¿ç”¨
        if hasattr(self, 'current_race_data'):
            horses = self.current_race_data.get('horses', [])
            jockeys = self.current_race_data.get('jockeys', [])
            
            # é¦¬åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            for horse in horses:
                if horse in message:
                    # éå»ãƒ‡ãƒ¼ã‚¿é–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚‚ã‚ã‚‹ã‹ã€ã¾ãŸã¯é¦¬åã ã‘ã§ã‚‚åå¿œ
                    for keyword in self.AI_KEYWORDS['viewlogic_history']:
                        if keyword in message_lower:
                            return ('viewlogic', 'history')
                    # é¦¬åã ã‘ã§ã‚‚åå¿œï¼ˆãŸã ã—ä»–ã®AIã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒãªã„å ´åˆï¼‰
                    if not any(kw in message_lower for kw_list in [
                        self.AI_KEYWORDS['dlogic'], 
                        self.AI_KEYWORDS['imlogic'],
                        self.AI_KEYWORDS['ilogic'],
                        self.AI_KEYWORDS['viewlogic_flow'],
                        self.AI_KEYWORDS['viewlogic_trend'],
                        self.AI_KEYWORDS['viewlogic_recommendation']
                    ] for kw in kw_list):
                        return ('viewlogic', 'history')
            
            # é¨æ‰‹åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆéƒ¨åˆ†ä¸€è‡´ã¨çŸ­ç¸®åå¯¾å¿œï¼‰
            for jockey in jockeys:
                if jockey:
                    # ãƒ•ãƒ«ãƒãƒ¼ãƒ ã§ã®ä¸€è‡´
                    if jockey in message:
                        for keyword in self.AI_KEYWORDS['viewlogic_history']:
                            if keyword in message_lower:
                                return ('viewlogic', 'history')
                        # é¨æ‰‹åã ã‘ã§ã‚‚åå¿œ
                        if not any(kw in message_lower for kw_list in [
                            self.AI_KEYWORDS['dlogic'], 
                            self.AI_KEYWORDS['imlogic'],
                            self.AI_KEYWORDS['ilogic'],
                            self.AI_KEYWORDS['viewlogic_flow'],
                            self.AI_KEYWORDS['viewlogic_trend'],
                            self.AI_KEYWORDS['viewlogic_recommendation']
                        ] for kw in kw_list):
                            return ('viewlogic', 'history')
                    
                    # çŸ­ç¸®åã§ã®ä¸€è‡´ï¼ˆä¾‹ï¼šå·ç”°å°†é›… â†’ å·ç”°ã€C.ãƒ«ãƒ¡ãƒ¼ãƒ« â†’ ãƒ«ãƒ¡ãƒ¼ãƒ«ï¼‰
                    if len(jockey) >= 2:
                        short_name = jockey[:2]  # æœ€åˆã®2æ–‡å­—
                        if short_name in message:
                            for keyword in self.AI_KEYWORDS['viewlogic_history']:
                                if keyword in message_lower:
                                    return ('viewlogic', 'history')
                            # çŸ­ç¸®åã ã‘ã§ã‚‚åå¿œ
                            if not any(kw in message_lower for kw_list in [
                                self.AI_KEYWORDS['dlogic'], 
                                self.AI_KEYWORDS['imlogic'],
                                self.AI_KEYWORDS['ilogic'],
                                self.AI_KEYWORDS['viewlogic_flow'],
                                self.AI_KEYWORDS['viewlogic_trend'],
                                self.AI_KEYWORDS['viewlogic_recommendation']
                            ] for kw in kw_list):
                                return ('viewlogic', 'history')
                    
                    # å¤–å›½äººé¨æ‰‹ã®å ´åˆï¼ˆC.ãƒ«ãƒ¡ãƒ¼ãƒ« â†’ ãƒ«ãƒ¡ãƒ¼ãƒ«ï¼‰
                    if '.' in jockey:
                        last_part = jockey.split('.')[-1]
                        if last_part in message:
                            for keyword in self.AI_KEYWORDS['viewlogic_history']:
                                if keyword in message_lower:
                                    return ('viewlogic', 'history')
                            if not any(kw in message_lower for kw_list in [
                                self.AI_KEYWORDS['dlogic'], 
                                self.AI_KEYWORDS['imlogic'],
                                self.AI_KEYWORDS['ilogic'],
                                self.AI_KEYWORDS['viewlogic_flow'],
                                self.AI_KEYWORDS['viewlogic_trend'],
                                self.AI_KEYWORDS['viewlogic_recommendation']
                            ] for kw in kw_list):
                                return ('viewlogic', 'history')

        # ViewLogicç¨®ç‰¡é¦¬åˆ†æï¼ˆå„ªå…ˆåº¦é«˜ï¼‰
        for keyword in self.AI_KEYWORDS['viewlogic_sire']:
            if keyword in message_lower or keyword in message:  # ã€Œçˆ¶ã€ã€Œæ¯çˆ¶ã€ã¯æ¼¢å­—ãªã®ã§messageã§ã‚‚ç¢ºèª
                return ('viewlogic', 'sire')

        # ViewLogicå±•é–‹äºˆæƒ³ï¼ˆå„ªå…ˆåº¦é«˜ï¼‰
        for keyword in self.AI_KEYWORDS['viewlogic_flow']:
            if keyword in message_lower:
                return ('viewlogic', 'flow')
        
        # ViewLogicå‚¾å‘åˆ†æï¼ˆI-Logicã‚ˆã‚Šå„ªå…ˆï¼‰
        for keyword in self.AI_KEYWORDS['viewlogic_trend']:
            if keyword in message_lower:
                return ('viewlogic', 'trend')
        
        # F-Logicåˆ†æï¼ˆæŠ•è³‡ä¾¡å€¤åˆ¤å®šï¼‰
        for keyword in self.AI_KEYWORDS['flogic']:
            if keyword.lower() in message_lower:
                return ('flogic', 'analysis')
        
        # I-Logicåˆ†æ
        for keyword in self.AI_KEYWORDS['ilogic']:
            if keyword.lower() in message_lower:
                return ('ilogic', 'analysis')
        
        # ViewLogicæ¨å¥¨
        for keyword in self.AI_KEYWORDS['viewlogic_recommendation']:
            if keyword in message_lower:
                return ('viewlogic', 'recommendation')
        
        # ãã®ä»–ã®D-Logicã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        for keyword in self.AI_KEYWORDS['dlogic']:
            if keyword.lower() in message_lower:
                return ('dlogic', 'analysis')
        
        # ãã®ä»–ã®IMLogicã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        for keyword in self.AI_KEYWORDS['imlogic']:
            if keyword.lower() in message_lower:
                return ('imlogic', 'analysis')
        
        # ã€Œæ¨™æº–åˆ†æã€ã¯D-Logicã¨ã—ã¦æ‰±ã†
        if 'æ¨™æº–' in message_lower and 'åˆ†æ' in message_lower:
            return ('dlogic', 'analysis')
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯IMLogicåˆ†æ
        return ('imlogic', 'analysis')
    
    def create_race_context_prompt(self, race_data: Dict[str, Any]) -> str:
        """
        ãƒ¬ãƒ¼ã‚¹é™å®šã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
        """
        horses_list = race_data.get('horses', [])
        horses_str = 'ã€'.join(horses_list) if horses_list else 'æƒ…å ±ãªã—'
        
        prompt = f"""
ã‚ãªãŸã¯ç«¶é¦¬äºˆæƒ³ã®å°‚é–€AIã§ã™ã€‚ä»¥ä¸‹ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦ã®ã¿åˆ†æãƒ»å›ç­”ã—ã¦ãã ã•ã„ã€‚

ã€å¯¾è±¡ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã€‘
- é–‹å‚¬æ—¥: {race_data.get('race_date', 'ä¸æ˜')}
- é–‹å‚¬å ´: {race_data.get('venue', 'ä¸æ˜')}
- ãƒ¬ãƒ¼ã‚¹ç•ªå·: {race_data.get('race_number', 'ä¸æ˜')}R
- ãƒ¬ãƒ¼ã‚¹å: {race_data.get('race_name', 'ä¸æ˜')}
- è·é›¢: {race_data.get('distance', 'ä¸æ˜')}
- é¦¬å ´çŠ¶æ…‹: {race_data.get('track_condition', 'ä¸æ˜')}
- å‡ºèµ°é¦¬: {horses_str}

ã€é‡è¦ãªåˆ¶ç´„ã€‘
1. ä¸Šè¨˜ãƒ¬ãƒ¼ã‚¹ä»¥å¤–ã®æƒ…å ±ã‚„åˆ†æã¯ä¸€åˆ‡è¡Œã‚ãªã„ã§ãã ã•ã„
2. ä»–ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦èã‹ã‚Œã¦ã‚‚ã€Œã“ã®ãƒãƒ£ãƒƒãƒˆã¯{race_data.get('venue')} {race_data.get('race_number')}Rå°‚ç”¨ã§ã™ã€ã¨å›ç­”
3. å‡ºèµ°é¦¬ãƒªã‚¹ãƒˆã«ãªã„é¦¬ã«ã¤ã„ã¦ã¯åˆ†æã§ãã¾ã›ã‚“
4. ãƒ¬ãƒ¼ã‚¹å½“æ—¥ã®æœ€æ–°æƒ…å ±ï¼ˆã‚ªãƒƒã‚ºã€é¦¬ä½“é‡ç­‰ï¼‰ã¯æŒã£ã¦ã„ã¾ã›ã‚“
"""
        return prompt
    
    def _is_local_racing(self, venue: str) -> bool:
        """åœ°æ–¹ç«¶é¦¬å ´ã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
        return venue in self.LOCAL_VENUES
    
    async def process_imlogic_message(
        self,
        message: str,
        race_data: Dict[str, Any],
        settings: Optional[Dict[str, Any]] = None
    ) -> Tuple[str, Optional[Dict]]:
        """
        IMLogicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆåœ°æ–¹ç«¶é¦¬å¯¾å¿œç‰ˆï¼‰
        """
        try:
            # åˆ†æã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ
            if self._should_analyze(message):
                venue = race_data.get('venue', '')
                
                # åœ°æ–¹ç«¶é¦¬å ´ã®å ´åˆã¯åœ°æ–¹ç«¶é¦¬ç‰ˆã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨
                if self._is_local_racing(venue):
                    from services.local_imlogic_engine_v2 import local_imlogic_engine_v2
                    imlogic_engine_temp = local_imlogic_engine_v2
                    logger.info(f"ğŸ‡ åœ°æ–¹ç«¶é¦¬ç‰ˆIMLogicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
                else:
                    # JRAç‰ˆï¼ˆæ—¢å­˜ï¼‰
                    from services.imlogic_engine import get_imlogic_engine
                    imlogic_engine_temp = get_imlogic_engine()
                    logger.info(f"ğŸ‡ JRAç‰ˆIMLogicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
                
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®è¨­å®šã‚’ä½¿ç”¨ï¼ˆè¨­å®šãŒç„¡ã„å ´åˆï¼‰
                if not settings:
                    settings = self._get_default_imlogic_settings()
                
                # IMLogicEngineã§åˆ†æ
                # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å¯¾å¿œ
                horse_weight = settings.get('horse_weight') or settings.get('horse_ratio', 70)
                jockey_weight = settings.get('jockey_weight') or settings.get('jockey_ratio', 30)
                raw_weights = settings.get('item_weights') or settings.get('weights', {})
                
                # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®ã‚­ãƒ¼å½¢å¼ãŒç•ªå·ä»˜ãã‹ç•ªå·ãªã—ã‹ã‚’åˆ¤å®š
                if '1_distance_aptitude' in raw_weights:
                    # ã™ã§ã«ç•ªå·ä»˜ãå½¢å¼
                    item_weights = raw_weights
                elif 'distance_aptitude' in raw_weights:
                    # ç•ªå·ãªã—å½¢å¼ã‹ã‚‰ç•ªå·ä»˜ãå½¢å¼ã«å¤‰æ›
                    item_weights = {
                        '1_distance_aptitude': raw_weights.get('distance_aptitude', 8.33),
                        '2_bloodline_evaluation': raw_weights.get('bloodline_evaluation', 8.33),
                        '3_jockey_compatibility': raw_weights.get('jockey_compatibility', 8.33),
                        '4_trainer_evaluation': raw_weights.get('trainer_evaluation', 8.33),
                        '5_track_aptitude': raw_weights.get('track_aptitude', 8.33),
                        '6_weather_aptitude': raw_weights.get('weather_aptitude', 8.33),
                        '7_popularity_factor': raw_weights.get('popularity_factor', 8.33),
                        '8_weight_impact': raw_weights.get('weight_impact', 8.33),
                        '9_horse_weight_impact': raw_weights.get('horse_weight_impact', 8.33),
                        '10_corner_specialist': raw_weights.get('corner_specialist', 8.33),
                        '11_margin_analysis': raw_weights.get('margin_analysis', 8.33),
                        '12_time_index': raw_weights.get('time_index', 8.37)
                    }
                else:
                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
                    item_weights = {
                        '1_distance_aptitude': 8.33,
                        '2_bloodline_evaluation': 8.33,
                        '3_jockey_compatibility': 8.33,
                        '4_trainer_evaluation': 8.33,
                        '5_track_aptitude': 8.33,
                        '6_weather_aptitude': 8.33,
                        '7_popularity_factor': 8.33,
                        '8_weight_impact': 8.33,
                        '9_horse_weight_impact': 8.33,
                        '10_corner_specialist': 8.33,
                        '11_margin_analysis': 8.33,
                        '12_time_index': 8.37
                    }
                
                # ä¸€æ™‚çš„ãªã‚¨ãƒ³ã‚¸ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§åˆ†æ
                logger.info(f"IMLogicåˆ†æé–‹å§‹ - venue: {venue}, horses: {race_data.get('horses', [])}")
                logger.info(f"IMLogicé‡ã¿è¨­å®š - horse: {horse_weight}%, jockey: {jockey_weight}%")
                
                analysis_result = imlogic_engine_temp.analyze_race(
                    race_data=race_data,
                    horse_weight=horse_weight,
                    jockey_weight=jockey_weight,
                    item_weights=item_weights
                )
                
                logger.info(f"IMLogicåˆ†æçµæœ: status={analysis_result.get('status')}, resultsæ•°={len(analysis_result.get('results', []))}")
                
                # çµæœãŒç©ºã®å ´åˆã®ãƒã‚§ãƒƒã‚¯ï¼ˆ'scores'ã¨'results'ã®ä¸¡æ–¹ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
                if not analysis_result or (not analysis_result.get('scores') and not analysis_result.get('results')):
                    logger.error(f"IMLogicåˆ†æçµæœãŒç©º: {analysis_result}")
                    logger.error(f"race_dataè©³ç´°: {race_data}")
                    return ("åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸã€‚é¦¬åãŒæ­£ã—ã„ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚", None)
                
                # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                formatted_content = self._format_imlogic_result(analysis_result, race_data)
                return (formatted_content, analysis_result)
            
            # é€šå¸¸ã®ä¼šè©±ã®å ´åˆ
            else:
                # ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                race_context = self.create_race_context_prompt(race_data)
                
                # IMLogicã®è¨­å®šèª¬æ˜
                if settings:
                    imlogic_prompt = self._create_imlogic_prompt(settings)
                else:
                    imlogic_prompt = """
IMLogicã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºå¯èƒ½ãªåˆ†æã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
é¦¬ã¨é¨æ‰‹ã®æ¯”ç‡ã€12é …ç›®ã®é‡ã¿ä»˜ã‘ã‚’è‡ªç”±ã«è¨­å®šã§ãã¾ã™ã€‚
"""
                
                # Claude APIã‚’å‘¼ã³å‡ºã—ï¼ˆä¼šè©±ç”¨ï¼‰
                if self.anthropic_client:
                    full_prompt = f"{race_context}\n\n{imlogic_prompt}\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: {message}"
                    response = self.anthropic_client.messages.create(
                        model="claude-3-haiku-20240307",
                        max_tokens=2000,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": full_prompt}
                        ]
                    )
                    return (response.content[0].text, None)
                else:
                    return ("ä¼šè©±æ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“", None)
            
        except Exception as e:
            import traceback
            logger.error(f"IMLogicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            logger.error(f"IMLogicã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹: {traceback.format_exc()}")
            logger.error(f"IMLogicã‚¨ãƒ©ãƒ¼æ™‚ã®race_data: {race_data}")
            return (f"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚IMLogicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    def _should_analyze(self, message: str) -> bool:
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒåˆ†æè¦æ±‚ã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
        analyze_keywords = ['åˆ†æ', 'è©•ä¾¡', 'é †ä½', 'ä¸Šä½', 'äºˆæƒ³', 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°', 'ã‚¹ã‚³ã‚¢']
        message_lower = message.lower()
        return any(keyword in message_lower for keyword in analyze_keywords)
    
    def _get_default_imlogic_settings(self) -> Dict[str, Any]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®IMLogicè¨­å®šã‚’è¿”ã™"""
        return {
            'horse_ratio': 70,
            'jockey_ratio': 30,
            'weights': self._get_default_weights()
        }
    
    def _get_default_weights(self) -> Dict[str, float]:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®12é …ç›®é‡ã¿ä»˜ã‘ã‚’è¿”ã™"""
        return {
            '1_distance_aptitude': 8.33,
            '2_bloodline_evaluation': 8.33,
            '3_jockey_compatibility': 8.33,
            '4_trainer_evaluation': 8.33,
            '5_track_aptitude': 8.33,
            '6_weather_aptitude': 8.33,
            '7_popularity_factor': 8.33,
            '8_weight_impact': 8.33,
            '9_horse_weight_impact': 8.33,
            '10_corner_specialist': 8.33,
            '11_margin_analysis': 8.33,
            '12_time_index': 8.37
        }
    
    def _format_imlogic_result(self, analysis_result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """IMLogicåˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        try:
            # 'scores'ã¨'results'ã®ä¸¡æ–¹ã«å¯¾å¿œ
            scores = analysis_result.get('scores') or analysis_result.get('results', [])
            if not scores:
                return "åˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆï¼ˆNoneã®å ´åˆã¯-1ã¨ã—ã¦æ‰±ã†ï¼‰
            scores.sort(key=lambda x: x.get('total_score') if x.get('total_score') is not None else -1, reverse=True)
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ¯ IMLogicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R")
            lines.append("")
            
            # å…¨é ­ã‚’é †ä½ä»˜ãã§è¡¨ç¤ºï¼ˆI-Logicå½¢å¼ï¼‰
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰']
            # -1ã¯ãƒ‡ãƒ¼ã‚¿ä¸è¶³ãªã®ã§ã€æœ‰åŠ¹ãªã‚¹ã‚³ã‚¢ã‹ã‚‰é™¤å¤–
            valid_scores = [s for s in scores if s.get('total_score') is not None and s.get('total_score') >= 0]
            no_data_scores = [s for s in scores if s.get('total_score') == -1]
            
            for i, score_data in enumerate(valid_scores):
                # ä¸Šä½3ä½ã¾ã§çµµæ–‡å­—ã€4ä½ä»¥é™ã¯æ•°å­—è¡¨ç¤º
                if i < 3:
                    rank_display = f"{emojis[i]} {i+1}ä½:"
                else:
                    rank_display = f"{i+1}ä½:"
                
                # 'horse_name'ã¨'horse'ã®ä¸¡æ–¹ã«å¯¾å¿œ
                horse_name = score_data.get('horse_name') or score_data.get('horse', 'ä¸æ˜')
                total_score = score_data.get('total_score', 0)
                horse_score = score_data.get('horse_score', 0)
                jockey_score = score_data.get('jockey_score', 0)
                
                lines.append(f"{rank_display} {horse_name}: {total_score:.1f}ç‚¹")
                lines.append(f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹")
                
                # æ¬¡ã®é¦¬ã¨ã®é–“ã«ç©ºè¡Œã‚’è¿½åŠ ï¼ˆæœ€å¾Œã®é¦¬ä»¥å¤–ï¼‰
                if i < len(valid_scores) - 1:
                    lines.append("")
                
                # 6ä½ç›®ã«åŒºåˆ‡ã‚Šç·šã‚’è¿½åŠ 
                if i == 5:
                    lines.append("ã€6ä½ä»¥ä¸‹ã€‘")
            
            # ãƒ‡ãƒ¼ã‚¿ãŒãªã„é¦¬ãŒã„ã‚‹å ´åˆã®æ³¨è¨˜
            if no_data_scores:
                no_data_horses = [s.get('horse_name') or s.get('horse', 'ä¸æ˜') for s in no_data_scores]
                lines.append("")
                lines.append("ã€ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã€‘")
                lines.append(f"ä»¥ä¸‹ã®é¦¬ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“: {', '.join(no_data_horses)}")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"çµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "åˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    async def process_metalogic_message(
        self,
        message: str,
        race_data: Dict[str, Any]
    ) -> Tuple[str, Optional[Dict]]:
        """
        MetaLogicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆãƒ¡ã‚¿äºˆæƒ³ã‚·ã‚¹ãƒ†ãƒ ï¼‰
        I-Logic 40%, D-Logic 30%, ViewLogic 30%ã®é‡ã¿ä»˜ã‘ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«
        
        Returns:
            (content, analysis_data) ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            from services.metalogic_engine import metalogic_engine
            
            # ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
            analysis_result = await metalogic_engine.analyze_race(race_data)
            
            if analysis_result.get('status') != 'success':
                return (analysis_result.get('message', 'åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ'), None)
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            content = self._format_metalogic_result(analysis_result)
            
            return (content, analysis_result)
            
        except Exception as e:
            logger.error(f"MetaLogicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            traceback.print_exc()
            return ("MetaLogicã®åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", None)
    
    def _format_metalogic_result(self, result: Dict[str, Any]) -> str:
        """MetaLogicçµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        try:
            rankings = result.get('rankings', [])
            
            if not rankings:
                return "åˆ†æçµæœãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
            
            content = "ğŸ¯ **MetaLogic ãƒ¡ã‚¿äºˆæƒ³ã‚·ã‚¹ãƒ†ãƒ **\n"
            content += "ï¼ˆI-Logic 40% + D-Logic 30% + ViewLogic 30% + å¸‚å ´è©•ä¾¡ï¼‰\n\n"
            content += "**æ¨å¥¨é¦¬ï¼ˆãƒ¡ã‚¿ã‚¹ã‚³ã‚¢é †ï¼‰**\n\n"
            
            for item in rankings[:5]:
                horse = item.get('horse', 'ä¸æ˜')
                score = item.get('meta_score', 0)
                details = item.get('details', {})
                
                # ä¿¡é ¼åº¦ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
                if details.get('engine_count', 0) >= 3:
                    confidence = "â­â­â­"
                elif details.get('engine_count', 0) >= 2:
                    confidence = "â­â­"
                else:
                    confidence = "â­"
                
                content += f"**{item.get('rank')}ä½ {horse}** {confidence}\n"
                content += f"  ãƒ¡ã‚¿ã‚¹ã‚³ã‚¢: **{score:.1f}ç‚¹**\n"
                content += f"  - D-Logic: {details.get('d_logic', 0):.1f}ç‚¹\n"
                content += f"  - I-Logic: {details.get('i_logic', 0):.1f}ç‚¹\n"
                content += f"  - ViewLogic: {details.get('view_logic', 0):.1f}ç‚¹\n"
                content += f"  - ã‚ªãƒƒã‚ºè©•ä¾¡: {details.get('odds_factor', 0):.1f}ç‚¹\n\n"
            
            content += "\nğŸ’¡ **è§£èª¬**\n"
            content += "MetaLogicã¯3ã¤ã®AIã‚¨ãƒ³ã‚¸ãƒ³ã¨å¸‚å ´è©•ä¾¡ã‚’çµ±åˆã—ãŸ\n"
            content += "ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«äºˆæƒ³ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚\n"
            content += "I-Logicã®é«˜ç²¾åº¦ã‚’æ´»ã‹ã—ã¤ã¤ã€è¤‡æ•°è¦–ç‚¹ã§ã®æ¤œè¨¼ã«ã‚ˆã‚Š\n"
            content += "å®‰å®šæ€§ã‚’å‘ä¸Šã•ã›ã¦ã„ã¾ã™ã€‚\n"
            
            return content
            
        except Exception as e:
            logger.error(f"MetaLogicçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "çµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    async def process_viewlogic_message(
        self,
        message: str,
        race_data: Dict[str, Any],
        sub_type: str = 'trend'
    ) -> Tuple[str, Optional[Dict]]:
        """
        ViewLogicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆåœ°æ–¹ç«¶é¦¬å¯¾å¿œç‰ˆï¼‰
        
        Returns:
            (content, analysis_data) ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            venue = race_data.get('venue', 'ä¸æ˜')
            race_number = race_data.get('race_number', 'ä¸æ˜')
            
            # åœ°æ–¹ç«¶é¦¬å ´ã®å ´åˆã¯åœ°æ–¹ç«¶é¦¬ç‰ˆã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨
            if self._is_local_racing(venue):
                from services.local_viewlogic_engine_v2 import local_viewlogic_engine_v2
                viewlogic_engine = local_viewlogic_engine_v2
                logger.info(f"ğŸ‡ åœ°æ–¹ç«¶é¦¬ç‰ˆViewLogicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
            else:
                # JRAç‰ˆï¼ˆæ—¢å­˜ï¼‰
                from services.viewlogic_engine import ViewLogicEngine
                viewlogic_engine = ViewLogicEngine()
                logger.info(f"ğŸ‡ JRAç‰ˆViewLogicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
            
            if sub_type == 'flow':
                # å±•é–‹äºˆæƒ³ï¼ˆé«˜åº¦ãªåˆ†æç‰ˆã‚’ä½¿ç”¨ï¼‰
                logger.info(f"ViewLogicå±•é–‹äºˆæƒ³é–‹å§‹: venue={venue}, horses={race_data.get('horses', [])}")
                result = viewlogic_engine.predict_race_flow_advanced(race_data)
                logger.info(f"ViewLogicå±•é–‹äºˆæƒ³çµæœ: status={result.get('status')}, type={result.get('type')}")
                
                if result.get('status') == 'success':
                    # å¤–éƒ¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆé–¢æ•°ã‚’ä½¿ç”¨
                    from services.v2.ai_handler_format_advanced import format_flow_prediction_advanced
                    content = format_flow_prediction_advanced(result)
                    return (content, result)
                else:
                    logger.error(f"ViewLogicå±•é–‹äºˆæƒ³ã‚¨ãƒ©ãƒ¼è©³ç´°: {result}")
                    return (f"å±•é–‹äºˆæƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: {result.get('message', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}", None)
                    
            elif sub_type == 'trend':
                # ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æï¼ˆå®Ÿéš›ã®å‡ºå ´é¦¬ãƒ»é¨æ‰‹ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
                import signal
                import time
                
                # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
                def timeout_handler(signum, frame):
                    raise TimeoutError("å‚¾å‘åˆ†æãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
                
                try:
                    # 25ç§’ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šï¼ˆRenderã®30ç§’åˆ¶é™ã‚ˆã‚ŠçŸ­ãï¼‰
                    signal.signal(signal.SIGALRM, timeout_handler)
                    signal.alarm(25)
                    
                    result = viewlogic_engine.analyze_course_trend(race_data)
                    
                    # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
                    signal.alarm(0)
                    
                    if result['status'] == 'success':
                        content = self._format_trend_analysis(result)
                        return (content, result)
                    else:
                        return (f"å‚¾å‘åˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ: {result.get('message', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}", None)
                        
                except TimeoutError:
                    signal.alarm(0)  # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
                    logger.error("ViewLogicå‚¾å‘åˆ†æãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸï¼ˆ25ç§’ï¼‰")
                    return ("å‚¾å‘åˆ†æã®å‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã‚Šã™ãã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿é‡ãŒå¤šã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚", None)
                except Exception as e:
                    signal.alarm(0)  # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
                    logger.error(f"ViewLogicå‚¾å‘åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
                    return (f"å‚¾å‘åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
                    
            elif sub_type == 'recommendation':
                # æ¨å¥¨é¦¬åˆ¸ï¼ˆé¦¬åˆ¸æ¨å¥¨ã¨ã—ã¦å®Ÿè£…ï¼‰
                result = viewlogic_engine.recommend_betting_tickets(
                    race_data=race_data
                )
                
                if result['status'] == 'success':
                    content = self._format_betting_recommendations(result)
                    return (content, result)
                else:
                    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªæ¨å¥¨ã‚’æä¾›
                    return (f"""
ğŸ¯ ViewLogicæ¨å¥¨é¦¬åˆ¸
{venue} {race_number}R

ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚ç¾åœ¨ã€æ¨å¥¨é¦¬åˆ¸ã®ç”ŸæˆãŒã§ãã¾ã›ã‚“ã€‚
ä»¥ä¸‹ã®åˆ†ææ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ãã ã•ã„ï¼š

â€¢ ã€Œå±•é–‹äºˆæƒ³ã€- ãƒ¬ãƒ¼ã‚¹ã®æµã‚Œã‚’äºˆæƒ³
â€¢ ã€Œå‚¾å‘åˆ†æã€- ã‚³ãƒ¼ã‚¹ãƒ»é¨æ‰‹æˆç¸¾ã‚’åˆ†æ

ã“ã‚Œã‚‰ã®çµæœã‚’å‚è€ƒã«é¦¬åˆ¸ã‚’ã”æ¤œè¨ãã ã•ã„ã€‚
""", None)
            
            elif sub_type == 'history':
                # ä½¿ã„æ–¹æ¡ˆå†…ã®åˆ¤å®š
                if 'ä½¿ã„æ–¹' in message or 'ViewLogicï¼•èµ°ã®ä½¿ã„æ–¹' in message:
                    return self._get_viewlogic_5race_guide(race_data), None
                
                # éå»ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºï¼ˆæ–°æ©Ÿèƒ½ï¼‰
                # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰é¦¬åã¾ãŸã¯é¨æ‰‹åã‚’æŠ½å‡º
                horses = race_data.get('horses', [])
                jockeys = race_data.get('jockeys', [])
                
                # é¦¬åãƒã‚§ãƒƒã‚¯
                target_horse = None
                for horse in horses:
                    if horse in message:
                        target_horse = horse
                        break
                
                # é¨æ‰‹åãƒã‚§ãƒƒã‚¯
                target_jockey = None
                if not target_horse:
                    for jockey in jockeys:
                        if jockey and jockey in message:
                            target_jockey = jockey
                            break
                
                # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼è¡¨ç¤ºç”¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æœ€åˆã«è¿”ã™
                if target_horse:
                    progress_message = "ViewLogicéå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...\n" + target_horse + "ã®å±¥æ­´ã‚’æ¤œç´¢ã—ã¦ã„ã¾ã™..."
                elif target_jockey:
                    progress_message = "ViewLogicéå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...\n" + target_jockey + "é¨æ‰‹ã®å±¥æ­´ã‚’æ¤œç´¢ã—ã¦ã„ã¾ã™..."
                else:
                    return ("åˆ†æå¯¾è±¡ã®é¦¬åã¾ãŸã¯é¨æ‰‹åãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚", None)
                
                # å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿å–å¾—å‡¦ç†
                if target_horse:
                    # é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿å–å¾—
                    result = viewlogic_engine.get_horse_history(target_horse)
                    if result['status'] == 'success':
                        content = self._format_horse_history(result, target_horse)
                        # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨å®Ÿéš›ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’çµåˆ
                        full_content = f"{progress_message}\n\n{content}"
                        return (full_content, result)
                    else:
                        return (f"{progress_message}\n\n{target_horse}ã®éå»ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚", None)
                
                elif target_jockey:
                    # é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿å–å¾—
                    result = viewlogic_engine.get_jockey_history(target_jockey)
                    if result['status'] == 'success':
                        content = self._format_jockey_history(result, target_jockey)
                        # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨å®Ÿéš›ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’çµåˆ
                        full_content = f"{progress_message}\n\n{content}"
                        return (full_content, result)
                    else:
                        return (f"{progress_message}\n\n{target_jockey}é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚", None)
                
                else:
                    # é¦¬åã‚‚é¨æ‰‹åã‚‚è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆ
                    example_horse = horses[0] if horses else 'ãƒ‰ã‚¦ãƒ‡ãƒ¥ãƒ¼ã‚¹'
                    return (f"å‡ºèµ°é¦¬ã¾ãŸã¯é¨æ‰‹ã®åå‰ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼šã€Œ{example_horse}ã®éå»ãƒ‡ãƒ¼ã‚¿ã€", None)

            elif sub_type == 'sire':
                # ç¨®ç‰¡é¦¬åˆ†æ
                return self._generate_sire_analysis(race_data)

            else:
                return ("ViewLogicæ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ã€Œå±•é–‹ã€ã€Œå‚¾å‘ã€ã€Œæ¨å¥¨ã€ã®ã„ãšã‚Œã‹ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚", None)
                
        except ImportError as e:
            logger.error(f"ViewLogicã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return ("ViewLogicã‚¨ãƒ³ã‚¸ãƒ³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚", None)
        except Exception as e:
            import traceback
            logger.error(f"ViewLogicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            logger.error(f"ViewLogicã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹: {traceback.format_exc()}")
            logger.error(f"ViewLogicã‚¨ãƒ©ãƒ¼æ™‚ã®race_data: {race_data}")
            logger.error(f"ViewLogicã‚¨ãƒ©ãƒ¼æ™‚ã®sub_type: {sub_type}")
            return (f"ViewLogicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    def _format_flow_prediction(self, result: Dict[str, Any]) -> str:
        """å±•é–‹äºˆæƒ³çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆé«˜åº¦ãªåˆ†æç‰ˆå¯¾å¿œï¼‰"""
        lines = []
        lines.append("ğŸ‡ **ViewLogicå±•é–‹äºˆæƒ³**")
        
        # ãƒ¬ãƒ¼ã‚¹æƒ…å ±
        race_info = result.get('race_info', {})
        lines.append(f"{race_info.get('venue', '')} {race_info.get('race_number', '')}R - {race_info.get('race_name', '')}")
        if race_info.get('distance'):
            lines.append(f"è·é›¢: {race_info.get('distance', '')}")
        lines.append("")
        
        # æ–°å½¢å¼ï¼ˆpredict_race_flow_advancedï¼‰ã®å ´åˆ
        if 'pace_prediction' in result:
            return self._format_flow_prediction_advanced(result)
        
        # æ—§å½¢å¼ï¼ˆpredict_race_flowï¼‰ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        prediction = result.get('prediction', {})
        lines.append(f"**ã€ãƒšãƒ¼ã‚¹äºˆæƒ³ã€‘{prediction.get('pace', 'ä¸æ˜')}**")
        lines.append(f"ç¢ºä¿¡åº¦: {prediction.get('pace_confidence', 0)}%")
        lines.append("")
        
        # è„šè³ªåˆ†å¸ƒ
        lines.append("**ã€è„šè³ªåˆ†å¸ƒã€‘**")
        for style_data in prediction['style_distribution']:
            horses_str = ', '.join(style_data['horses']) if style_data['horses'] else ''
            lines.append(f"â€¢ {style_data['style']}: {style_data['count']}é ­")
            if horses_str:
                lines.append(f"  {horses_str}")
        lines.append("")
        
        # è©³ç´°ãªé€ƒã’é¦¬åˆ†æ
        if prediction['detailed_escapes']:
            lines.append("**ã€é€ƒã’é¦¬è©³ç´°ã€‘**")
            for escape_type, horses in prediction['detailed_escapes'].items():
                if horses:
                    lines.append(f"â€¢ {escape_type}: {', '.join(horses)}")
            lines.append("")
        
        # æœ‰åˆ©/ä¸åˆ©
        if prediction['advantaged_horses']:
            lines.append("**ğŸ¯ æœ‰åˆ©ãªé¦¬**")
            for horse in prediction['advantaged_horses']:
                lines.append(f"â€¢ {horse}")
            lines.append("")
        
        if prediction['disadvantaged_horses']:
            lines.append("**âš ï¸ ä¸åˆ©ãªé¦¬**")
            for horse in prediction['disadvantaged_horses']:
                lines.append(f"â€¢ {horse}")
            lines.append("")
        
        lines.append(f"_åˆ†æé¦¬æ•°: {result.get('analyzed_horses', 0)}/{result.get('total_horses', 0)}é ­_")
        
        return "\n".join(lines)
    
    def _format_flow_prediction_advanced(self, result: Dict[str, Any]) -> str:
        """é«˜åº¦ãªå±•é–‹äºˆæƒ³çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        lines = []
        lines.append("ğŸ‡ **ViewLogicå±•é–‹äºˆæƒ³**")
        
        # ãƒ¬ãƒ¼ã‚¹æƒ…å ±
        race_info = result.get('race_info', {})
        lines.append(f"{race_info.get('venue', '')} {race_info.get('race_number', '')}R")
        if race_info.get('distance'):
            lines.append(f"è·é›¢: {race_info.get('distance', '')}")
        lines.append("")
        
        # ãƒšãƒ¼ã‚¹äºˆæƒ³
        pace_pred = result.get('pace_prediction', {})
        pace = pace_pred.get('pace', 'ä¸æ˜')
        confidence = pace_pred.get('confidence', 0)
        lines.append(f"**ã€ãƒšãƒ¼ã‚¹äºˆæƒ³ã€‘{pace}**")
        lines.append(f"ç¢ºä¿¡åº¦: {confidence}%")
        lines.append("")
        
        # è©³ç´°ãªè„šè³ªåˆ†é¡
        detailed_styles = result.get('detailed_styles', {})
        lines.append("**ã€å±•é–‹äºˆæƒ³ã€‘**")
        
        for main_style, sub_styles in detailed_styles.items():
            has_horses = any(horses for horses in sub_styles.values())
            if has_horses:
                lines.append(f"\nâ—† {main_style}")
                for sub_style, horses in sub_styles.items():
                    if horses:
                        horses_str = ', '.join(horses[:3])  # æœ€åˆã®3é ­ã¾ã§è¡¨ç¤º
                        if len(horses) > 3:
                            horses_str += f" ä»–{len(horses)-3}é ­"
                        lines.append(f"  â€¢ {sub_style}: {horses_str}")
        lines.append("")
        
        # ãƒ¬ãƒ¼ã‚¹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚´ãƒ¼ãƒ«äºˆæƒ³ã®ã¿ï¼‰
        simulation = result.get('race_simulation', {})
        if simulation and 'finish' in simulation:
            lines.append("**ã€ä¸Šä½äºˆæƒ³ã€‘**")
            for i, entry in enumerate(simulation['finish'][:5], 1):
                horse = entry.get('horse_name', 'ä¸æ˜')
                lines.append(f"{i}. {horse}")
            lines.append("")
        
        # ãƒšãƒ¼ã‚¹ã«å¿œã˜ãŸç‹™ã„ç›®
        lines.append("**ã€ç‹™ã„ç›®ã€‘**")
        if 'ãƒã‚¤ãƒšãƒ¼ã‚¹' in pace:
            lines.append("â€¢ å¾Œæ–¹å¾…æ©Ÿã®å·®ã—ãƒ»è¿½è¾¼é¦¬ãŒæœ‰åˆ©")
            lines.append("â€¢ å‰åŠé£›ã°ã™é€ƒã’ãƒ»å…ˆè¡Œé¦¬ã¯è‹¦æˆ¦äºˆæƒ³")
        elif 'ã‚¹ãƒ­ãƒ¼ãƒšãƒ¼ã‚¹' in pace:
            lines.append("â€¢ å‰æ®‹ã‚Šã®å¯èƒ½æ€§å¤§")
            lines.append("â€¢ é€ƒã’ãƒ»å…ˆè¡Œé¦¬ã‚’é‡è¦–")
            lines.append("â€¢ è¿½è¾¼ä¸€è¾ºå€’ã¯å³ã—ã„å±•é–‹")
        else:
            lines.append("â€¢ å¹³å‡ãƒšãƒ¼ã‚¹ã§åŠ›å‹è² ")
            lines.append("â€¢ ç·åˆåŠ›ã®é«˜ã„é¦¬ã‚’é‡è¦–")
        
        return "\n".join(lines)
    
    def _format_trend_analysis(self, result: Dict[str, Any]) -> str:
        """ã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆæ–°ã—ã„4é …ç›®æ§‹é€ å¯¾å¿œï¼‰"""
        lines = []
        lines.append("ğŸ“Š **ViewLogicã‚³ãƒ¼ã‚¹å‚¾å‘åˆ†æ**")
        
        course = result['course_info']
        course_key = course.get('course_key', f"{course['venue']}ã‚³ãƒ¼ã‚¹")
        lines.append(f"{course_key}")
        lines.append("")
        
        trends = result['trends']
        
        # 1. å‡ºå ´é¦¬ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾è¤‡å‹ç‡
        if trends.get('horse_course_performance'):
            lines.append("**ã€å‡ºå ´é¦¬ã®å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ã€‘**")
            horses = trends['horse_course_performance']
            
            # æˆç¸¾ãŒã‚ã‚‹é¦¬ã®ã¿è¡¨ç¤º
            horses_with_data = [h for h in horses if h.get('status') == 'found' and h.get('total_runs', 0) > 0]
            horses_no_data = [h for h in horses if h.get('status') != 'found' or h.get('total_runs', 0) == 0]
            
            if horses_with_data:
                for i, horse in enumerate(horses_with_data, 1):
                    total_runs = horse.get('total_runs', 0)
                    fukusho_rate = horse.get('fukusho_rate', 0.0)
                    lines.append(f"{i}. **{horse['horse_name']}**: {total_runs}æˆ¦ è¤‡å‹ç‡{fukusho_rate:.1f}%")
                
                # å®Œçµãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                lines.append("")
                lines.append(f"ä»¥ä¸ŠãŒå½“ã‚³ãƒ¼ã‚¹ã§å‡ºèµ°çµŒé¨“ã®ã‚ã‚‹{len(horses_with_data)}é ­ã§ã™ã€‚")
                if horses_no_data:
                    no_data_names = [h['horse_name'] for h in horses_no_data[:5]]  # æœ€åˆã®5é ­ã®ã¿è¡¨ç¤º
                    if len(horses_no_data) > 5:
                        lines.append(f"ãã®ä»–ã®é¦¬ï¼ˆ{', '.join(no_data_names)}ä»–ï¼‰ã¯å½“ã‚³ãƒ¼ã‚¹ã§ã®å‡ºèµ°çµŒé¨“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
                    else:
                        lines.append(f"ãã®ä»–ã®é¦¬ï¼ˆ{', '.join(no_data_names)}ï¼‰ã¯å½“ã‚³ãƒ¼ã‚¹ã§ã®å‡ºèµ°çµŒé¨“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
            else:
                lines.append("å‡ºå ´é¦¬å…¨é ­ãŒå½“ã‚³ãƒ¼ã‚¹ã§ã®å‡ºèµ°çµŒé¨“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
                lines.append("éå»ã®ãƒ‡ãƒ¼ã‚¿ãŒãªã„ãŸã‚ã€ä»–ã®è¦ç´ ã§ã®åˆ¤æ–­ãŒé‡è¦ã«ãªã‚Šã¾ã™ã€‚")
            lines.append("")
        
        # 2. é¨æ‰‹ã®è©²å½“ã‚³ãƒ¼ã‚¹æˆç¸¾è¤‡å‹ç‡
        if trends.get('jockey_course_performance'):
            lines.append("**ã€é¨æ‰‹ã®å½“ã‚³ãƒ¼ã‚¹æˆç¸¾ã€‘**")
            jockeys = trends['jockey_course_performance']
            
            # æˆç¸¾ãŒã‚ã‚‹é¨æ‰‹ã®ã¿è¡¨ç¤º
            jockeys_with_data = [j for j in jockeys if j.get('status') == 'found' and j.get('total_runs', 0) > 0]
            jockeys_no_data = [j for j in jockeys if j.get('status') != 'found' or j.get('total_runs', 0) == 0]
            
            if jockeys_with_data:
                for i, jockey in enumerate(jockeys_with_data, 1):
                    total_runs = jockey.get('total_runs', 0)
                    win_rate = jockey.get('win_rate', 0.0)
                    fukusho_rate = jockey.get('fukusho_rate', 0.0)
                    # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç›´è¿‘5æˆ¦ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ä¿æŒ
                    display_runs = f"ç›´è¿‘{total_runs}æˆ¦" if total_runs <= 5 else f"{total_runs}æˆ¦"
                    lines.append(f"{i}. **{jockey['jockey_name']}**: {display_runs} å‹ç‡{win_rate:.1f}% è¤‡å‹ç‡{fukusho_rate:.1f}%")
                
                # å®Œçµãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                lines.append("")
                lines.append(f"ä»¥ä¸ŠãŒå½“ã‚³ãƒ¼ã‚¹ã§é¨ä¹—çµŒé¨“ã®ã‚ã‚‹{len(jockeys_with_data)}åã§ã™ï¼ˆç›´è¿‘ãƒ‡ãƒ¼ã‚¿ã‚ˆã‚Šï¼‰ã€‚")
                if jockeys_no_data:
                    lines.append(f"ãã®ä»–ã®é¨æ‰‹ã¯å½“ã‚³ãƒ¼ã‚¹ã§ã®é¨ä¹—çµŒé¨“ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆç›´è¿‘5æˆ¦å†…ï¼‰ã€‚")
            else:
                lines.append("å‡ºå ´é¨æ‰‹å…¨å“¡ãŒå½“ã‚³ãƒ¼ã‚¹ã§ã®é¨ä¹—çµŒé¨“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
                lines.append("é¨æ‰‹ã®é©æ€§ã‚ˆã‚Šã‚‚é¦¬ã®èƒ½åŠ›ã‚’é‡è¦–ã—ãŸæ–¹ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚")
            lines.append("")
        
        # 3. é¨æ‰‹ã®æ é †åˆ¥è¤‡å‹ç‡
        if trends.get('jockey_post_performance'):
            lines.append("**ã€é¨æ‰‹ã®æ é †åˆ¥æˆç¸¾ã€‘**")
            jockey_post_data = trends['jockey_post_performance']
            
            # ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
            logger.info(f"ğŸ é¨æ‰‹æ é †åˆ¥æˆç¸¾ãƒ‡ãƒ¼ã‚¿å–å¾—: type={type(jockey_post_data)}, keys={list(jockey_post_data.keys()) if isinstance(jockey_post_data, dict) else 'not dict'}")
            if isinstance(jockey_post_data, dict) and jockey_post_data:
                first_key = list(jockey_post_data.keys())[0]
                logger.info(f"   ã‚µãƒ³ãƒ—ãƒ«ï¼ˆ{first_key}ï¼‰: {jockey_post_data[first_key]}")
            
            # jockey_post_dataã®å‹ãƒã‚§ãƒƒã‚¯
            if jockey_post_data and isinstance(jockey_post_data, dict):
                # å„é¨æ‰‹ã®å€‹åˆ¥æˆç¸¾ã‚’è¡¨ç¤º
                jockey_count = 0
                for jockey_name, post_stats in jockey_post_data.items():
                    # post_statsã®å‹ãƒã‚§ãƒƒã‚¯
                    if not isinstance(post_stats, dict):
                        logger.error(f"é¨æ‰‹ {jockey_name} ã®post_statsãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(post_stats)}")
                        continue
                    
                    # ä»Šå›ã®æ ç•ªæƒ…å ±ã‚’å–å¾—
                    assigned_post = post_stats.get('assigned_post')
                    post_category = post_stats.get('post_category')
                    
                    # è©²å½“ã™ã‚‹æ ç•ªã§ã®æˆç¸¾ã‚’å–å¾—
                    if assigned_post and post_category:
                        # assigned_post_statsãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°all_post_statsã‹ã‚‰å–å¾—
                        assigned_stats = post_stats.get('assigned_post_stats')
                        if not assigned_stats and post_category:
                            all_stats = post_stats.get('all_post_stats', {})
                            if isinstance(all_stats, dict):
                                assigned_stats = all_stats.get(post_category, {})
                        
                        if assigned_stats and isinstance(assigned_stats, dict):
                            race_count = assigned_stats.get('race_count', 0)
                            fukusho_rate = assigned_stats.get('fukusho_rate', 0.0)
                            
                            if race_count > 0:
                                jockey_count += 1
                                # è¤‡å‹ç‡ã‚’æ­£å¸¸ç¯„å›²ï¼ˆ0-100%ï¼‰ã«ä¿®æ­£
                                if fukusho_rate > 100:
                                    # ç•°å¸¸ã«å¤§ãã„å€¤ã¯100ã§å‰²ã‚‹
                                    display_rate = fukusho_rate / 100
                                elif fukusho_rate > 1.0:
                                    # 1ã‚’è¶…ãˆã‚‹å€¤ã¯ãã®ã¾ã¾ä½¿ç”¨ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆå€¤ï¼‰
                                    display_rate = fukusho_rate
                                else:
                                    # 0.0-1.0ã®å ´åˆã¯100å€ã—ã¦ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆå€¤ã«
                                    display_rate = fukusho_rate * 100
                                # 100%ã‚’ä¸Šé™ã¨ã™ã‚‹
                                display_rate = min(display_rate, 100.0)
                                # ãƒ¬ãƒ¼ã‚¹æ•°ã¯è¡¨ç¤ºã›ãšã€è¤‡å‹ç‡ã®ã¿ã‚’è¡¨ç¤º
                                lines.append(f"{jockey_count}. **{jockey_name}**ï¼ˆ{assigned_post}æ ï¼‰: è¤‡å‹ç‡{display_rate:.1f}%")
                            else:
                                jockey_count += 1
                                lines.append(f"{jockey_count}. **{jockey_name}**ï¼ˆ{assigned_post}æ ï¼‰: ãƒ‡ãƒ¼ã‚¿ãªã—")
                        else:
                            jockey_count += 1
                            lines.append(f"{jockey_count}. **{jockey_name}**ï¼ˆ{assigned_post}æ ï¼‰: ãƒ‡ãƒ¼ã‚¿ãªã—")
                    else:
                        # æ ç•ªæƒ…å ±ãŒãªã„å ´åˆã¯å…¨ä½“ã®æˆç¸¾ã‚’è¡¨ç¤º
                        all_stats = post_stats.get('all_post_stats', {})
                        if isinstance(all_stats, dict):
                            total_races = 0
                            total_fukusho = 0
                            for category, stats in all_stats.items():
                                if isinstance(stats, dict):
                                    races = stats.get('race_count', 0)
                                    rate = stats.get('fukusho_rate', 0.0)
                                    if races > 0:
                                        total_races += races
                                        total_fukusho += races * rate
                            
                            if total_races > 0:
                                avg_fukusho = total_fukusho / total_races
                                jockey_count += 1
                                # å…¨ä½“æˆç¸¾ã§ã‚‚åŒã˜æ­£è¦åŒ–ã‚’é©ç”¨
                                if avg_fukusho > 100:
                                    display_avg = avg_fukusho / 100
                                elif avg_fukusho > 1.0:
                                    display_avg = avg_fukusho
                                else:
                                    display_avg = avg_fukusho * 100
                                # 100%ã‚’ä¸Šé™ã¨ã™ã‚‹
                                display_avg = min(display_avg, 100.0)
                                lines.append(f"{jockey_count}. **{jockey_name}**: è¤‡å‹ç‡{display_avg:.1f}%")
                            else:
                                jockey_count += 1
                                lines.append(f"{jockey_count}. **{jockey_name}**: ãƒ‡ãƒ¼ã‚¿ãªã—")
                        else:
                            jockey_count += 1
                            lines.append(f"{jockey_count}. **{jockey_name}**: ãƒ‡ãƒ¼ã‚¿ãªã—")
                
                # å®Œçµãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                if jockey_count > 0:
                    lines.append("")
                    lines.append(f"ä»¥ä¸ŠãŒå‡ºå ´é¨æ‰‹{jockey_count}åã®æ é †åˆ¥æˆç¸¾ã§ã™ã€‚")
                else:
                    lines.append("å‡ºå ´é¨æ‰‹ã®æ é †åˆ¥ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
                    
            elif jockey_post_data and not isinstance(jockey_post_data, dict):
                logger.error(f"jockey_post_dataãŒè¾æ›¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: type={type(jockey_post_data)}")
                lines.append("â€¢ æ é †åˆ¥ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
            else:
                lines.append("â€¢ æ é †åˆ¥ãƒ‡ãƒ¼ã‚¿ãªã—")
            lines.append("")
        

        
        # ã‚¤ãƒ³ã‚µã‚¤ãƒˆ
        if result.get('insights'):
            lines.append("**ğŸ’¡ ãƒã‚¤ãƒ³ãƒˆ**")
            for insight in result['insights']:
                lines.append(f"â€¢ {insight}")
        
        return "\n".join(lines)
    
    def _format_daily_trend(self, result: Dict[str, Any]) -> str:
        """å½“æ—¥å‚¾å‘åˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        lines = []
        lines.append("ğŸ“ˆ **ViewLogicå½“æ—¥å‚¾å‘**")
        lines.append(f"{result['venue']} - {result['date']}")
        lines.append(f"å®Ÿæ–½æ¸ˆã¿: {result['races_completed']}R")
        lines.append("")
        
        trends = result['trends']
        
        # è„šè³ªåˆ¥æˆç¸¾
        if trends.get('running_style_performance'):
            lines.append("**ã€è„šè³ªåˆ¥æˆç¸¾ã€‘**")
            for style, perf in trends['running_style_performance'].items():
                win_rate = perf.get('win_rate', 0)
                if win_rate > 1:
                    win_rate = win_rate / 100
                wins = perf.get('wins', 0)
                runs = perf.get('runs', 0)
                lines.append(f"â€¢ {style}: {wins}å‹/{runs}é ­ (å‹ç‡{win_rate:.0%})")
            lines.append("")
        
        # å¥½èª¿é¨æ‰‹
        if trends.get('hot_jockeys'):
            lines.append("**ã€å¥½èª¿é¨æ‰‹ã€‘**")
            for jockey in trends['hot_jockeys']:
                lines.append(f"â€¢ {jockey['name']}: {jockey['wins']}å‹/{jockey['runs']}é¨ä¹—")
            lines.append("")
        
        # é¦¬å ´çŠ¶æ…‹
        lines.append(f"**ã€é¦¬å ´ã€‘** {trends.get('track_condition', 'è‰¯')} / {trends.get('track_bias', 'ãƒ•ãƒ©ãƒƒãƒˆ')}")
        lines.append("")
        
        # æ¨å¥¨äº‹é …
        if result.get('recommendations'):
            lines.append("**â­ æ¨å¥¨**")
            for rec in result['recommendations']:
                lines.append(f"â€¢ {rec}")
        
        return "\n".join(lines)
    
    def _create_imlogic_prompt(self, settings: Dict[str, Any]) -> str:
        """
        IMLogicè¨­å®šã‹ã‚‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
        """
        weights = settings.get('weights', {})
        horse_ratio = settings.get('horse_ratio', 70)
        jockey_ratio = settings.get('jockey_ratio', 30)
        
        prompt_parts = [
            f"IMLogicã‚«ã‚¹ã‚¿ãƒ è¨­å®šã«ã‚ˆã‚‹åˆ†æ",
            f"é¦¬ã®èƒ½åŠ›: {horse_ratio}%ã€é¨æ‰‹ã®èƒ½åŠ›: {jockey_ratio}%ã®æ¯”ç‡ã§è©•ä¾¡",
            "",
            "é‡è¦–ã™ã‚‹é …ç›®ï¼ˆå„ªå…ˆé †ä½ï¼‰:"
        ]
        
        # é‡ã¿ä»˜ã‘ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å„ªå…ˆé †ä½ã‚’æ±ºå®š
        sorted_weights = sorted(
            weights.items(),
            key=lambda x: x[1],
            reverse=True
        )
        
        for i, (item, weight) in enumerate(sorted_weights, 1):
            if weight > 0:
                item_name = self._get_item_display_name(item)
                prompt_parts.append(f"{i}. {item_name} (é‡è¦åº¦: {weight})")
        
        return "\n".join(prompt_parts)
    
    def _get_item_display_name(self, item_key: str) -> str:
        """
        é …ç›®ã‚­ãƒ¼ã‹ã‚‰è¡¨ç¤ºåã‚’å–å¾—
        """
        display_names = {
            'distance_aptitude': 'è·é›¢é©æ€§',
            'track_aptitude': 'ã‚³ãƒ¼ã‚¹é©æ€§',
            'growth_potential': 'æˆé•·åŠ›',
            'trainer_skill': 'èª¿æ•™å¸«',
            'breakthrough_potential': 'çˆ†ç™ºåŠ›',
            'strength_score': 'å¼·ã•',
            'winning_percentage': 'å‹ç‡',
            'recent_performance': 'è¿‘èµ°',
            'course_experience': 'ã‚³ãƒ¼ã‚¹çµŒé¨“',
            'distance_experience': 'è·é›¢å®Ÿç¸¾',
            'stability': 'å®‰å®šæ„Ÿ',
            'jockey_compatibility': 'é¨æ‰‹ç›¸æ€§'
        }
        return display_names.get(item_key, item_key)
    
    async def process_message(
        self,
        message: str,
        race_data: Dict[str, Any],
        ai_type: Optional[str] = None,
        settings: Optional[Dict[str, Any]] = None,
        user_email: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        çµ±åˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
        
        Returns:
            {
                'content': str,  # å¿œç­”å†…å®¹
                'ai_type': str,  # ä½¿ç”¨ã—ãŸAI
                'sub_type': str,  # ã‚µãƒ–ã‚¿ã‚¤ãƒ—
                'analysis_data': dict  # åˆ†æãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ã‚Œã°ï¼‰
            }
        """
        # ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒï¼ˆdetermine_ai_typeã§ä½¿ç”¨ï¼‰
        self.current_race_data = race_data
        
        # ã¾ãšå‡ºèµ°é¦¬ãƒã‚§ãƒƒã‚¯ï¼ˆAIåˆ¤å®šã®å‰ã«å¿…ãšå®Ÿè¡Œï¼‰
        venue = race_data.get('venue', '')
        race_number = race_data.get('race_number', '')
        race_horses = race_data.get('horses', [])

        # ãƒ¬ãƒ¼ã‚¹ã«å­˜åœ¨ã—ãªã„é¦¬åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        # ã‚«ã‚¿ã‚«ãƒŠã®é¦¬åã‚’æ­£ã—ãæŠ½å‡ºï¼ˆã‚¡-ãƒ´ãƒ¼ã‚’ä½¿ç”¨ï¼‰
        potential_horses = re.findall(r'[ã‚¡-ãƒ´ãƒ¼]+', message)

        for potential_horse in potential_horses:
            if len(potential_horse) >= 3:
                is_in_race = False
                for race_horse in race_horses:
                    if potential_horse in race_horse or race_horse in potential_horse:
                        is_in_race = True
                        break

                # åŠ©è©ãƒã‚§ãƒƒã‚¯ã‚’ç·©å’Œï¼ˆé¦¬åå˜ä½“ã§ã‚‚æ¤œå‡ºï¼‰
                if not is_in_race:
                    common_words = ['ãƒ‡ãƒ¼ã‚¿', 'ãƒ¬ãƒ¼ã‚¹', 'ã‚¹ã‚³ã‚¢', 'ãƒã‚¤ãƒ³ãƒˆ', 'ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¨ãƒ©ãƒ¼', 'ViewLogic', 'IMLogic', 'DLogic', 'ILogic', 'FLogic', 'ãƒ•ã‚§ã‚¢', 'ã‚ªãƒƒã‚º', 'ãƒ­ã‚¸ãƒƒã‚¯', 'ã‚¨ãƒ•ãƒ­ã‚¸ãƒƒã‚¯', 'ã‚³ãƒ©ãƒ ']  # 'ã‚³ãƒ©ãƒ 'ã‚’é™¤å¤–å˜èªã«è¿½åŠ 
                    if potential_horse not in common_words:
                        return {
                            'content': f"ã€Œ{potential_horse}ã€ã¯ã€{venue} {race_number}Rã«ã¯å‡ºèµ°ã—ã¾ã›ã‚“ã€‚\nã“ã®ãƒ¬ãƒ¼ã‚¹ã®å‡ºèµ°é¦¬ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™:\n" + "ã€".join(race_horses),
                            'ai_type': 'imlogic',  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§imlogicã‚’è¿”ã™
                            'sub_type': 'out_of_scope',
                            'analysis_data': None
                        }
        
        # æ¬¡ã«ãƒ¬ãƒ¼ã‚¹å¤–ã®è³ªå•ã‚’ãƒã‚§ãƒƒã‚¯
        if self._is_out_of_scope(message, race_data):
            # ä»–ã®ãƒ¬ãƒ¼ã‚¹ã‚„é–‹å‚¬å ´ã¸ã®è¨€åŠã®å ´åˆ
            return {
                'content': f"ã“ã®ãƒãƒ£ãƒƒãƒˆã¯{venue} {race_number}Rå°‚ç”¨ã§ã™ã€‚ä»–ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦ã¯æ–°ã—ã„ãƒãƒ£ãƒƒãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚",
                'ai_type': 'imlogic',  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§imlogicã‚’è¿”ã™
                'ai_display_name': 'IMLogic AI',
                'sub_type': 'out_of_scope',
                'analysis_data': None
            }
        
        # AI ã‚¿ã‚¤ãƒ—ã®æ±ºå®šï¼ˆãƒ¬ãƒ¼ã‚¹å¤–ãƒã‚§ãƒƒã‚¯ã®å¾Œã«ç§»å‹•ï¼‰
        if ai_type:
            determined_ai = ai_type
            logger.info(f"AIåˆ¤å®š(æ‰‹å‹•æŒ‡å®š): ai_type={ai_type}, determined_ai={determined_ai}")
            # ViewLogicã®å ´åˆã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã‚’æ±ºå®š
            if ai_type == 'viewlogic':
                _, sub_type = self.determine_ai_type(message)
                # ViewLogicä»¥å¤–ãŒåˆ¤å®šã•ã‚ŒãŸå ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«
                if sub_type not in ['flow', 'trend', 'opinion']:
                    sub_type = 'manual'
            elif ai_type == 'flogic':
                sub_type = 'analysis'  # F-Logicã¯åˆ†æã‚¿ã‚¤ãƒ—
            elif ai_type == 'metalogic':
                sub_type = 'analysis'  # MetaLogicã¯åˆ†æã‚¿ã‚¤ãƒ—
            else:
                sub_type = 'manual'
        else:
            determined_ai, sub_type = self.determine_ai_type(message)
            logger.info(f"AIåˆ¤å®š(è‡ªå‹•): message='{message[:50]}...', determined_ai={determined_ai}, sub_type={sub_type}")

        # AIç¨®åˆ¥ã«å¿œã˜ã¦å‡¦ç†
        analysis_data = None
        if determined_ai == 'imlogic':
            result = await self.process_imlogic_message(message, race_data, settings)
            # ã‚¿ãƒ—ãƒ«ã¾ãŸã¯è¾æ›¸ã®å ´åˆã¯åˆ†è§£
            if isinstance(result, tuple):
                content, analysis_data = result
            elif isinstance(result, dict):
                content = result.get('content', '')
                analysis_data = result.get('analysis_data')
            else:
                content = result
        elif determined_ai == 'dlogic':
            result = await self.process_dlogic_message(message, race_data)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        elif determined_ai == 'flogic':
            result = await self.process_flogic_message(message, race_data)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        elif determined_ai == 'ilogic':
            result = await self.process_ilogic_message(message, race_data)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        elif determined_ai == 'metalogic':
            result = await self.process_metalogic_message(message, race_data)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        elif determined_ai == 'column':
            logger.info(f"ã‚³ãƒ©ãƒ å‡¦ç†é–‹å§‹: determined_ai={determined_ai}, user_email={user_email}")
            # ã‚³ãƒ©ãƒ è¡¨ç¤ºã®å‡¦ç† - Supabaseã‹ã‚‰ã‚³ãƒ©ãƒ ã‚’å–å¾—ã—ã¦è¿”ã™
            from supabase import create_client
            from datetime import datetime
            import os

            def strip_html_tags(text):
                """HTMLã‚¿ã‚°ã‚’é™¤å»ã—ã¦ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›"""
                # HTMLã‚¿ã‚°ã‚’é™¤å»
                clean = re.compile('<.*?>')
                text = re.sub(clean, '', text)
                # HTMLã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’å¤‰æ›
                text = text.replace('&nbsp;', ' ')
                text = text.replace('&lt;', '<')
                text = text.replace('&gt;', '>')
                text = text.replace('&amp;', '&')
                text = text.replace('&quot;', '"')
                text = text.replace('&#39;', "'")
                return text.strip()

            supabase_url = os.environ.get("SUPABASE_URL")
            supabase_key = os.environ.get("SUPABASE_SERVICE_ROLE_KEY")
            supabase = create_client(supabase_url, supabase_key)

            # ç®¡ç†è€…ãƒã‚§ãƒƒã‚¯
            is_admin = user_email in ['goldbenchan@gmail.com', 'kusanokiyoshi1@gmail.com']

            # ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆLINEé€£æºçŠ¶æ…‹ã¨ãƒã‚¤ãƒ³ãƒˆæ®‹é«˜ï¼‰
            user_has_line = False
            user_points = 0
            user_id = None
            if user_email:
                try:
                    # v2_usersãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’ä¸€æ‹¬å–å¾—ï¼ˆid, line_user_idï¼‰
                    users_response = supabase.table('v2_users').select('id, line_user_id').eq('email', user_email).execute()

                    if users_response.data and len(users_response.data) > 0:
                        user_data = users_response.data[0]
                        user_id = user_data.get('id')
                        line_user_id = user_data.get('line_user_id')
                        user_has_line = line_user_id is not None and line_user_id != ''
                        logger.info(f"LINEé€£æºåˆ¤å®š: line_user_id={line_user_id}, user_has_line={user_has_line}")

                        # user_idã§ãƒã‚¤ãƒ³ãƒˆæ®‹é«˜ã‚’ç¢ºèª
                        if user_id:
                            points_response = supabase.table('v2_user_points').select('current_points').eq('user_id', user_id).execute()
                            if points_response.data and len(points_response.data) > 0:
                                user_points = points_response.data[0].get('current_points', 0)

                    logger.info(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—: email={user_email}, is_admin={is_admin}, has_line={user_has_line}, points={user_points}")
                except Exception as e:
                    logger.error(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼: {str(e)}")

            # race_idã‚’æ§‹æˆï¼ˆç®¡ç†è€…ãƒ‘ãƒãƒ«å½¢å¼ã«åˆã‚ã›ã‚‹ï¼‰
            race_date = race_data.get('race_date', '')
            year = race_date.split('-')[0] if race_date else '2025'
            venue_map = {
                'ä¸­å±±': 'nakayama', 'æ±äº¬': 'tokyo', 'é˜ªç¥': 'hanshin', 'äº¬éƒ½': 'kyoto',
                'ä¸­äº¬': 'chukyo', 'æ–°æ½Ÿ': 'niigata', 'ç¦å³¶': 'fukushima', 'æœ­å¹Œ': 'sapporo',
                'å‡½é¤¨': 'hakodate', 'å°å€‰': 'kokura', 'å¤§äº•': 'ooi', 'å·å´': 'kawasaki',
                'æµ¦å’Œ': 'urawa', 'èˆ¹æ©‹': 'funabashi'
            }
            venue_code = venue_map.get(race_data.get('venue', ''), race_data.get('venue', '').lower())
            race_id = f"{year}_{venue_code}_r{race_data.get('race_number', '')}"

            # ã‚³ãƒ©ãƒ ã‚’å–å¾—
            logger.info(f"ã‚³ãƒ©ãƒ æ¤œç´¢: race_id={race_id}")
            response = supabase.table('v2_columns').select('*').eq('race_id', race_id).eq('display_in_llm', True).eq('is_published', True).execute()

            if response.data and len(response.data) > 0:
                columns_html = "## ã“ã®ãƒ¬ãƒ¼ã‚¹ã®ã‚³ãƒ©ãƒ \n\n"
                logger.info(f"å–å¾—ã—ãŸã‚³ãƒ©ãƒ æ•°: {len(response.data)}")
                for col in response.data:
                    logger.info(f"ã‚³ãƒ©ãƒ : title={col.get('title')}, access_type={col.get('access_type')}, required_points={col.get('required_points')}")

                    # access_typeã‚’å–å¾—ï¼ˆNull/ç©ºæ–‡å­—å¯¾å¿œï¼‰
                    actual_access_type = col.get('access_type')
                    if actual_access_type is None or actual_access_type == '':
                        actual_access_type = 'free'
                        logger.warning(f"access_typeãŒNullã¾ãŸã¯ç©ºã®ãŸã‚ã€freeã¨ã—ã¦æ‰±ã„ã¾ã™")
                    # æ–‡å­—åˆ—ã®å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤
                    actual_access_type = str(actual_access_type).strip() if actual_access_type else 'free'

                    # ã‚¢ã‚¯ã‚»ã‚¹ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ
                    if actual_access_type == 'free':
                        access_text = "ç„¡æ–™"
                    elif actual_access_type == 'line_only' or actual_access_type == 'line_linked':  # line_linkedã‚‚ã‚µãƒãƒ¼ãƒˆ
                        access_text = "LINEé€£æºé™å®š"
                    elif actual_access_type == 'paid' or actual_access_type == 'point_required':
                        access_text = f"{col.get('required_points', 1)}ãƒã‚¤ãƒ³ãƒˆ"
                    else:
                        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚±ãƒ¼ã‚¹ - å€¤ã‚’æ˜ç¤º
                        access_text = f"ä¸æ˜({actual_access_type})"
                        logger.warning(f"äºˆæœŸã—ãªã„access_type: '{actual_access_type}'")

                    columns_html += f"### ğŸ“ {col['title']} ({access_text})\n"

                    # summaryã‚‚HTMLã‚¿ã‚°é™¤å»
                    summary = strip_html_tags(col.get('summary', ''))
                    if summary:
                        columns_html += f"{summary}\n\n"

                    # ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãƒã‚§ãƒƒã‚¯
                    can_access = False
                    access_reason = ""

                    logger.info(f"ã‚¢ã‚¯ã‚»ã‚¹ãƒã‚§ãƒƒã‚¯é–‹å§‹: access_type={actual_access_type}, user_has_line={user_has_line}, user_points={user_points}")

                    if actual_access_type == 'free':
                        # ç„¡æ–™ã‚³ãƒ©ãƒ ã¯èª°ã§ã‚‚ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
                        can_access = True
                        logger.info("â†’ ç„¡æ–™ã‚³ãƒ©ãƒ ã®ãŸã‚ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯")
                    elif actual_access_type == 'line_only' or actual_access_type == 'line_linked':  # line_linkedã‚‚ã‚µãƒãƒ¼ãƒˆ
                        # LINEé€£æºè€…é™å®šã‚³ãƒ©ãƒ 
                        # ç®¡ç†è€…ã¯ç„¡æ–™ã§é–²è¦§å¯èƒ½
                        if is_admin:
                            can_access = True
                            logger.info("â†’ ç®¡ç†è€…ã®ãŸã‚LINEé€£æºãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—")
                        elif user_has_line:
                            can_access = True
                            logger.info("â†’ LINEé€£æºæ¸ˆã¿ã®ãŸã‚ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯")
                        else:
                            access_reason = "ğŸ“± **ã“ã®ã‚³ãƒ©ãƒ ã®æœ¬æ–‡ã‚’èª­ã‚€ã«ã¯LINEé€£æºãŒå¿…è¦ã§ã™**\n\n[ãƒã‚¤ãƒšãƒ¼ã‚¸ã‹ã‚‰LINEé€£æºã‚’è¡Œã£ã¦ãã ã•ã„]"
                            logger.info(f"â†’ LINEæœªé€£æºã®ãŸã‚ã‚¢ã‚¯ã‚»ã‚¹æ‹’å¦ (user_has_line={user_has_line}, line_user_idå­˜åœ¨={user_has_line})")
                    elif actual_access_type == 'paid' or actual_access_type == 'point_required':
                        # ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»ã‚³ãƒ©ãƒ 
                        required_points = col.get('required_points', 1)

                        # ç®¡ç†è€…ã¯ç„¡æ–™ã§é–²è¦§å¯èƒ½
                        if is_admin:
                            can_access = True
                            logger.info("â†’ ç®¡ç†è€…ã®ãŸã‚ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»ã‚’ã‚¹ã‚­ãƒƒãƒ—")
                        else:
                            # æ—¢èª­ãƒã‚§ãƒƒã‚¯
                            if user_id:
                                read_check = supabase.table('v2_column_reads').select('id').eq('column_id', col['id']).eq('user_id', user_id).execute()
                                if read_check.data:
                                    # æ—¢èª­ã®å ´åˆã¯ç„¡æ–™ã§è¡¨ç¤º
                                    can_access = True
                                    logger.info(f"â†’ æ—¢èª­ã®ãŸã‚ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»ãªã—")
                                elif user_points >= required_points:
                                    # åˆå›é–²è¦§ã§ãƒã‚¤ãƒ³ãƒˆååˆ†
                                    can_access = True
                                    points_consumed = False
                                    # ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»å‡¦ç†
                                    try:
                                        # ãƒã‚¤ãƒ³ãƒˆæ¸›ç®—
                                        new_points = user_points - required_points
                                        update_response = supabase.table('v2_user_points').update({
                                            'current_points': new_points,
                                            'updated_at': datetime.now().isoformat()
                                        }).eq('user_id', user_id).execute()

                                        # æ—¢èª­è¨˜éŒ²ã‚’ä½œæˆ
                                        read_record = supabase.table('v2_column_reads').insert({
                                            'column_id': col['id'],
                                            'user_id': user_id,
                                            'read_at': datetime.now().isoformat()
                                        }).execute()

                                        points_consumed = True
                                        logger.info(f"â†’ {required_points}ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»ã—ã¦è¡¨ç¤º")
                                    except Exception as e:
                                        logger.error(f"ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»å‡¦ç†ã‚¨ãƒ©ãƒ¼: {str(e)}")
                                        can_access = False
                                        access_reason = "âš ï¸ **ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ**\n\nã—ã°ã‚‰ãã—ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚"
                                else:
                                    access_reason = f"ğŸ’° **ã“ã®ã‚³ãƒ©ãƒ ã®æœ¬æ–‡ã‚’èª­ã‚€ã«ã¯{required_points}ãƒã‚¤ãƒ³ãƒˆãŒå¿…è¦ã§ã™**\n\nç¾åœ¨ã®æ®‹é«˜: {user_points}ãƒã‚¤ãƒ³ãƒˆ\nä¸è¶³ãƒã‚¤ãƒ³ãƒˆ: {required_points - user_points}ãƒã‚¤ãƒ³ãƒˆ\n\n[ãƒã‚¤ãƒ³ãƒˆã‚’è³¼å…¥ã™ã‚‹]"
                    else:
                        # äºˆæœŸã—ãªã„access_typeã®å ´åˆ
                        logger.error(f"æœªå‡¦ç†ã®access_type: '{actual_access_type}'")
                        access_reason = f"âš ï¸ **ã“ã®ã‚³ãƒ©ãƒ ã®ã‚¿ã‚¤ãƒ—({actual_access_type})ã¯èªè­˜ã§ãã¾ã›ã‚“**\n\nç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚"

                    if can_access:
                        # ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                        if actual_access_type in ['paid', 'point_required'] and not is_admin:
                            if 'points_consumed' in locals() and points_consumed:
                                columns_html += f"âœ… **{required_points}ãƒã‚¤ãƒ³ãƒˆæ¶ˆè²»ã—ã¾ã—ãŸ**\n\n---\n\n"

                        # contentã®HTMLã‚¿ã‚°ã‚’é™¤å»
                        content_text = strip_html_tags(col.get('content', ''))
                        columns_html += f"{content_text}\n\n"
                    else:
                        columns_html += f"{access_reason}\n\n"
                content = columns_html
            else:
                content = "ã“ã®ãƒ¬ãƒ¼ã‚¹ã«ã¯è¡¨ç¤ºã™ã‚‹ã‚³ãƒ©ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"

            analysis_data = None
        else:  # viewlogic
            result = await self.process_viewlogic_message(message, race_data, sub_type)
            if isinstance(result, tuple):
                content, analysis_data = result
            else:
                content = result
        
        # è¡¨ç¤ºåã®è¨­å®š
        ai_display_names = {
            'metalogic': 'MetaLogic AI',
            'flogic': 'F-Logic AI',
            'dlogic': 'D-Logic AI',
            'ilogic': 'I-Logic AI',
            'imlogic': 'IMLogic AI',
            'viewlogic': 'ViewLogic AI',
            'column': 'ã‚³ãƒ©ãƒ ã‚·ã‚¹ãƒ†ãƒ '
        }
        
        # ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¿½åŠ 
        logger.info(f"æœ€çµ‚ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”Ÿæˆ: determined_ai={determined_ai}, display_name={ai_display_names.get(determined_ai, 'IMLogic AI')}")

        return {
            'content': content,
            'ai_type': determined_ai,
            'ai_display_name': ai_display_names.get(determined_ai, 'IMLogic AI'),
            'sub_type': sub_type,
            'analysis_data': analysis_data
        }
    
    def _is_out_of_scope(self, message: str, race_data: Dict[str, Any]) -> bool:
        """
        ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãƒ¬ãƒ¼ã‚¹ç¯„å›²å¤–ã‹ãƒã‚§ãƒƒã‚¯
        """
        # ä»–ã®ãƒ¬ãƒ¼ã‚¹ç•ªå·ã¸ã®è¨€åŠã‚’ãƒã‚§ãƒƒã‚¯
        other_race_pattern = r'\d+R(?![\d])'  # æ•°å­—+Rï¼ˆå¾Œã«æ•°å­—ãŒç¶šã‹ãªã„ï¼‰
        matches = re.findall(other_race_pattern, message)
        
        current_race_num = str(race_data.get('race_number', ''))
        for match in matches:
            race_num = match[:-1]  # 'R'ã‚’é™¤å»
            if race_num != current_race_num:
                return True
        
        # ä»–ã®é–‹å‚¬å ´ã¸ã®è¨€åŠã‚’ãƒã‚§ãƒƒã‚¯
        venues = ['æ±äº¬', 'ä¸­å±±', 'é˜ªç¥', 'äº¬éƒ½', 'ä¸­äº¬', 'å°å€‰', 'æ–°æ½Ÿ', 'ç¦å³¶', 'æœ­å¹Œ', 'å‡½é¤¨']
        current_venue = race_data.get('venue', '')
        
        for venue in venues:
            if venue in message and venue != current_venue:
                # æ˜ç¢ºã«ä»–ã®é–‹å‚¬å ´ã®ãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦èã„ã¦ã„ã‚‹å ´åˆ
                if re.search(f'{venue}\\d+R', message):
                    return True
        
        # ãƒ¬ãƒ¼ã‚¹ã«å­˜åœ¨ã—ãªã„é¦¬åã‚’ãƒã‚§ãƒƒã‚¯
        race_horses = race_data.get('horses', [])
        if race_horses:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰é¦¬åã‚‰ã—ã„å˜èªã‚’æŠ½å‡ºï¼ˆå…¨ã‚«ã‚¿ã‚«ãƒŠæ–‡å­—ã¨è‹±å­—ã®é€£ç¶šï¼‰
            # ã‚¡-ãƒ´ ã§å…¨ã¦ã®ã‚«ã‚¿ã‚«ãƒŠï¼ˆå°æ–‡å­—å«ã‚€ï¼‰ã¨ãƒ´ã‚’ã‚«ãƒãƒ¼
            potential_horses = re.findall(r'[ã‚¡-ãƒ´ãƒ¼]+|[A-Za-z]+', message)
            
            for potential_horse in potential_horses:
                # 3æ–‡å­—ä»¥ä¸Šã§ã€ã‹ã¤ãƒ¬ãƒ¼ã‚¹ã®é¦¬åãƒªã‚¹ãƒˆã«å­˜åœ¨ã—ãªã„å ´åˆ
                if len(potential_horse) >= 3:
                    # ãƒ¬ãƒ¼ã‚¹ã®é¦¬åãƒªã‚¹ãƒˆã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    is_in_race = False
                    for race_horse in race_horses:
                        if potential_horse in race_horse or race_horse in potential_horse:
                            is_in_race = True
                            break
                    
                    # æ˜ã‚‰ã‹ã«é¦¬åã¨ã—ã¦è¨€åŠã•ã‚Œã¦ã„ã‚‹å ´åˆï¼ˆã€œã®ã€ã€œã¯ã€ãªã©ï¼‰
                    # ãŸã ã—ã‚³ãƒ©ãƒ ã¯é™¤å¤–
                    if potential_horse == 'ã‚³ãƒ©ãƒ ':
                        continue  # ã‚³ãƒ©ãƒ ã¯é¦¬åã§ã¯ãªã„ã®ã§ã‚¹ã‚­ãƒƒãƒ—

                    if not is_in_race and re.search(f'{potential_horse}(ã®|ã¯|ãŒ|ã‚’|ã¨|ã£ã¦|ã¨ã„ã†)', message):
                        # ä¸€èˆ¬çš„ãªå˜èªã‚„åŠ©è©ã§ãªã„ã“ã¨ã‚’ç¢ºèª
                        common_words = ['ãƒ‡ãƒ¼ã‚¿', 'ãƒ¬ãƒ¼ã‚¹', 'ã‚¹ã‚³ã‚¢', 'ãƒã‚¤ãƒ³ãƒˆ', 'ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¨ãƒ©ãƒ¼', 'ViewLogic', 'IMLogic', 'DLogic', 'ILogic', 'FLogic', 'ãƒ•ã‚§ã‚¢', 'ã‚ªãƒƒã‚º', 'ãƒ­ã‚¸ãƒƒã‚¯', 'ã‚¨ãƒ•ãƒ­ã‚¸ãƒƒã‚¯', 'ã‚³ãƒ©ãƒ ']
                        if potential_horse not in common_words:
                            logger.info(f"ãƒ¬ãƒ¼ã‚¹å¤–ã®é¦¬ã‚’æ¤œå‡º: {potential_horse}")
                            return True
        
        return False
    
    async def process_dlogic_message(
        self,
        message: str,
        race_data: Dict[str, Any]
    ) -> Tuple[str, Optional[Dict]]:
        """
        D-Logicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆåœ°æ–¹ç«¶é¦¬å¯¾å¿œç‰ˆï¼‰
        """
        try:
            # D-Logicåˆ†æã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ
            if self._should_analyze(message):
                venue = race_data.get('venue', '')
                
                # åœ°æ–¹ç«¶é¦¬å ´ã®å ´åˆã¯åœ°æ–¹ç«¶é¦¬ç‰ˆã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨
                if self._is_local_racing(venue):
                    from services.local_fast_dlogic_engine_v2 import local_fast_dlogic_engine_v2
                    logger.info(f"ğŸ‡ åœ°æ–¹ç«¶é¦¬ç‰ˆD-Logicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
                    
                    # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã‹ã‚‰é¦¬åã‚’æŠ½å‡º
                    horses = race_data.get('horses', [])
                    if not horses:
                        return ("åˆ†æå¯¾è±¡ã®é¦¬ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None)
                    
                    # åœ°æ–¹ç«¶é¦¬ç‰ˆD-Logicè¨ˆç®—
                    dlogic_result = {}
                    for horse_name in horses:
                        score_data = local_fast_dlogic_engine_v2.raw_manager.calculate_dlogic_realtime(horse_name)
                        if score_data and not score_data.get('error'):
                            # total_scoreã‚’scoreã¨ã—ã¦ä½¿ç”¨
                            dlogic_result[horse_name] = {
                                'score': score_data.get('total_score', 0),
                                'data_available': True,
                                'details': score_data
                            }
                        else:
                            dlogic_result[horse_name] = {
                                'score': 0,
                                'data_available': False
                            }
                    
                    # çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                    content = self._format_dlogic_batch_result(dlogic_result, race_data)
                    
                    # åˆ†æãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
                    analysis_data = {
                        'type': 'dlogic',
                        'scores': dlogic_result,
                        'top_horses': sorted(
                            [h for h in dlogic_result.keys() if dlogic_result[h].get('data_available', False)],
                            key=lambda h: dlogic_result[h].get('score', 0),
                            reverse=True
                        )[:5]
                    }
                    
                    return (content, analysis_data)
                    
                else:
                    # JRAç‰ˆï¼ˆæ—¢å­˜ï¼‰
                    from api.v2.dlogic import calculate_dlogic_batch
                    logger.info(f"ğŸ‡ JRAç‰ˆD-Logicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
                    
                    # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã‹ã‚‰é¦¬åã‚’æŠ½å‡º
                    horses = race_data.get('horses', [])
                    if not horses:
                        return ("åˆ†æå¯¾è±¡ã®é¦¬ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None)
                    
                    # D-Logicãƒãƒƒãƒè¨ˆç®—ã‚’å®Ÿè¡Œ
                    dlogic_result = await calculate_dlogic_batch(horses)
                    
                    if not dlogic_result:
                        return ("D-Logicåˆ†æã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚", None)
                    
                    # çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
                    content = self._format_dlogic_batch_result(dlogic_result, race_data)
                    
                    # åˆ†æãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
                    analysis_data = {
                        'type': 'dlogic',
                        'scores': dlogic_result,
                        'top_horses': sorted(
                            [h for h in dlogic_result.keys() if dlogic_result[h].get('data_available', False)],
                            key=lambda h: dlogic_result[h].get('score', 0),
                            reverse=True
                        )[:5]
                    }
                    
                    return (content, analysis_data)
            
            # é€šå¸¸ã®ä¼šè©±ã®å ´åˆ
            else:
                # ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                race_context = self.create_race_context_prompt(race_data)
                
                # D-Logicã®èª¬æ˜
                dlogic_prompt = """
D-Logicã¯ã€12é …ç›®ã«ã‚ˆã‚‹é¦¬ã®ç·åˆè©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
å„é¦¬ã®èƒ½åŠ›ã‚’0-100ç‚¹ã§è©•ä¾¡ã—ã€ãƒ©ãƒ³ã‚­ãƒ³ã‚°å½¢å¼ã§è¡¨ç¤ºã—ã¾ã™ã€‚
åˆ†æã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€ŒD-LogicæŒ‡æ•°ã‚’æ•™ãˆã¦ã€ã€Œè©•ä¾¡ã—ã¦ã€ãªã©ã¨ãŠèããã ã•ã„ã€‚
"""
                
                # Claude APIã‚’å‘¼ã³å‡ºã—ï¼ˆä¼šè©±ç”¨ï¼‰
                if self.anthropic_client:
                    full_prompt = f"{race_context}\n\n{dlogic_prompt}\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: {message}"
                    response = self.anthropic_client.messages.create(
                        model="claude-3-haiku-20240307",
                        max_tokens=2000,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": full_prompt}
                        ]
                    )
                    return (response.content[0].text, None)
                else:
                    return ("ä¼šè©±æ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“", None)
            
        except Exception as e:
            logger.error(f"D-Logicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return (f"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚D-Logicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    async def process_flogic_message(
        self,
        message: str,
        race_data: Dict[str, Any]
    ) -> Tuple[str, Optional[Dict[str, Any]]]:
        """
        F-Logicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆæŠ•è³‡ä¾¡å€¤åˆ¤å®šï¼‰
        """
        try:
            # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ç¢ºèª
            horses = race_data.get('horses', [])
            jockeys = race_data.get('jockeys', [])
            venue = race_data.get('venue')
            race_number = race_data.get('race_number')
            
            # F-Logicã®èª¬æ˜è¦æ±‚ã‹ã©ã†ã‹åˆ¤å®š
            explanation_keywords = ['ã£ã¦ä½•', 'ã¨ã¯', 'èª¬æ˜', 'ã©ã†ã„ã†', 'ä½•ã§ã™ã‹', 'æ•™ãˆã¦']
            is_explanation = any(keyword in message for keyword in explanation_keywords)
            
            if is_explanation:
                explanation = """ğŸ¯ F-Logicï¼ˆFair Value Logicï¼‰ã«ã¤ã„ã¦

F-Logicã¯ã€ç«¶é¦¬ã«ãŠã‘ã‚‹ç†è«–çš„ãªã€Œãƒ•ã‚§ã‚¢å€¤ï¼ˆé©æ­£ã‚ªãƒƒã‚ºï¼‰ã€ã‚’è¨ˆç®—ã—ã€å¸‚å ´ã‚ªãƒƒã‚ºã¨ã®ä¹–é›¢ã‹ã‚‰æŠ•è³‡ä¾¡å€¤ã‚’åˆ¤å®šã™ã‚‹AIã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚

ã€ä¸»ãªæ©Ÿèƒ½ã€‘
â€¢ I-Logicã‚¹ã‚³ã‚¢ã‚’åŸºã«ã—ãŸç†è«–çš„å‹ç‡è¨ˆç®—
â€¢ ãƒ•ã‚§ã‚¢å€¤ï¼ˆç†è«–ã‚ªãƒƒã‚ºï¼‰ã®ç®—å‡º
â€¢ å¸‚å ´ã‚ªãƒƒã‚ºã¨ã®ä¹–é›¢ç‡åˆ†æ
â€¢ æœŸå¾…å€¤ã¨ROIï¼ˆæŠ•è³‡åç›Šç‡ï¼‰ã®è¨ˆç®—
â€¢ KellyåŸºæº–ã«ã‚ˆã‚‹æœ€é©æŠ•è³‡æ¯”ç‡ææ¡ˆ

ã€æŠ•è³‡åˆ¤å®šã®ä»•çµ„ã¿ã€‘
ãƒ•ã‚§ã‚¢å€¤ < å¸‚å ´ã‚ªãƒƒã‚º â†’ å‰²å®‰ï¼ˆè²·ã„æ¨å¥¨ï¼‰
ãƒ•ã‚§ã‚¢å€¤ > å¸‚å ´ã‚ªãƒƒã‚º â†’ å‰²é«˜ï¼ˆè¦‹é€ã‚Šæ¨å¥¨ï¼‰

ä¾‹ï¼šãƒ•ã‚§ã‚¢å€¤5.0å€ã®é¦¬ãŒå¸‚å ´ã§10.0å€
â†’ ã‚ªãƒƒã‚ºä¹–é›¢ç‡2.0å€ = å¼·ã„æŠ•è³‡ä¾¡å€¤ã‚ã‚Š

F-Logicåˆ†æã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€ŒF-Logicåˆ†æã—ã¦ã€ã¨ãŠèããã ã•ã„ã€‚"""
                return (explanation, None)
            
            if not horses:
                return ("F-Logicåˆ†æã«ã¯ãƒ¬ãƒ¼ã‚¹æƒ…å ±ãŒå¿…è¦ã§ã™ã€‚", None)
            
            # åˆ†æè¦æ±‚ã‹ã©ã†ã‹åˆ¤å®š
            analyze_keywords = ['åˆ†æ', 'è¨ˆç®—', 'åˆ¤å®š', 'ä¾¡å€¤', 'ã‚ªãƒƒã‚º', 'ãƒ•ã‚§ã‚¢', 'æœŸå¾…å€¤']
            should_analyze = any(keyword in message for keyword in analyze_keywords)
            
            if should_analyze:
                # ãƒ¬ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚ªãƒƒã‚ºã‚’å–å¾—
                odds_values = race_data.get('odds', [])
                market_odds = {}
                

                
                # ã‚ªãƒƒã‚ºãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ãƒãƒƒãƒ”ãƒ³ã‚°
                if odds_values and horses:
                    for i, horse_name in enumerate(horses):
                        if i < len(odds_values):
                            odds_value = odds_values[i]
                            # ã‚ªãƒƒã‚ºå€¤ãŒæœ‰åŠ¹ãªå ´åˆã®ã¿è¿½åŠ 
                            if odds_value and odds_value > 0:
                                market_odds[horse_name] = float(odds_value)
                    logger.info(f"F-Logic: market_odds from race_data: {list(market_odds.items())[:3]}")
                    logger.info(f"F-Logic: Total odds mapped: {len(market_odds)}")
                
                # ã‚ªãƒƒã‚ºãŒãªã„å ´åˆã¯odds_managerã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹ï¼ˆãƒ‡ãƒãƒƒã‚°ã®ãŸã‚ä¸€æ™‚çš„ã«ç„¡åŠ¹åŒ–ï¼‰
                # if not market_odds:
                #     logger.info("F-Logic: No odds in race_data, trying odds_manager")
                #     from services.odds_manager import odds_manager
                #     market_odds = odds_manager.get_real_time_odds(
                #         venue=venue,
                #         race_number=race_number,
                #         horses=horses
                #     )
                
                # ã‚ªãƒƒã‚ºãŒå–å¾—ã§ããªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿”ã™
                if not market_odds:
                    return ("ã‚ªãƒƒã‚ºãƒ‡ãƒ¼ã‚¿ãŒå–å¾—ã§ããªã„ãŸã‚ã€F-Logicåˆ†æã‚’å®Ÿè¡Œã§ãã¾ã›ã‚“ã€‚\n\nF-Logicã¯å¸‚å ´ã‚ªãƒƒã‚ºã¨ãƒ•ã‚§ã‚¢å€¤ã®æ¯”è¼ƒãŒå¿…è¦ãªãŸã‚ã€ã‚ªãƒƒã‚ºãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã¯åˆ†æã§ãã¾ã›ã‚“ã€‚", None)
                
                # F-Logicåˆ†æå®Ÿè¡Œ
                from services.flogic_engine import flogic_engine
                result = flogic_engine.analyze_race(race_data, market_odds)
                
                if result.get('status') == 'success':
                    content = self._format_flogic_result(result, race_data)
                    
                    # åˆ†æãƒ‡ãƒ¼ã‚¿ã‚‚è¿”ã™
                    analysis_data = {
                        'type': 'flogic',
                        'rankings': result.get('rankings', []),
                        'has_market_odds': result.get('has_market_odds', False)
                    }
                    
                    return (content, analysis_data)
                else:
                    return (f"F-Logicåˆ†æã‚¨ãƒ©ãƒ¼: {result.get('message', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}", None)
            else:
                # F-Logicã®èª¬æ˜ï¼ˆClaude APIä¸è¦ã€ç›´æ¥è¿”ç­”ï¼‰
                race_context = f"ç¾åœ¨é¸æŠä¸­: {venue}{race_number}R"
                if horses:
                    race_context += f"ï¼ˆ{len(horses)}é ­ï¼‰"
                    
                explanation = f"""ğŸ¯ {race_context}

F-Logicï¼ˆFair Value Logicï¼‰ã¯ã€ç†è«–çš„ãªå…¬æ­£ã‚ªãƒƒã‚ºã¨å¸‚å ´ã‚ªãƒƒã‚ºã‚’æ¯”è¼ƒã—ã¦æŠ•è³‡ä¾¡å€¤ã‚’åˆ¤å®šã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚

ã€ä¸»ãªæ©Ÿèƒ½ã€‘
ğŸ¯ å…¬æ­£ä¾¡å€¤è¨ˆç®—: I-Logicã‚¹ã‚³ã‚¢ã‹ã‚‰ç†è«–çš„ãªé©æ­£ã‚ªãƒƒã‚ºã‚’ç®—å‡º
ğŸ’° æŠ•è³‡ä¾¡å€¤åˆ¤å®š: å¸‚å ´ã‚ªãƒƒã‚ºã¨ã®ä¹–é›¢ã‹ã‚‰å‰²å®‰ãƒ»å‰²é«˜ã‚’åˆ¤å®š
ğŸ“Š æœŸå¾…å€¤è¨ˆç®—: æŠ•è³‡ãƒªã‚¿ãƒ¼ãƒ³ã®æœŸå¾…å€¤ã¨ROIã‚’æ¨å®š

ã€æŠ•è³‡åˆ¤æ–­åŸºæº–ã€‘
ãƒ»ãƒ•ã‚§ã‚¢å€¤ < å¸‚å ´ã‚ªãƒƒã‚º = å‰²å®‰ï¼ˆè²·ã„ï¼‰
ãƒ»ãƒ•ã‚§ã‚¢å€¤ > å¸‚å ´ã‚ªãƒƒã‚º = å‰²é«˜ï¼ˆè¦‹é€ã‚Šï¼‰

åˆ†æã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€ŒF-Logicåˆ†æã—ã¦ã€ã€ŒæŠ•è³‡ä¾¡å€¤ã‚’åˆ¤å®šã€ãªã©ã¨ãŠèããã ã•ã„ã€‚"""
                
                return (explanation, None)
                
        except Exception as e:
            logger.error(f"F-Logicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return (f"F-Logicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    def _format_flogic_result(self, result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """
        F-Logicåˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        """
        try:
            rankings = result.get('rankings', [])
            if not rankings:
                return "F-Logicåˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            lines = []
            lines.append(f"ğŸ¯ F-Logic æŠ•è³‡ä¾¡å€¤åˆ†æçµæœ")
            lines.append("=" * 40)
            
            # å…¨é¦¬ã‚’æŠ•è³‡ä¾¡å€¤é †ã«å‡ºåŠ›
            for i, horse in enumerate(rankings, 1):
                # é †ä½ã¨é¦¬å
                lines.append(f"\nã€{i}ä½ã€‘ {horse['horse']}")
                lines.append("-" * 30)
                
                # ãƒ•ã‚§ã‚¢å€¤ã¨å¸‚å ´ã‚ªãƒƒã‚º
                lines.append(f"ãƒ•ã‚§ã‚¢å€¤: {horse['fair_odds']}å€")
                if 'market_odds' in horse:
                    lines.append(f"å¸‚å ´ã‚ªãƒƒã‚º: {horse['market_odds']}å€")
                    divergence = horse.get('odds_divergence', 0)
                    lines.append(f"ã‚ªãƒƒã‚ºä¹–é›¢ç‡: {divergence:.2f}å€")
                
                # æŠ•è³‡åˆ¤æ–­
                signal = horse.get('investment_signal', 'è©•ä¾¡ãªã—')
                lines.append(f"æŠ•è³‡åˆ¤æ–­: {signal}")
                
                # æœŸå¾…å€¤ã¨ROI
                if 'expected_value' in horse:
                    lines.append(f"æœŸå¾…å€¤: {horse['expected_value']}")
                if 'roi_estimate' in horse:
                    lines.append(f"æ¨å®šROI: {horse['roi_estimate']}%")
                
                # I-Logicã‚¹ã‚³ã‚¢
                if 'ilogic_score' in horse:
                    # I-Logicã‚¹ã‚³ã‚¢ã¯éè¡¨ç¤ºï¼ˆI-Logicã‚¨ãƒ³ã‚¸ãƒ³ã¨é‡è¤‡ã™ã‚‹ãŸã‚ï¼‰
                    pass
                
                # æŠ•è³‡ä¾¡å€¤è©•ä¾¡
                if horse.get('odds_divergence', 0) >= 2.0:
                    lines.append("â­ ã€éå¸¸ã«å‰²å®‰ã€‘æŠ•è³‡ä¾¡å€¤ãŒé«˜ã„")
                elif horse.get('odds_divergence', 0) >= 1.5:
                    lines.append("âœ¨ ã€å‰²å®‰ã€‘è‰¯ã„æŠ•è³‡æ©Ÿä¼š")
                elif horse.get('odds_divergence', 0) >= 1.2:
                    lines.append("ğŸ“Š ã€ã‚„ã‚„å‰²å®‰ã€‘æ¤œè¨ä¾¡å€¤ã‚ã‚Š")
                elif horse.get('odds_divergence', 0) >= 0.8:
                    lines.append("â– ã€é©æ­£ã€‘æŠ•è³‡ä¾¡å€¤ã¯æ™®é€š")
                else:
                    lines.append("âš ï¸ ã€å‰²é«˜ã€‘æŠ•è³‡ã¯è¦‹é€ã‚Šæ¨å¥¨")
            
            # æ³¨æ„äº‹é …
            lines.append("\n\nâ€»F-Logicã¯ç†è«–å€¤ã¨å¸‚å ´ä¾¡æ ¼ã®ä¹–é›¢ã‚’åˆ†æã™ã‚‹ã‚‚ã®ã§ã™")
            lines.append("â€»æŠ•è³‡ã¯è‡ªå·±è²¬ä»»ã§ãŠé¡˜ã„ã—ã¾ã™")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"F-Logicçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "F-Logicåˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    async def process_ilogic_message(
        self,
        message: str,
        race_data: Dict[str, Any]
    ) -> Tuple[str, Optional[Dict]]:
        """
        I-Logicãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ï¼ˆåœ°æ–¹ç«¶é¦¬å¯¾å¿œç‰ˆï¼‰
        """
        try:
            # I-Logicåˆ†æã‚’å®Ÿè¡Œã™ã‚‹å ´åˆ
            if self._should_analyze(message):
                venue = race_data.get('venue', '')
                
                # åœ°æ–¹ç«¶é¦¬å ´ã®å ´åˆã¯åœ°æ–¹ç«¶é¦¬ç‰ˆã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨
                if self._is_local_racing(venue):
                    from services.local_race_analysis_engine_v2 import local_race_analysis_engine_v2 as local_ilogic_engine_v2
                    logger.info(f"ğŸ‡ åœ°æ–¹ç«¶é¦¬ç‰ˆI-Logicã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨: {venue}")
                    
                    # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã‚’æº–å‚™
                    horses = race_data.get('horses', [])
                    jockeys = race_data.get('jockeys', [])
                    
                    if not horses:
                        return ("åˆ†æå¯¾è±¡ã®é¦¬ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None)
                    
                    if not jockeys:
                        return ("I-Logicåˆ†æã«ã¯é¨æ‰‹æƒ…å ±ãŒå¿…è¦ã§ã™ã€‚", None)
                    
                    # åœ°æ–¹ç«¶é¦¬ç‰ˆI-Logicè¨ˆç®—
                    logger.info(f"åœ°æ–¹I-Logicåˆ†æé–‹å§‹: horses={horses}, jockeys={jockeys}")
                    result = local_ilogic_engine_v2.analyze_race(race_data)
                    logger.info(f"åœ°æ–¹I-Logicåˆ†æçµæœ: status={result.get('status')}, scoresæ•°={len(result.get('scores', []))}")
                    
                    if result.get('status') == 'success':
                        scores = result.get('scores', [])
                        content = self._format_ilogic_scores_local(scores, race_data)
                        
                        analysis_data = {
                            'type': 'ilogic',
                            'scores': scores,
                            'top_horses': [s['horse'] for s in scores[:5]]
                        }
                        
                        return (content, analysis_data)
                    else:
                        return (f"I-Logicåˆ†æã«å¤±æ•—ã—ã¾ã—ãŸ: {result.get('message', 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼')}", None)
                else:
                    # JRAç‰ˆï¼ˆæ—¢å­˜ã®å‡¦ç†ï¼‰
                    # ãƒ¬ãƒ¼ã‚¹æƒ…å ±ã‚’æº–å‚™
                    horses = race_data.get('horses', [])
                    jockeys = race_data.get('jockeys', [])
                    posts = race_data.get('posts', [])
                    horse_numbers = race_data.get('horse_numbers', [])
                    venue = race_data.get('venue', '')
                    race_number = race_data.get('race_number', 0)
                    
                    if not horses:
                        return ("åˆ†æå¯¾è±¡ã®é¦¬ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", None)
                    
                    # é¨æ‰‹ãƒ»æ é †ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆ
                    if not jockeys or not posts:
                        return ("I-Logicåˆ†æã«ã¯é¨æ‰‹ãƒ»æ é †æƒ…å ±ãŒå¿…è¦ã§ã™ã€‚ã“ã®ãƒ¬ãƒ¼ã‚¹ã§ã¯åˆ†æã§ãã¾ã›ã‚“ã€‚", None)
                    
                    try:
                        # HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã¯ãªãç›´æ¥é–¢æ•°å‘¼ã³å‡ºã—ã‚’ä½¿ç”¨ï¼ˆRenderç’°å¢ƒå¯¾å¿œï¼‰
                        logger.info(f"I-Logicç›´æ¥é–¢æ•°å‘¼ã³å‡ºã—é–‹å§‹: {venue} {race_number}R")
                        
                        # race-analysis-v2/chat é–¢æ•°ã‚’ç›´æ¥å‘¼ã³å‡ºã—
                        from api.race_analysis_v2 import race_analysis_chat
                        
                        # APIã®æœŸå¾…ã™ã‚‹å½¢å¼ã«åˆã‚ã›ã‚‹
                        request_data = {
                            'message': f"{venue} {race_number}Rã‚’åˆ†æã—ã¦",
                            'race_info': {
                                'venue': venue,
                                'race_number': race_number,
                                'horses': horses,
                                'jockeys': jockeys,
                                'posts': posts,
                                'horse_numbers': horse_numbers or list(range(1, len(horses) + 1))
                            }
                        }
                        
                        logger.info(f"I-Logicé–¢æ•°å‘¼ã³å‡ºã—ãƒ‡ãƒ¼ã‚¿: {request_data}")
                        
                        # ç›´æ¥é–¢æ•°ã‚’å‘¼ã³å‡ºã—
                        result_data = await race_analysis_chat(request_data)
                        
                        logger.info(f"I-Logicé–¢æ•°ãƒ¬ã‚¹ãƒãƒ³ã‚¹: {result_data}")
                        
                        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‡¦ç†
                        if not result_data:
                            return ("I-Logicåˆ†æã‹ã‚‰ç©ºã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚", None)
                        
                        if result_data.get('status') != 'success':
                            error_msg = result_data.get('response', 'I-Logicåˆ†æã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ')
                            return (error_msg, None)
                        
                        response_text = result_data.get('response', '')
                        
                        if not response_text:
                            return ("I-Logicåˆ†æçµæœãŒç©ºã§ã™ã€‚", None)
                        
                        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰é¦¬åã¨ã‚¹ã‚³ã‚¢ã‚’æŠ½å‡º
                        scores = self._parse_ilogic_response(response_text, horses)
                        
                        # åˆ†æãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º
                        analysis_data = {
                            'type': 'ilogic',
                            'response_text': response_text,
                            'top_horses': scores[:5] if scores else []
                        }
                        
                        return (response_text, analysis_data)
                        
                    except Exception as e:
                        logger.error(f"I-Logicåˆ†æã‚¨ãƒ©ãƒ¼: {e}")
                        import traceback
                        traceback.print_exc()
                        return ("I-Logicåˆ†æã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", None)
            
            # é€šå¸¸ã®ä¼šè©±ã®å ´åˆ
            else:
                # ãƒ¬ãƒ¼ã‚¹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨­å®š
                race_context = self.create_race_context_prompt(race_data)
                
                # I-Logicã®èª¬æ˜
                ilogic_prompt = """
I-Logicã¯ã€é¦¬ã®èƒ½åŠ›ï¼ˆ70%ï¼‰ã¨é¨æ‰‹ã®é©æ€§ï¼ˆ30%ï¼‰ã‚’ç·åˆã—ãŸåˆ†æã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚
é–‹å‚¬å ´é©æ€§ã€ã‚¯ãƒ©ã‚¹è£œæ­£ã€é¨æ‰‹ã®æ é †é©æ€§ãªã©ã‚’è€ƒæ…®ã—ãŸç²¾å¯†ãªè©•ä¾¡ã‚’è¡Œã„ã¾ã™ã€‚
åˆ†æã‚’ã”å¸Œæœ›ã®å ´åˆã¯ã€ŒI-Logicåˆ†æã—ã¦ã€ã€Œç·åˆè©•ä¾¡ã¯ï¼Ÿã€ãªã©ã¨ãŠèããã ã•ã„ã€‚
"""
                
                # Claude APIã‚’å‘¼ã³å‡ºã—ï¼ˆä¼šè©±ç”¨ï¼‰
                if self.anthropic_client:
                    full_prompt = f"{race_context}\n\n{ilogic_prompt}\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•: {message}"
                    response = self.anthropic_client.messages.create(
                        model="claude-3-haiku-20240307",
                        max_tokens=2000,
                        temperature=0.7,
                        messages=[
                            {"role": "user", "content": full_prompt}
                        ]
                    )
                    return (response.content[0].text, None)
                else:
                    return ("ä¼šè©±æ©Ÿèƒ½ã¯ç¾åœ¨åˆ©ç”¨ã§ãã¾ã›ã‚“", None)
            
        except Exception as e:
            import traceback
            logger.error(f"I-Logicå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            logger.error(f"I-Logicã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹: {traceback.format_exc()}")
            logger.error(f"I-Logicã‚¨ãƒ©ãƒ¼æ™‚ã®race_data: {race_data}")
            return (f"ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚I-Logicåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)
    
    def _parse_dlogic_result(self, content: str) -> Optional[Dict]:
        """
        D-Logicçµæœã‹ã‚‰ã‚¹ã‚³ã‚¢æƒ…å ±ã‚’æŠ½å‡º
        """
        try:
            import re
            
            # D-Logicä¸Šä½5é ­ã‚’æŠ½å‡ºã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³
            top5_pattern = r'D-Logicä¸Šä½5é ­[ï¼š:]\s*([^ã€\n]+(?:ã€[^ã€\n]+){0,4})'
            match = re.search(top5_pattern, content)
            
            if match:
                top5_horses = [horse.strip() for horse in match.group(1).split('ã€')]
                return {
                    'type': 'dlogic',
                    'top_horses': top5_horses
                }
            
            return None
            
        except Exception as e:
            logger.error(f"D-Logicçµæœãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _format_ilogic_result(self, analysis_result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """
        I-Logicåˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        """
        try:
            top_horses = analysis_result.get('top_horses', [])
            detailed_scores = analysis_result.get('detailed_scores', {})
            
            if not top_horses:
                return "I-Logicåˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ‘‘ I-Logicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R")
            lines.append("")
            
            # ä¸Šä½5é ­ã‚’è¡¨ç¤º
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ä½:', '5ä½:']
            for i, horse_name in enumerate(top_horses[:5]):
                emoji = emojis[i] if i < 5 else f"{i+1}."
                
                # è©³ç´°ã‚¹ã‚³ã‚¢ãŒã‚ã‚Œã°è¡¨ç¤º
                if horse_name in detailed_scores:
                    score_info = detailed_scores[horse_name]
                    total_score = score_info.get('total_score', 0)
                    horse_score = score_info.get('horse_score', 0)
                    jockey_score = score_info.get('jockey_score', 0)
                    
                    lines.append(f"{emoji} {horse_name}: {total_score:.1f}ç‚¹")
                    lines.append(f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹")
                else:
                    lines.append(f"{emoji} {horse_name}")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"I-Logicçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "I-Logicåˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    def _format_betting_recommendations(self, result: Dict[str, Any]) -> str:
        """
        ViewLogicé¦¬åˆ¸æ¨å¥¨çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆå±•é–‹äºˆæƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
        """
        try:
            lines = []
            lines.append("ğŸ¯ ViewLogicæ¨å¥¨é¦¬åˆ¸")
            lines.append("")
            
            venue = result.get('venue', 'ä¸æ˜')
            total_horses = result.get('total_horses', 0)
            top_5_horses = result.get('top_5_horses', [])
            recommendations = result.get('recommendations', [])
            
            lines.append(f"**é–‹å‚¬å ´**: {venue}")
            lines.append(f"**å‡ºèµ°é ­æ•°**: {total_horses}é ­")
            
            # å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‚’è¡¨ç¤º
            if top_5_horses:
                lines.append("")
                lines.append("**ğŸ‡ ViewLogicå±•é–‹äºˆæƒ³ ä¸Šä½5é ­**:")
                for i, horse in enumerate(top_5_horses[:5], 1):
                    lines.append(f"  {i}. {horse}")
            
            lines.append("")
            
            if not recommendations:
                lines.append("âš ï¸ æ¨å¥¨é¦¬åˆ¸ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
                return "\n".join(lines)
            
            lines.append("### ğŸ“‹ æ¨å¥¨é¦¬åˆ¸")
            lines.append("")
            
            for rec in recommendations:
                rec_type = rec.get('type', 'ä¸æ˜')
                ticket_type = rec.get('ticket_type', 'é¦¬åˆ¸')
                horses = rec.get('horses', [])
                confidence = rec.get('confidence', 0)
                investment = rec.get('investment', 0)
                reason = rec.get('reason', '')
                buy_type = rec.get('buy_type', '')
                combinations = rec.get('combinations', 0)
                
                # æ¨å¥¨é¦¬åˆ¸ã®ã‚¢ã‚¤ã‚³ãƒ³
                icon_map = {
                    'å˜å‹': 'ğŸ¥‡',
                    'é¦¬é€£BOX': 'ğŸ“¦',
                    '3é€£å˜æµã—': 'ğŸ¯',
                    'ãƒ¯ã‚¤ãƒ‰': 'ğŸŒŸ',
                    '3é€£è¤‡BOX': 'ğŸ’°'
                }
                icon = icon_map.get(rec_type, 'ğŸª')
                
                lines.append(f"{icon} **{rec_type}**")
                
                # é¦¬åã®è¡¨ç¤ºï¼ˆè¤‡é›‘ãªå½¢å¼ã«å¯¾å¿œï¼‰
                if isinstance(horses, dict):
                    # æµã—è²·ã„ã®å ´åˆï¼ˆ3é€£å˜ãªã©ï¼‰
                    if '1ç€' in horses:
                        lines.append(f"  ã€{ticket_type}ã€‘")
                        lines.append(f"   1ç€: {', '.join(horses['1ç€'])}")
                        lines.append(f"   2ç€: {', '.join(horses['2ç€'])}")  
                        lines.append(f"   3ç€: {', '.join(horses['3ç€'])}")
                    elif 'è»¸' in horses:
                        # ãƒ¯ã‚¤ãƒ‰ã®å ´åˆ
                        lines.append(f"  ã€{ticket_type}ã€‘ {horses['è»¸']} è»¸")
                        lines.append(f"   ç›¸æ‰‹: {', '.join(horses['ç›¸æ‰‹'])}")
                elif isinstance(horses, list):
                    # é€šå¸¸ã®BOXè²·ã„ã¾ãŸã¯å˜å‹
                    if buy_type == 'BOX':
                        lines.append(f"  ã€{ticket_type}BOXã€‘ {' - '.join(horses)}")
                    else:
                        lines.append(f"  ã€{ticket_type}ã€‘ {' â†’ '.join(horses)}")
                
                # è²·ã„æ–¹è©³ç´°
                if buy_type and combinations > 0:
                    lines.append(f"   è²·ã„æ–¹: {buy_type} ({combinations}ç‚¹è²·ã„)")
                
                lines.append(f"   ğŸ’° æŠ•è³‡é¡: **{investment:,}å††**")
                lines.append(f"   ğŸ“Š ä¿¡é ¼åº¦: {confidence}%")
                if reason:
                    lines.append(f"   ğŸ’­ {reason}")
                lines.append("")
            
            # ç·æŠ•è³‡é¡
            total_investment = sum(rec.get('investment', 0) for rec in recommendations)
            lines.append("---")
            lines.append(f"ğŸ’µ **ç·æŠ•è³‡é¡**: {total_investment:,}å††")
            
            lines.append("")
            lines.append("â€» ViewLogicå±•é–‹äºˆæƒ³ã®ä¸Šä½é¦¬ã‚’åŸºã«ã—ãŸæ¨å¥¨é¦¬åˆ¸ã§ã™")
            lines.append("â€» æŠ•è³‡ã¯è‡ªå·±è²¬ä»»ã§ãŠé¡˜ã„ã—ã¾ã™")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"é¦¬åˆ¸æ¨å¥¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return "é¦¬åˆ¸æ¨å¥¨çµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    def _format_dlogic_batch_result(self, dlogic_result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """
        D-Logicãƒãƒƒãƒè¨ˆç®—çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        """
        try:
            if not dlogic_result:
                return "D-Logicåˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # ã‚¹ã‚³ã‚¢ãŒã‚ã‚‹é¦¬ã‚’æŠ½å‡ºã—ã¦ã‚½ãƒ¼ãƒˆ
            valid_horses = []
            for horse_name, data in dlogic_result.items():
                if data.get('data_available', False) and data.get('score') is not None:
                    valid_horses.append((horse_name, data))
            
            # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            valid_horses.sort(key=lambda x: x[1].get('score', 0), reverse=True)
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ¯ D-Logicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R {race_data.get('race_name', '')}")
            lines.append("")
            
            # å…¨é ­ã‚’é †ä½ä»˜ãã§è¡¨ç¤ºï¼ˆI-Logicå½¢å¼ï¼‰
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰']
            for i, (horse_name, data) in enumerate(valid_horses):
                # ä¸Šä½3ä½ã¾ã§çµµæ–‡å­—ã€4ä½ä»¥é™ã¯æ•°å­—è¡¨ç¤º
                if i < 3:
                    rank_display = f"{emojis[i]} {i+1}ä½:"
                else:
                    rank_display = f"{i+1}ä½:"
                
                score = data.get('score', 0)
                lines.append(f"{rank_display} {horse_name}: {score:.1f}ç‚¹")
                
                # è©³ç´°ã‚¹ã‚³ã‚¢ãŒã‚ã‚Œã°è¡¨ç¤ºï¼ˆä¸Šä½5é ­ã®ã¿ï¼‰
                if i < 5 and data.get('details'):
                    details = data['details']
                    # ä¸»è¦ãªé …ç›®ã‚’è¡¨ç¤º
                    if 'distance_aptitude' in details:
                        lines.append(f"   è·é›¢é©æ€§: {details['distance_aptitude']:.1f}")
                    if 'bloodline_evaluation' in details:
                        lines.append(f"   è¡€çµ±è©•ä¾¡: {details['bloodline_evaluation']:.1f}")
                
                # æ¬¡ã®é¦¬ã¨ã®é–“ã«ç©ºè¡Œã‚’è¿½åŠ ï¼ˆæœ€å¾Œã®é¦¬ä»¥å¤–ï¼‰
                if i < len(valid_horses) - 1:
                    lines.append("")
                
                # 6ä½ç›®ã«åŒºåˆ‡ã‚Šç·šã‚’è¿½åŠ 
                if i == 5:
                    lines.append("ã€6ä½ä»¥ä¸‹ã€‘")
            
            # ãƒ‡ãƒ¼ã‚¿ãŒãªã„é¦¬ãŒã„ã‚‹å ´åˆã®æ³¨è¨˜
            no_data_horses = [name for name, data in dlogic_result.items() 
                            if not data.get('data_available', False)]
            if no_data_horses:
                lines.append("")
                lines.append("ã€ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã€‘")
                lines.append(f"ä»¥ä¸‹ã®é¦¬ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“:")
                lines.append(f"{', '.join(no_data_horses)}")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"D-Logicçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "D-Logicåˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    def _parse_ilogic_response(self, response_text: str, horses: List[str]) -> List[str]:
        """
        I-Logicãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰é¦¬åé †ä½ã‚’æŠ½å‡º
        """
        try:
            import re
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰é¦¬åã‚’é †ä½é †ã«æŠ½å‡º
            extracted_horses = []
            
            # å„é¦¬åãŒä½•ä½ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            for horse in horses:
                for line in response_text.split('\n'):
                    if horse in line and ('ä½' in line or 'ğŸ¥‡' in line or 'ğŸ¥ˆ' in line or 'ğŸ¥‰' in line or 'ğŸ…' in line):
                        if horse not in extracted_horses:
                            extracted_horses.append(horse)
                            break
            
            return extracted_horses
            
        except Exception as e:
            logger.error(f"I-Logicãƒ¬ã‚¹ãƒãƒ³ã‚¹è§£æã‚¨ãƒ©ãƒ¼: {e}")
            return []
    
    def _format_ilogic_api_result(self, scores: List[Dict[str, Any]], race_data: Dict[str, Any]) -> str:
        """
        I-Logic APIçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆV1äº’æ›ï¼‰
        """
        try:
            if not scores:
                return "I-Logicåˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ‘‘ I-Logicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R {race_data.get('race_name', '')}")
            
            # ä¸Šä½5é ­ã‚’è¡¨ç¤º
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ä½:', '5ä½:']
            for i, score_data in enumerate(scores[:5]):
                emoji = emojis[i] if i < 5 else f"{i+1}."
                horse_name = score_data.get('horse', 'ä¸æ˜')
                total_score = score_data.get('score', 0)
                
                lines.append(f"{emoji} {horse_name}: {total_score:.1f}ç‚¹")
            
            # 6ä½ä»¥ä¸‹ã‚‚ç°¡æ½”ã«è¡¨ç¤º
            if len(scores) > 5:
                lines.append("")
                lines.append("ã€6ä½ä»¥ä¸‹ã€‘")
                for score_data in scores[5:]:
                    horse_name = score_data.get('horse', 'ä¸æ˜')
                    total_score = score_data.get('score', 0)
                    lines.append(f"{horse_name}: {total_score:.1f}ç‚¹")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"I-Logic APIçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "I-Logicåˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    def _format_ilogic_scores_local(self, scores: List[Dict[str, Any]], race_data: Dict[str, Any]) -> str:
        """åœ°æ–¹ç«¶é¦¬ç‰ˆI-Logicã‚¹ã‚³ã‚¢ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        venue = race_data.get('venue', 'ä¸æ˜')
        race_number = race_data.get('race_number', 'ä¸æ˜')
        
        content = f"ğŸ¯ I-Logicåˆ†æçµæœ\n"
        content += f"{venue} {race_number}R\n\n"
        
        if not scores:
            return content + "åˆ†æãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
        
        # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
        scores.sort(key=lambda x: x.get('total_score', 0), reverse=True)
        
        # ä¸Šä½5é ­ã‚’è¡¨ç¤º
        for i, score in enumerate(scores[:5], 1):
            horse = score.get('horse', 'ä¸æ˜')
            jockey = score.get('jockey', 'ä¸æ˜')
            total = score.get('total_score', 0)
            horse_score = score.get('horse_score', 0)
            jockey_score = score.get('jockey_score', 0)
            
            if i == 1:
                content += f"ğŸ¥‡ {i}ä½: {horse}: {total:.1f}ç‚¹\n"
            elif i == 2:
                content += f"ğŸ¥ˆ {i}ä½: {horse}: {total:.1f}ç‚¹\n"
            elif i == 3:
                content += f"ğŸ¥‰ {i}ä½: {horse}: {total:.1f}ç‚¹\n"
            else:
                content += f"{i}ä½: {horse}: {total:.1f}ç‚¹\n"
            
            content += f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹\n\n"
        
        # 6ä½ä»¥ä¸‹
        if len(scores) > 5:
            content += "ã€6ä½ä»¥ä¸‹ã€‘\n"
            for i, score in enumerate(scores[5:], 6):
                horse = score.get('horse', 'ä¸æ˜')
                total = score.get('total_score', 0)
                horse_score = score.get('horse_score', 0)
                jockey_score = score.get('jockey_score', 0)
                
                content += f"{i}ä½: {horse}: {total:.1f}ç‚¹\n"
                content += f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹\n"
                
                # æ¬¡ã®é¦¬ã¨ã®é–“ã«ç©ºè¡Œã‚’è¿½åŠ ï¼ˆæœ€å¾Œã®é¦¬ä»¥å¤–ï¼‰
                if i < len(scores) - 1:
                    content += "\n"
        
        return content
    
    def _format_ilogic_batch_result(self, ilogic_result: Dict[str, Any], race_data: Dict[str, Any]) -> str:
        """
        I-Logicãƒãƒƒãƒè¨ˆç®—çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        """
        try:
            if not ilogic_result:
                return "I-Logicåˆ†æçµæœãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"
            
            # ã‚¹ã‚³ã‚¢ãŒã‚ã‚‹é¦¬ã‚’æŠ½å‡ºã—ã¦ã‚½ãƒ¼ãƒˆ
            valid_horses = []
            for horse_name, data in ilogic_result.items():
                if data.get('data_available', False) and data.get('score') is not None:
                    valid_horses.append((horse_name, data))
            
            # ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            valid_horses.sort(key=lambda x: x[1].get('score', 0), reverse=True)
            
            # çµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            lines = []
            lines.append(f"ğŸ‘‘ I-Logicåˆ†æçµæœ")
            lines.append(f"{race_data.get('venue', '')} {race_data.get('race_number', '')}R {race_data.get('race_name', '')}")
            
            # ä¸Šä½5é ­ã‚’è¡¨ç¤º
            emojis = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4ä½:', '5ä½:']
            for i, (horse_name, data) in enumerate(valid_horses[:5]):
                emoji = emojis[i] if i < 5 else f"{i+1}."
                total_score = data.get('score', 0)
                horse_score = data.get('horse_score', 0)
                jockey_score = data.get('jockey_score', 0)
                
                lines.append(f"{emoji} {horse_name}: {total_score:.1f}ç‚¹")
                lines.append(f"   é¦¬: {horse_score:.1f}ç‚¹ | é¨æ‰‹: {jockey_score:.1f}ç‚¹")
            
            # 6ä½ä»¥ä¸‹ã‚‚ç°¡æ½”ã«è¡¨ç¤º
            if len(valid_horses) > 5:
                lines.append("")
                lines.append("ã€6ä½ä»¥ä¸‹ã€‘")
                for horse_name, data in valid_horses[5:]:
                    total_score = data.get('score', 0)
                    lines.append(f"{horse_name}: {total_score:.1f}ç‚¹")
            
            # ãƒ‡ãƒ¼ã‚¿ãŒãªã„é¦¬ãŒã„ã‚‹å ´åˆã®æ³¨è¨˜
            no_data_horses = [name for name, data in ilogic_result.items() 
                            if not data.get('data_available', False)]
            if no_data_horses:
                lines.append("")
                lines.append("ã€ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã€‘")
                lines.append(f"ä»¥ä¸‹ã®é¦¬ã¯ãƒ‡ãƒ¼ã‚¿ä¸è¶³ã®ãŸã‚åˆ†æã§ãã¾ã›ã‚“ã§ã—ãŸ:")
                lines.append(f"{', '.join(no_data_horses)}")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"I-Logicçµæœãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return "I-Logicåˆ†æçµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    def _format_betting_recommendations(self, result: Dict[str, Any]) -> str:
        """
        ViewLogicé¦¬åˆ¸æ¨å¥¨çµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆå±•é–‹äºˆæƒ³ãƒ™ãƒ¼ã‚¹ï¼‰
        """
        try:
            lines = []
            lines.append("ğŸ¯ ViewLogicæ¨å¥¨é¦¬åˆ¸")
            lines.append("")
            
            venue = result.get('venue', 'ä¸æ˜')
            total_horses = result.get('total_horses', 0)
            top_5_horses = result.get('top_5_horses', [])
            recommendations = result.get('recommendations', [])
            
            lines.append(f"**é–‹å‚¬å ´**: {venue}")
            lines.append(f"**å‡ºèµ°é ­æ•°**: {total_horses}é ­")
            
            # å±•é–‹äºˆæƒ³ã®ä¸Šä½5é ­ã‚’è¡¨ç¤º
            if top_5_horses:
                lines.append("")
                lines.append("**ğŸ‡ ViewLogicå±•é–‹äºˆæƒ³ ä¸Šä½5é ­**:")
                for i, horse in enumerate(top_5_horses[:5], 1):
                    lines.append(f"  {i}. {horse}")
            
            lines.append("")
            
            if not recommendations:
                lines.append("âš ï¸ æ¨å¥¨é¦¬åˆ¸ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
                return "\n".join(lines)
            
            lines.append("### ğŸ“‹ æ¨å¥¨é¦¬åˆ¸")
            lines.append("")
            
            for rec in recommendations:
                rec_type = rec.get('type', 'ä¸æ˜')
                ticket_type = rec.get('ticket_type', 'é¦¬åˆ¸')
                horses = rec.get('horses', [])
                confidence = rec.get('confidence', 0)
                investment = rec.get('investment', 0)
                reason = rec.get('reason', '')
                buy_type = rec.get('buy_type', '')
                combinations = rec.get('combinations', 0)
                
                # æ¨å¥¨é¦¬åˆ¸ã®ã‚¢ã‚¤ã‚³ãƒ³
                icon_map = {
                    'å˜å‹': 'ğŸ¥‡',
                    'é¦¬é€£BOX': 'ğŸ“¦',
                    '3é€£å˜æµã—': 'ğŸ¯',
                    'ãƒ¯ã‚¤ãƒ‰': 'ğŸŒŸ',
                    '3é€£è¤‡BOX': 'ğŸ’°'
                }
                icon = icon_map.get(rec_type, 'ğŸª')
                
                lines.append(f"{icon} **{rec_type}**")
                
                # é¦¬åã®è¡¨ç¤ºï¼ˆè¤‡é›‘ãªå½¢å¼ã«å¯¾å¿œï¼‰
                if isinstance(horses, dict):
                    # æµã—è²·ã„ã®å ´åˆï¼ˆ3é€£å˜ãªã©ï¼‰
                    if '1ç€' in horses:
                        lines.append(f"  ã€{ticket_type}ã€‘")
                        lines.append(f"   1ç€: {', '.join(horses['1ç€'])}")
                        lines.append(f"   2ç€: {', '.join(horses['2ç€'])}")  
                        lines.append(f"   3ç€: {', '.join(horses['3ç€'])}")
                    elif 'è»¸' in horses:
                        # ãƒ¯ã‚¤ãƒ‰ã®å ´åˆ
                        lines.append(f"  ã€{ticket_type}ã€‘ {horses['è»¸']} è»¸")
                        lines.append(f"   ç›¸æ‰‹: {', '.join(horses['ç›¸æ‰‹'])}")
                elif isinstance(horses, list):
                    # é€šå¸¸ã®BOXè²·ã„ã¾ãŸã¯å˜å‹
                    if buy_type == 'BOX':
                        lines.append(f"  ã€{ticket_type}BOXã€‘ {' - '.join(horses)}")
                    else:
                        lines.append(f"  ã€{ticket_type}ã€‘ {' â†’ '.join(horses)}")
                
                # è²·ã„æ–¹è©³ç´°
                if buy_type and combinations > 0:
                    lines.append(f"   è²·ã„æ–¹: {buy_type} ({combinations}ç‚¹è²·ã„)")
                
                lines.append(f"   ğŸ’° æŠ•è³‡é¡: **{investment:,}å††**")
                lines.append(f"   ğŸ“Š ä¿¡é ¼åº¦: {confidence}%")
                if reason:
                    lines.append(f"   ğŸ’­ {reason}")
                lines.append("")
            
            # ç·æŠ•è³‡é¡
            total_investment = sum(rec.get('investment', 0) for rec in recommendations)
            lines.append("---")
            lines.append(f"ğŸ’µ **ç·æŠ•è³‡é¡**: {total_investment:,}å††")
            
            lines.append("")
            lines.append("â€» ViewLogicå±•é–‹äºˆæƒ³ã®ä¸Šä½é¦¬ã‚’åŸºã«ã—ãŸæ¨å¥¨é¦¬åˆ¸ã§ã™")
            lines.append("â€» æŠ•è³‡ã¯è‡ªå·±è²¬ä»»ã§ãŠé¡˜ã„ã—ã¾ã™")
            
            return "\n".join(lines)
            
        except Exception as e:
            logger.error(f"é¦¬åˆ¸æ¨å¥¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return "é¦¬åˆ¸æ¨å¥¨çµæœã®è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"
    
    def _format_horse_history(self, result: Dict[str, Any], horse_name: str) -> str:
        """é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è¡¨ç¤º"""
        lines = []
        lines.append(f"ğŸ‡ **{horse_name} éå»æˆ¦ç¸¾**")
        lines.append("")
        
        if result["status"] == "success" and result["races"]:
            races = result["races"]
            lines.append(f"ğŸ“Š **ç›´è¿‘{len(races)}æˆ¦ã®ãƒ‡ãƒ¼ã‚¿**")
            lines.append("")
            
            for i, race in enumerate(races, 1):
                # ãƒ¬ãƒ¼ã‚¹åŸºæœ¬æƒ…å ±ï¼ˆæ–°ã—ã„çµµæ–‡å­—ä»˜ãã‚­ãƒ¼ã¨æ—§ã‚­ãƒ¼ã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
                race_date = race.get("ğŸ“… é–‹å‚¬æ—¥", race.get("é–‹å‚¬æ—¥", "ä¸æ˜"))
                venue = race.get("ğŸŸï¸ ç«¶é¦¬å ´", race.get("ç«¶é¦¬å ´", "ä¸æ˜"))
                race_name = race.get("ğŸ ãƒ¬ãƒ¼ã‚¹", race.get("ãƒ¬ãƒ¼ã‚¹", ""))
                class_name = race.get("ğŸ† ã‚¯ãƒ©ã‚¹", race.get("ã‚¯ãƒ©ã‚¹", ""))
                distance = race.get("ğŸ“ è·é›¢", race.get("è·é›¢", "ä¸æ˜"))
                track = race.get("ğŸŒ¤ï¸ é¦¬å ´", race.get("é¦¬å ´", ""))
                
                # è¡€çµ±æƒ…å ±ã®å–å¾—
                sire = race.get("ğŸ´ çˆ¶", race.get("çˆ¶", ""))
                broodmare_sire = race.get("ğŸ æ¯çˆ¶", race.get("æ¯çˆ¶", ""))
                
                # æ—¥ä»˜ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®æ”¹å–„ï¼ˆä¾‹: 2025/0608 â†’ 2025/06/08ï¼‰
                if race_date != "ä¸æ˜" and len(race_date) == 9 and "/" in race_date:
                    parts = race_date.split("/")
                    if len(parts) == 2 and len(parts[1]) == 4:
                        year = parts[0]
                        month = parts[1][:2]
                        day = parts[1][2:]
                        race_date = f"{year}/{month}/{day}"
                
                # ãƒ¬ãƒ¼ã‚¹åã¨ã‚¯ãƒ©ã‚¹åã®è¡¨ç¤ºï¼ˆã©ã¡ã‚‰ã‹ä¸€æ–¹ã§ã‚‚è¡¨ç¤ºï¼‰
                if race_name or class_name:
                    # ãƒ¬ãƒ¼ã‚¹åã¨ã‚¯ãƒ©ã‚¹åã®çµ„ã¿åˆã‚ã›ã‚’é©åˆ‡ã«å‡¦ç†
                    if race_name and class_name:
                        race_display = f"{race_name}ï¼ˆ{class_name}ï¼‰"
                    elif race_name:
                        race_display = race_name
                    else:  # class_nameã®ã¿ã®å ´åˆ
                        race_display = class_name
                    lines.append(f"**{i}. {race_date} {venue} {race_display}**")
                else:
                    # ãƒ¬ãƒ¼ã‚¹åã‚‚ã‚¯ãƒ©ã‚¹åã‚‚ãªã„å ´åˆã¯ãƒ¬ãƒ¼ã‚¹ç•ªå·ã®ã¿
                    race_num = race.get("ğŸ ãƒ¬ãƒ¼ã‚¹", race.get("ãƒ¬ãƒ¼ã‚¹", ""))
                    if race_num:
                        lines.append(f"**{i}. {race_date} {venue} {race_num}**")
                    else:
                        lines.append(f"**{i}. {race_date} {venue}**")
                
                # è·é›¢ã¨é¦¬å ´ï¼ˆé¦¬å ´ãŒç©ºã®å ´åˆã¯ã€Œ-ã€ã‚’è¡¨ç¤ºï¼‰
                track_display = track if track else "-"
                lines.append(f"ã€€ğŸ“ è·é›¢: {distance} / é¦¬å ´: {track_display}")
                
                # æˆç¸¾æƒ…å ±ï¼ˆæ–°ã—ã„çµµæ–‡å­—ä»˜ãã‚­ãƒ¼ã¨æ—§ã‚­ãƒ¼ã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
                chakujun = race.get("ğŸ¥‡ ç€é †", race.get("ç€é †", ""))
                # "11ç€" ã®ã‚ˆã†ãªå½¢å¼ã‹ã‚‰æ•°å­—éƒ¨åˆ†ã‚’æŠ½å‡º
                if chakujun and "ç€" in str(chakujun):
                    chakujun = str(chakujun).replace("ç€", "")
                # å…ˆé ­ã®0ã‚’å‰Šé™¤ï¼ˆ"02" â†’ "2"ï¼‰
                if chakujun and str(chakujun).startswith("0") and len(str(chakujun)) > 1:
                    chakujun = str(chakujun).lstrip("0")
                
                if chakujun and str(chakujun) != "":
                    # 1-3ç€ã¯å¼·èª¿è¡¨ç¤º
                    if str(chakujun) in ["1", "2", "3"]:
                        chakujun_display = f"**ğŸ† {chakujun}ç€**"
                    else:
                        chakujun_display = f"{chakujun}ç€"
                else:
                    chakujun_display = "-"
                
                popularity = race.get("ğŸ“Š äººæ°—", race.get("äººæ°—", ""))
                # "10ç•ªäººæ°—" ã®ã‚ˆã†ãªå½¢å¼ã‹ã‚‰æ•°å­—éƒ¨åˆ†ã‚’æŠ½å‡º
                if popularity and "ç•ªäººæ°—" in str(popularity):
                    popularity = str(popularity).replace("ç•ªäººæ°—", "")
                if popularity and str(popularity) != "":
                    popularity_display = f"{popularity}ç•ªäººæ°—"
                else:
                    popularity_display = "-"
                
                lines.append(f"ã€€ğŸ“Š ç€é †: {chakujun_display} / äººæ°—: {popularity_display}")
                
                # ã‚¿ã‚¤ãƒ ã¨ä¸Šã‚Šï¼ˆæ–°ã—ã„çµµæ–‡å­—ä»˜ãã‚­ãƒ¼ã¨æ—§ã‚­ãƒ¼ã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
                time_result = race.get("â±ï¸ ã‚¿ã‚¤ãƒ ", race.get("ã‚¿ã‚¤ãƒ ", ""))
                agari = race.get("ğŸƒ ä¸Šã‚Š", race.get("ä¸Šã‚Š", ""))
                
                # ã‚¿ã‚¤ãƒ ã®è¡¨ç¤ºæ”¹å–„ï¼ˆä¾‹: 1588 â†’ 1:58.8ï¼‰
                time_display = "-"
                if time_result and str(time_result).isdigit():
                    time_str = str(time_result)
                    if len(time_str) == 4:  # 1588ã®ã‚ˆã†ãªå½¢å¼
                        time_display = f"{time_str[0]}:{time_str[1:3]}.{time_str[3]}"
                    elif len(time_str) == 3:  # 589ã®ã‚ˆã†ãªå½¢å¼ï¼ˆ1åˆ†æœªæº€ï¼‰
                        time_display = f"0:{time_str[0:2]}.{time_str[2]}"
                    else:
                        time_display = time_result
                elif time_result:
                    time_display = time_result
                
                # ä¸Šã‚Šã®è¡¨ç¤ºæ”¹å–„ï¼ˆä¾‹: 334 â†’ 33.4ï¼‰
                agari_display = "-"
                if agari and str(agari) != "":
                    agari_str = str(agari).replace("ç§’", "")  # "334ç§’"ã‹ã‚‰"ç§’"ã‚’å‰Šé™¤
                    try:
                        if agari_str.isdigit():
                            agari_int = int(agari_str)
                            if agari_int > 100:  # 334ã®ã‚ˆã†ãªå½¢å¼ã®å ´åˆ
                                agari_display = f"{agari_int/10:.1f}ç§’"
                            else:
                                agari_display = f"{agari_int:.1f}ç§’"
                        else:
                            agari_float = float(agari_str)
                            if agari_float > 100:  # 343.0ã®ã‚ˆã†ãªå½¢å¼ã®å ´åˆ
                                agari_display = f"{agari_float/10:.1f}ç§’"
                            else:
                                agari_display = f"{agari_float:.1f}ç§’"
                    except:
                        agari_display = str(agari) if agari else "-"
                
                lines.append(f"ã€€â± ã‚¿ã‚¤ãƒ : {time_display} / ä¸Šã‚Š: {agari_display}")
                
                # è¡€çµ±æƒ…å ±ã‚’è¡¨ç¤º
                if sire or broodmare_sire:
                    bloodline_parts = []
                    if sire and sire != "ä¸æ˜":
                        bloodline_parts.append(f"çˆ¶: {sire}")
                    if broodmare_sire and broodmare_sire != "ä¸æ˜":
                        bloodline_parts.append(f"æ¯çˆ¶: {broodmare_sire}")
                    if bloodline_parts:
                        lines.append(f"ã€€ğŸ§¬ è¡€çµ±: {' / '.join(bloodline_parts)}")
                
                # ãƒ¬ãƒ¼ã‚¹åãŒã‚ã‚Œã°è¿½åŠ ï¼ˆæ³¨ï¼šã“ã‚Œã¯åˆ¥ã®ãƒ¬ãƒ¼ã‚¹åãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰
                extra_race_name = race.get("ãƒ¬ãƒ¼ã‚¹å", "")
                if extra_race_name and extra_race_name != race_name:  # é‡è¤‡ã‚’é¿ã‘ã‚‹
                    lines.append(f"ã€€ğŸ“‹ {extra_race_name}")
                
                # é¨æ‰‹åãŒã‚ã‚Œã°è¿½åŠ   
                jockey = race.get("ğŸ‡ é¨æ‰‹", race.get("é¨æ‰‹", ""))
                if jockey:
                    lines.append(f"ã€€ğŸ‡ é¨æ‰‹: {jockey}")
                
                lines.append("")
            
            # çµ±è¨ˆæƒ…å ±
            # 2024-09-11: åœ°æ–¹ç«¶é¦¬ç‰ˆã®å‹ç‡ãƒ»è¤‡å‹ç‡è¨ˆç®—ã«ãƒã‚°ãŒã‚ã‚‹ãŸã‚ä¸€æ™‚çš„ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
            # TODO: è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ä¿®æ­£å¾Œã«å¾©æ´»ã•ã›ã‚‹
            """
            total_races = result.get("total_races", len(races))
            if total_races > 0:
                lines.append("ğŸ“ˆ **æˆ¦ç¸¾ã‚µãƒãƒªãƒ¼**")
                lines.append(f"ã€€ç·æˆ¦æ•°: {total_races}æˆ¦")
                
                # ç€é †åˆ†æï¼ˆæ•´æ•°å‹ã¨æ–‡å­—åˆ—å‹ã€çµµæ–‡å­—ä»˜ãã‚­ãƒ¼ã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
                win_count = 0
                place_count = 0
                valid_races = []
                
                for r in races:
                    # ç€é †ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆæ–°æ—§ä¸¡æ–¹ã®ã‚­ãƒ¼ã«å¯¾å¿œï¼‰
                    chakujun = r.get("ğŸ¥‡ ç€é †", r.get("ç€é †", ""))
                    # "11ç€" ã®ã‚ˆã†ãªå½¢å¼ã‹ã‚‰æ•°å­—éƒ¨åˆ†ã‚’æŠ½å‡º
                    if chakujun and "ç€" in str(chakujun):
                        chakujun = str(chakujun).replace("ç€", "")
                    
                    # æœ‰åŠ¹ãªç€é †ãƒ‡ãƒ¼ã‚¿ã‹ãƒã‚§ãƒƒã‚¯
                    if chakujun and str(chakujun).isdigit():
                        valid_races.append({"ç€é †": int(chakujun)})
                        if str(chakujun) == "1":
                            win_count += 1
                        if str(chakujun) in ["1", "2", "3"]:
                            place_count += 1
                if valid_races:
                    win_rate = (win_count / len(valid_races)) * 100
                    place_rate = (place_count / len(valid_races)) * 100
                    lines.append(f"ã€€ğŸ¥‡ å‹ç‡: {win_rate:.1f}% ({win_count}/{len(valid_races)})")
                    lines.append(f"ã€€ğŸ… è¤‡å‹ç‡: {place_rate:.1f}% ({place_count}/{len(valid_races)})")
                    
                    # å¹³å‡ç€é †
                    avg_position = sum(int(r.get("ç€é †")) for r in valid_races) / len(valid_races)
                    lines.append(f"ã€€ğŸ“Š å¹³å‡ç€é †: {avg_position:.1f}ç€")
                else:
                    lines.append("ã€€â€» ç€é †ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
            """
        
        else:
            lines.append("âŒ **ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“**")
            lines.append(f"ã€€{horse_name}ã®éå»æˆ¦ç¸¾ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ãªã„ã‹ã€")
            lines.append("ã€€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
        
        return "\n".join(lines)
    
    def _format_jockey_history(self, result: Dict[str, Any], jockey_name: str) -> str:
        """é¨æ‰‹ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¢ãƒã‚¤ãƒ«æœ€é©åŒ–ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§è¡¨ç¤º"""
        lines = []
        lines.append(f"ğŸ‘¤ **{jockey_name}é¨æ‰‹ ãƒ‡ãƒ¼ã‚¿**")
        lines.append("")
        
        if result["status"] == "success" and result.get("statistics"):
            stats = result["statistics"]
            
            # ç·åˆæˆç¸¾ã‚’è¡¨ç¤º
            lines.append("ğŸ“ˆ **ç·åˆæˆç¸¾ï¼ˆç›´è¿‘ãƒ‡ãƒ¼ã‚¿ï¼‰**")
            total_races = stats.get('total_races', 0)
            place_rate = stats.get('place_rate', 0)
            
            if total_races > 0:
                lines.append(f"ã€€åˆ†æå¯¾è±¡: {total_races}æˆ¦")
                lines.append(f"ã€€è¤‡å‹ç‡: {place_rate:.1f}%")
            else:
                lines.append("ã€€åˆ†æå¯¾è±¡: 0æˆ¦")
            lines.append("")
            
            # å ´æ‰€åˆ¥æˆç¸¾ï¼ˆåœ°æ–¹ç«¶é¦¬ç‰ˆã®ç‰¹å¾´ï¼‰
            if stats.get('top_venues'):
                lines.append("ğŸŸï¸ **ä¸»ãªç«¶é¦¬å ´åˆ¥æˆç¸¾**")
                for venue_stat in stats['top_venues']:
                    lines.append(f"ã€€{venue_stat}")
                lines.append("")
            
            # recent_ridesã‹ã‚‰ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºï¼ˆå‡ºèµ°æ•°ãŒ0ã§ãªã„å ´åˆã®ã¿è¡¨ç¤ºï¼‰
            if result.get("recent_rides"):
                lines.append("ğŸŸï¸ **ç«¶é¦¬å ´ãƒ»è·é›¢åˆ¥æˆç¸¾ï¼ˆç›´è¿‘ãƒ‡ãƒ¼ã‚¿ï¼‰**")
                displayed_any = False
                
                for ride in result["recent_rides"]:
                    venue = ride.get("ç«¶é¦¬å ´", "ä¸æ˜")
                    distance = ride.get("è·é›¢", "ä¸æ˜")
                    runs = ride.get("å‡ºèµ°æ•°", 0)
                    fukusho_rate = ride.get("è¤‡å‹ç‡", "0.0%")
                    
                    # å‡ºèµ°æ•°ãŒ0ã§ãªã„å ´åˆã®ã¿è¡¨ç¤º
                    if runs > 0:
                        # é¨æ‰‹ãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç›´è¿‘5æˆ¦ã®ã¿ä¿æŒ
                        display_runs = f"ç›´è¿‘{runs}æˆ¦" if runs <= 5 else f"{runs}æˆ¦"
                        lines.append(f"ã€€{venue}{distance}: {display_runs} è¤‡å‹ç‡{fukusho_rate}")
                        displayed_any = True
                
                if not displayed_any:
                    lines.append("ã€€ãƒ‡ãƒ¼ã‚¿ãªã—")
                lines.append("")
            
            # çµ±è¨ˆæƒ…å ±ã‹ã‚‰é¦¬å ´çŠ¶æ…‹åˆ¥æˆç¸¾
            if stats.get("é¦¬å ´åˆ¥æˆç¸¾"):
                lines.append("ğŸŒ§ï¸ **é¦¬å ´çŠ¶æ…‹åˆ¥æˆç¸¾ï¼ˆç›´è¿‘ãƒ‡ãƒ¼ã‚¿ï¼‰**")
                track_stats = stats["é¦¬å ´åˆ¥æˆç¸¾"]
                
                # é‡è¤‡ã‚’é™¤å»ã—ã¦è¡¨ç¤º
                seen_conditions = set()
                for track_data in track_stats:
                    condition = track_data.get("é¦¬å ´", "ä¸æ˜")
                    rate = track_data.get("è¤‡å‹ç‡", "0.0%")
                    
                    # ã€Œå¹³åœ°ãƒ»èŠã€ãªã©åŒã˜æ¡ä»¶ã¯1å›ã ã‘è¡¨ç¤º
                    if condition not in seen_conditions:
                        lines.append(f"ã€€{condition}: è¤‡å‹ç‡{rate}")
                        seen_conditions.add(condition)
                
                lines.append("")
            
            # æ é †åˆ¥æˆç¸¾
            if stats.get("æ é †åˆ¥æˆç¸¾"):
                lines.append("ğŸ¯ **æ é †åˆ¥æˆç¸¾ï¼ˆç›´è¿‘ãƒ‡ãƒ¼ã‚¿ï¼‰**")
                post_stats = stats["æ é †åˆ¥æˆç¸¾"]
                
                for post_data in post_stats:
                    post = post_data.get("æ ", "ä¸æ˜")
                    rate = post_data.get("è¤‡å‹ç‡", "0.0%")
                    lines.append(f"ã€€{post}: è¤‡å‹ç‡{rate}")
                
                lines.append("")
            
            # ç·åˆçµ±è¨ˆã¯æ—¢ã«ä¸Šéƒ¨ã§è¡¨ç¤ºæ¸ˆã¿ã®ãŸã‚ã€ã“ã“ã§ã¯è¡¨ç¤ºã—ãªã„

        
        else:
            lines.append("âŒ **ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“**")
            lines.append(f"ã€€{jockey_name}é¨æ‰‹ã®ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ãªã„ã‹ã€")
            lines.append("ã€€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
        
        return "\n".join(lines)
    
    def _get_viewlogic_5race_guide(self, race_data: Dict[str, Any]) -> str:
        """ViewLogicï¼•èµ°ã®ä½¿ã„æ–¹æ¡ˆå†…ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"""
        venue = race_data.get('venue', '')
        race_number = race_data.get('race_number', '')
        
        lines = []
        lines.append("ğŸ‡ **ViewLogicï¼•èµ°ã®ä½¿ã„æ–¹**")
        lines.append("")
        lines.append(f"**{venue}{race_number}R**ã«å‡ºèµ°ã™ã‚‹**é¦¬å**ã¾ãŸã¯**é¨æ‰‹å**ã‚’1ã¤ã ã‘å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚")
        lines.append("")
        lines.append("ğŸ“Š **å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿**")
        lines.append("â€¢ ãƒŠãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰**ç›´è¿‘5èµ°**ã®è©³ç´°ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º")
        lines.append("â€¢ ãƒ¬ãƒ¼ã‚¹çµæœã€ç€é †ã€ã‚¿ã‚¤ãƒ ã€æ¡ä»¶ç­‰ã®å±¥æ­´æƒ…å ±")
        lines.append("â€¢ æˆç¸¾åˆ†æï¼ˆå‹ç‡ã€è¤‡å‹ç‡ã€å¹³å‡ç€é †ï¼‰")
        lines.append("")
        lines.append("ğŸ’¡ **å…¥åŠ›ä¾‹**")
        lines.append("â€¢ é¦¬åã®ã¿ï¼šã€Œãƒ‰ã‚¦ãƒ‡ãƒ¥ãƒ¼ã‚¹ã€")
        lines.append("â€¢ é¨æ‰‹åã®ã¿ï¼šã€Œæ­¦è±Šã€")
        lines.append("â€¢ ãƒ•ãƒ«ãƒãƒ¼ãƒ ï¼šã€ŒåŒ—æ‘å‹ä¸€ã®éå»5èµ°ã€")
        lines.append("")
        lines.append("âš ï¸ **æ³¨æ„äº‹é …**")
        lines.append("â€¢ **1å›ã®å…¥åŠ›ã§1ã¤ã®å¯¾è±¡ã®ã¿**åˆ†æå¯èƒ½")
        lines.append("â€¢ è¤‡æ•°ã®é¦¬åã‚„é¨æ‰‹åã‚’åŒæ™‚ã«å…¥åŠ›ã™ã‚‹ã¨åå¿œã—ã¾ã›ã‚“")
        lines.append("â€¢ ã“ã®ãƒ¬ãƒ¼ã‚¹ã«å‡ºèµ°ã—ãªã„é¦¬ãƒ»é¨æ‰‹ã¯åˆ†æã§ãã¾ã›ã‚“")
        lines.append("")
        lines.append("ğŸ”„ **ãƒ‡ãƒ¼ã‚¿æ›´æ–°**")
        lines.append("â€¢ ãƒŠãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯**æ¯æœˆç¬¬ä¸€æœˆæ›œæ—¥**ã«æ›´æ–°")
        lines.append("â€¢ æœ€æ–°ã®ç«¶èµ°çµæœãŒåæ˜ ã•ã‚Œã¦ã„ã¾ã™")
        lines.append("")
        lines.append("âœ¨ ã•ã£ããé¦¬åã¾ãŸã¯é¨æ‰‹åã‚’1ã¤å…¥åŠ›ã—ã¦è©¦ã—ã¦ã¿ã¦ãã ã•ã„ï¼")

        return "\n".join(lines)

    def _generate_sire_analysis(self, race_data: Dict[str, Any]) -> Tuple[str, Optional[Dict]]:
        """
        ç¨®ç‰¡é¦¬åˆ†æã‚’ç”Ÿæˆ
        å‡ºèµ°é¦¬ã®çˆ¶ã€æ¯ã€æ¯çˆ¶ã‚’è¡¨ç¤º

        Returns:
            (content, analysis_data) ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            venue = race_data.get('venue', '')
            race_number = race_data.get('race_number', '')
            horses = race_data.get('horses', [])

            # åœ°æ–¹ç«¶é¦¬ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            is_local = self._is_local_racing(venue)

            # çµ±åˆãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            # åˆæœŸåŒ–æ¸ˆã¿ã®DLogicãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä½¿ç”¨ï¼ˆé«˜é€ŸåŒ–ï¼‰
            dlogic_manager = self.dlogic_manager

            lines = []
            lines.append("ğŸ‡ **è¡€çµ±åˆ†æ**")
            lines.append(f"ğŸ“ {venue} {race_number}R")
            lines.append("")

            # å„é¦¬ã®è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            for i, horse in enumerate(horses):
                horse_number = i + 1

                # é¦¬åã‚’å–å¾—ï¼ˆè¾æ›¸å½¢å¼ã¨æ–‡å­—åˆ—å½¢å¼ã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
                if isinstance(horse, dict):
                    horse_name = horse.get('é¦¬å', horse.get('name', ''))
                else:
                    horse_name = str(horse)

                if not horse_name:
                    continue

                # è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                pedigree_data = self._get_horse_pedigree(dlogic_manager, horse_name)

                # é¦¬ç•ªã«å¿œã˜ãŸçµµæ–‡å­—ã‚’è¨­å®š
                number_emojis = ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ', 
                                '1ï¸âƒ£1ï¸âƒ£', '1ï¸âƒ£2ï¸âƒ£', '1ï¸âƒ£3ï¸âƒ£', '1ï¸âƒ£4ï¸âƒ£', '1ï¸âƒ£5ï¸âƒ£', '1ï¸âƒ£6ï¸âƒ£', '1ï¸âƒ£7ï¸âƒ£', '1ï¸âƒ£8ï¸âƒ£']
                number_emoji = number_emojis[horse_number - 1] if horse_number <= 18 else f"{horse_number}ç•ª"
                
                # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå‡ºåŠ›
                lines.append(f"{number_emoji} **{horse_name}** ğŸ")

                if pedigree_data:
                    sire = pedigree_data.get('sire', 'ãƒ‡ãƒ¼ã‚¿ãªã—')
                    dam = pedigree_data.get('dam', None)
                    broodmare_sire = pedigree_data.get('broodmare_sire', 'ãƒ‡ãƒ¼ã‚¿ãªã—')

                    lines.append(f"ã€€ğŸ‘¨ çˆ¶ï¼š{sire}")
                    if dam and dam != '':
                        lines.append(f"ã€€ğŸ‘© æ¯ï¼š{dam}")
                    lines.append(f"ã€€ğŸ‘´ æ¯çˆ¶ï¼š{broodmare_sire}")
                else:
                    lines.append("ã€€â“ è¡€çµ±ãƒ‡ãƒ¼ã‚¿ãªã—")

                lines.append("")  # 1è¡Œç©ºã‘ã‚‹

            content = "\n".join(lines)

            # åˆ†æãƒ‡ãƒ¼ã‚¿ã‚‚è¿”ã™ï¼ˆå°†æ¥çš„ãªæ‹¡å¼µç”¨ï¼‰
            analysis_data = {
                'venue': venue,
                'race_number': race_number,
                'type': 'sire_analysis',
                'horses_count': len(horses)
            }

            return (content, analysis_data)

        except Exception as e:
            logger.error(f"ç¨®ç‰¡é¦¬åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
            return (f"ç¨®ç‰¡é¦¬åˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}", None)

    def _get_horse_pedigree(self, dlogic_manager, horse_name: str) -> Optional[Dict[str, str]]:
        """
        çµ±åˆãƒŠãƒ¬ãƒƒã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰é¦¬ã®è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—

        Args:
            dlogic_manager: DLogicRawDataManager ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            horse_name: é¦¬å

        Returns:
            è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ {'sire': çˆ¶å, 'dam': æ¯å, 'broodmare_sire': æ¯çˆ¶å}
        """
        try:
            # é¦¬ã®éå»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            horse_data = dlogic_manager.get_horse_raw_data(horse_name)

            if not horse_data or 'races' not in horse_data:
                logger.warning(f"é¦¬ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {horse_name}")
                return None

            # æœ€æ–°ã®ãƒ¬ãƒ¼ã‚¹ã‹ã‚‰è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            races = horse_data.get('races', [])
            if not races:
                return None

            # æœ€æ–°ãƒ¬ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
            latest_race = races[0]

            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰29, 30, 31ã‹ã‚‰è¡€çµ±ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            pedigree = {
                'sire': latest_race.get('sire', latest_race.get('29', 'ãƒ‡ãƒ¼ã‚¿ãªã—')),
                'dam': latest_race.get('dam', latest_race.get('30', '')),
                'broodmare_sire': latest_race.get('broodmare_sire', latest_race.get('31', 'ãƒ‡ãƒ¼ã‚¿ãªã—'))
            }

            # ç©ºæ–‡å­—ã®å ´åˆã¯Noneã«å¤‰æ›
            if pedigree['dam'] == '':
                pedigree['dam'] = None

            return pedigree

        except Exception as e:
            logger.error(f"è¡€çµ±ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼ ({horse_name}): {e}")
            return None
